---
url: /zhCN/lxguide/report-issue.md
---
`@useFixer`

# **报告异常&建言新策**

*创建日期 2023年11月27日，修改日期 2023年11月27日 作者：Feiron Iguista*

::: info

再次感谢您选择使用LauncherX，并且还愿意来了解如何反馈问题和提出建议！

:::

\[\[toc]]

## 异常反馈

您有很多方法向我们反馈。一般来说，只要能与我们取得联系，那您就可以反馈问题。但是特定的方法有助于我们整理、记录和追踪问题，所以接下来我将依照我们推荐的顺序来列出一般可用的反馈方式。`i`

另外，您或许应该在反馈前阅读关于提供错误信息的指引：[如何找到有效的错误信息和日志文件 ](/zhCN/lxguide/others/report-with-logs.md) 我们仅有在有日志文件的情况下才能更好地定位问题！`i`

### 使用Github（推荐）或Gitee上的LauncherX Issue Tracker （LXIT）

这类代码托管平台一般都有完备的Issue系统（您如果不知道这是什么的话，可以理解为：一个用于归纳问题和建议的反馈系统），我们团队中负责LauncherX者都会在您于此处提交issue时收到邮件提醒。`i`

您提交的内容，首先必须满足以下两个条件：

* 不能和其中现有的项目重复。如果您想要提交的内容已经有他人提交并且您想作出一些补充，请直接在他人已提交的issue下作出补充。
* 不能是无意义的内容。我们有群聊供您大放异想天开之彩。

然后，希望您能够遵守以下约定，以让我们能有最高效的问题处理能力：

::: warning

翻译者请注意：这一段是援引自@CodingEric已经锁定的置顶issue：[LXIT Submission Guidelines · Issue #1 · Corona-Studio/LXIT (github.com)](https://github.com/Corona-Studio/LXIT/issues/1)。这些内容同样需要进行本地化。

:::

LXIT是LauncherX的问题追踪计划。请所有参与测试的人员务必严格遵循以下规程，否则您的请求可能不会受到回应。`i`

对于问题报告，需要：

* 系统信息
* 复现步骤

对于新功能请求，需要：

* 功能描述
* 引入原因
* 如果可能，绘制用户界面示意图或者程序流程图

我们不明确规定issue的格式，您也可以同时将多个问题/功能请求写入至同一个issue中。标题不重要，但最好能简明概括问题。`i`

以下issue不被允许：

* 没有实质性内容
* 使用过激语言等其他恶意行为

感谢您的参与！ // *结束*

##### 前往Issue Tracker：

* Github：[Corona-Studio/LXIT: Issue tracker of LauncherX / LauncherX 议题追踪仓库 (github.com)](https://github.com/Corona-Studio/LXIT/issues)
* Gitee(可能不会及时回应)：[Issues · Feiron Iguista/LXIT - LauncherX Issue Tracker - Gitee.com](https://gitee.com/feironiguista/corona-lxit/issues)

***

### 通过KOOK或Discord频道(暂未创建)反馈

您可以在很多地方找到我们更新的服务器邀请。一般而言，您在加入并通过验证之后，需要在频道的列表中寻找类似于：**【反馈】LauncherX** 的文字频道。`i`

**但是！** 您必须遵守以下的格式进行反馈。与此同时，和上一条一样，无意义的、重复的内容不能提交。如果您想要补充说明已存在的问题，请找到它并点击回复。`i`

格式示范：

```
简述：界面动画卡顿
版本：（请在设置-关于 中找到出现问题的LauncherX版本。）
详细：在切换界面的时候动画总是一卡一卡的。
环境信息：macOS 13.1 arm（系统版本，系统架构。请注意：如果您在使用架构不正确的构建，则请不要发送这条反馈，除非正确的构建中也有这个问题。）  | 开启了低电量模式（补充一些您觉得可能造成问题的情况，比如您当前的内存占用率？您是否在使用第三方杀毒软件？）
复现步骤：（请使用序号标注尽可能详细的导致问题再次出现的步骤。）
```

##### 邀请链接：

* KOOK： [KOOK (kookapp.cn)](https://www.kookapp.cn/app/invite/rCdGVn)
* Discord： \[暂无]

***

### (非常不推荐的方法) QQ私聊 > QQ群内反馈 > 发邮件

::: warning

不是不行，但是整理起来真的很麻烦，而且有很大概率会忘记。并且，您的建言贡献不会被记录，而是随着时间与聊天记录流过而被遗忘。

:::

在这些渠道进行反馈是效率十分低下的。虽然看起来好像能够获得我们第一时间的反应，但是整个流程是不清晰的。尤其是在群内反馈，**单线程的消息流中随时可能会被其他人的闲聊扰乱，进而进一步对问题反馈带来干扰**。不过无论如何，**有格式的内容充足的反馈总是比混乱的反馈更好**.`i`

***

### 奇怪的方法：加入我们，手动修复

您如果觉得您“一眼看出了问题所在” 并且确信自己“有能力修复”，而且打算“长期地与我们一起创造些什么”，您随时可以加入审核群！审核群的群号：**1040526762** `i`

***

### 另外，哪些用于反馈的信息是有用的，该如何获取有用的信息?

一般而言，截图是非常直观的信息载体。但是倘若能包含错误信息，将会更好! 比如，在「任务中心」的错误，一般会包含被折叠的错误堆栈追踪。您应该将它展开然后进行截图，这样包含的信息是很全面的。`i`

我们可能会需要您提供复现步骤或者是在您那边的LauncherX行为 (或者说，症状)，这个时候或许需要您进行屏幕录制。对于Windows 10或更新版本的用户，如果您的系统没有被精简，可以使用 XBox Game Bar的录制窗口功能 (参见: [Xbox: 了解 Windows 上的 Game Bar](https://support.xbox.com/zh-CN/help/games-apps/game-setup-and-play/get-to-know-game-bar-on-windows-10) ) ; 否则，您可以使用QQ的屏幕录制。对于macOS用户，可以使用`⌘ + ⇧ + 5` (command + shift + 5) 以进行屏幕录制。对于Linux用户或其他无法使用上述录屏工具的用户，可以下载OBS进行录制。(参见: [知乎: OBS录屏安装与简单使用方法](https://zhuanlan.zhihu.com/p/425486889))`i`

倘若游戏发生了致命错误并退出，仍然还有[保留的日志窗口或错误分析窗口](/zhCN/lxguide/features/log-window)可供分析游戏错误。那假如LauncherX发生了崩溃，一般也只有macOS会有系统级别的错误报告弹窗了，在哪里寻找错误报告呢? 请阅读: [如何找到更全面的日志文件](/zhCN/lxguide/others/report-with-logs) `i`

一般而言，我们不强求一般用户向我们详细反馈问题。但是我们希望热心市民能够提供重要且充足的错误信息，一方面帮助我们改进LauncherX，另一方面我们可以帮助您解决问题。目前，**发现并最先报告恶性bug的用户将有机会受邀加入内测** ! `i`

## 功能建议

实际上，您可以在**标明“这是一条建议”的基础上**，像反馈问题一样提交您的建议。`i`

一般而言，您需要：

* 尽可能详尽地描述您希望添加的内容
* 如果可能的话，请绘制示意图。可以在截屏的基础上圈圈点点，也可以制作框架图、甚至是原型设计（这样您或许会收到加入我们的邀请！）
* 阐述您为什么想要这些
* 最重要的：您需要在标题注明这是建议！比如：把“【建议】” 放在标题的开头。

***

::: tip

再次感谢您对项目的付出！

:::

---

---
url: /enUS/lxguide/add-game-account.md
---
# Add a game account to LauncherX

\[\[toc]]

Edited date: February 27, 2023 | Feiron Iguista | Japerz

## Preface

In this guide, we recommend that you prioritize using an official Microsoft account to log in to your Minecraft. Although the official has not made clear its opposition to games without genuine verification such as offline mode, we still recommend that you support and maintain intellectual property rights by purchasing Minecraft. **Using an offline copy of Minecraft may result in infringement, so all consequences will be borne by you and LauncherX is not responsible for it.**

This article will guide you in using LauncherX to add **Local Only** game accounts during initial use and subsequent use, including the following types:

* Microsoft Account
* Offline Mode Account
* AuthLib Account(Original Mojang account login)

*Since the official has stopped supporting Mojang accounts and started migrating Mojang accounts to Microsoft accounts, LauncherX will no longer support Mojang account login. For More Details: [Mojang Java Edition Minecraft Account Move | Minecraft](https://help.minecraft.net/hc/en-us/articles/19615552270221)*

## Initial Setup

When you use LauncherX for the first time, you will see LauncherX greet you and ask you to perform some initial settings necessary to use LauncherX. When you reach the "Add Account" step, you can choose one of the following operations. Click the "Add" button to get started.

### Microsoft Acount Login

Click the "Microsoft Account" button in the pop-up window, LauncherX will pop up another window (verification information window) containing a verification link, a one-time verification code and some buttons.

![image-20230222204440416](/assets/image-20230222204440416.CbZu2DPU.png)

The entire process takes about 10 seconds to complete (this may take a little longer depending on network performance and whether your browser saves your Microsoft account login information).
Taking into account Microsoft's privacy policy, we recommend that you complete this process within 3 minutes to avoid invalidation of the one-time verification code. If the one-time code fails, you need to close the current verification information window and repeat the operation of adding a Microsoft account.

* Click "Copy Code" to copy the one-time code you need to use for this login to the clipboard. *[\[Microsoft\]Clipboard in Windows](https://support.microsoft.com/en-us/windows/clipboard-in-windows-c436501e-985d-1c8d-97ea-fe46ddf338c6)*
* Click "Open Verification Page" to open the Microsoft account verification page through your default browser.
* Paste the one-time code you copied into the specified location as prompted on the web page. If Microsoft requires you to log in, please log in to your Microsoft account on the web page first.
* After this window pops up, you need to "agree" to continue adding the account.

![image-20230222204659302](/assets/image-20230222204659302.3ad4zMoe.png)

While LauncherX is verifying your account, you can continue with the next step of setup.

If you think the verification process is too slow or failing, consider optimizing your current network environment (for example, using an accelerator for Xbox login or trying to move closer to your wireless network source, if you are using one.)

#### Unexpected situation: Edge browser pops up requiring security verification device:

![image-20230222204732083](/assets/image-20230222204732083.BMhcgG6A.png)

For this case, you need:

* Hit "Cancel"
* Click "Other login methods" on the web page, as shown in the figure:![image-20230222204925338](/assets/image-20230222204925338.kW0y5m6W.png)
* Click "Use my password" or choose any login method that's convenient for you: ![image-20230222205034775](/assets/image-20230222205034775.BycQG9xY.png)

### Offline Mode

This is arguably the easiest way to add an account. You can use LauncherX to enable custom skins for your local game. This feature will only take effect on your local client. See: Game Account Management/Skin Preview
**But I still want to remind you that using the offline version may be illegal and result in legal consequences, and you will be responsible for all the consequences.**

* Click "Offline Account"
* Enter any player name you want. Note that some versions (especially older versions) do not support non-English and English character IDs.
* Offline mode only allows you to play local games and servers that support offline login.

### AuthLib

Use a special login verification service with the help of [AuthLib-Injector](https://github.com/yushijinhun/authlib-injector). Before choosing this option to log in, you should confirm that you have an AuthLib external login service from one party.

To do this, you need to prepare:

* External login verification email
* Corresponding password
* The AuthLib server address corresponding to the authentication service (this is necessary for external logins, because LauncherX does not know whose Yggdrasil API you need to authenticate to. Typically, this address is something like "https://\<service provider's domain name>/api/yggdrasil”)"

Click "External Login" to get started.

* A window as shown in the picture will pop up: ![image-20230227091559255](/assets/image-20230227091559255.BP6hakQE.png)
* Enter the information you should have prepared previously
* Save account. This information will be encrypted and used as credentials, which will be used for verification after you log in to the server that supports the corresponding AuthLib service.

## More setup

After completing the initial setup, you can enter **Settings-Account** to add more game accounts.

After clicking "Add Account", everything is exactly the same as when you first set up LauncherX. We recommend that you add an offline account with the same ID after adding a Microsoft account to avoid the problem that some games cannot be started when online or not.

---

---
url: /enUS/projbobcat/resourceCompleter/resourceInfoResolver/assetInfoResolver.md
---
# Assets resolver

\[\[toc]]

The Assets resolver provides parsing and verification functions for game asset files. These files are generally stored in
`.minecraft/assets` directory

## Get the Version Manifest Versions list

First, you need to submit a request to <https://launchermeta.mojang.com/mc/game/version_manifest.json>
Send an **HTTP GET** request.

You will see something similar to the following returned:

```json

{
  "latest": {
    "release": "1.19.3",
    "snapshot": "23w06a"
  },
  "versions": [
    {
      "id": "23w06a",
      "type": "snapshot",
      "url": "https://piston-meta.mojang.com/v1/packages/92ed97b686fe8904d8ec00fd486c435582fd0155/23w06a.json",
      "time": "2023-02-08T15:11:06+00:00",
      "releaseTime": "2023-02-08T15:00:04+00:00"
    },
    ...
  ]
}

```

The Mojang server will return a JSON object, and the **versions** field is the Versions array we need.

### Convert JSON return to ProjBobcat type

If you are using [JSON.NET](https://www.newtonsoft.com/json)(Newtonsoft.JSON) in your project.
You can use code similar to the following to convert the server response you get into the corresponding ProjBobcat type:

```c#

// Requesting data from the Mojang API (example, not actual code)
...
var responseJson = await res.Content.ReadAsStringAsync();

// Convert JSON response to ProjBobcat type // [!code focus]
var manifest = JsonConvert.DeserializeObject<VersionManifest>(responseJson); // [!code focus]

// Get the Versions list // [!code focus]
var versions = manifest.Versions; // [!code focus]

```

Here, **versions** is the `Versions` array required by the Assets resolver.

## Initialize resolver

You can initialize the Assets resolver with the following code:

```c#

var resolver = new AssetInfoResolver
{
    AssetIndexUriRoot = "https://launchermeta.mojang.com/",
    AssetUriRoot = "https://resources.download.minecraft.net/",
    BasePath = "[GAME_ROOT_PATH]",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES],
    Versions = versions // Versions array obtained in the previous step
};

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:-----------------------:|:-------------------------------:|
| \[GAME\_ROOT\_PATH] | The game root directory, usually the path to the .minecraft folder |
| \[SEARCHED\_VERSION\_INFO] | VersionInfo of the version to check (obtained via game locator) |
| \[CHECK\_LOCAL\_FILES] | Check local files (if false, skip all checks) |

---

---
url: /ruRU/projbobcat/resourceCompleter/resourceInfoResolver/assetInfoResolver.md
---
# Assets 解析器

\[\[toc]]

Assets 解析器提供了对游戏资产文件的解析和验证功能, 这些文件一般存放在
`.minecraft/assets` 目录下

## 获取 Version Manifest Versions 列表

首先, 您需要向 <https://launchermeta.mojang.com/mc/game/version_manifest.json>
发送一个 **HTTP GET** 请求.

您将看到类似下面的返回内容：

```json

{
  "latest": {
    "release": "1.19.3",
    "snapshot": "23w06a"
  },
  "versions": [
    {
      "id": "23w06a",
      "type": "snapshot",
      "url": "https://piston-meta.mojang.com/v1/packages/92ed97b686fe8904d8ec00fd486c435582fd0155/23w06a.json",
      "time": "2023-02-08T15:11:06+00:00",
      "releaseTime": "2023-02-08T15:00:04+00:00"
    },
    ...
  ]
}

```

Mojang 服务器将会返回一个 JSON 对象, **versions** 字段则是我们所需要的 Versions 数组

### 将 JSON 返回转换为 ProjBobcat 类型

如果您在您的项目中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）.
您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型：

```c#

// 从 Mojang API 请求数据（示例, 非实际代码）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus]
var manifest = JsonConvert.DeserializeObject<VersionManifest>(responseJson); // [!code focus]

// 获取 Versions 列表 // [!code focus]
var versions = manifest.Versions; // [!code focus]

```

此处, **versions** 即是 Assets 解析器所需要的 `Versions` 数组.

## 初始化解析器

你可以通过下面的代码来初始化 Assets 解析器：

```c#

var resolver = new AssetInfoResolver
{
    AssetIndexUriRoot = "https://launchermeta.mojang.com/",
    AssetUriRoot = "https://resources.download.minecraft.net/",
    BasePath = "[GAME_ROOT_PATH]",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES],
    Versions = versions // 在上一步获取到的 Versions 数组
};

```

在上述代码块中, 请将这些参数按照您的实际情况替换：

|           项目            |               说明                |
|:-----------------------:|:-------------------------------:|
|    \[GAME\_ROOT\_PATH]     |   游戏根目录, 通常为 .minecraft 文件夹的路径   |
| \[SEARCHED\_VERSION\_INFO] | 要检查的版本的 VersionInfo （通过游戏定位器获得） |
|   \[CHECK\_LOCAL\_FILES]   |    检查本地文件（如果为 false, 则跳过所有检查）    |

---

---
url: /zhCN/projbobcat/resourceCompleter/resourceInfoResolver/assetInfoResolver.md
---
# Assets 解析器

\[\[toc]]

Assets 解析器提供了对游戏资产文件的解析和验证功能，这些文件一般存放在
`.minecraft/assets` 目录下

## 获取 Version Manifest Versions 列表

首先，您需要向 <https://launchermeta.mojang.com/mc/game/version_manifest.json>
发送一个 **HTTP GET** 请求。

您将看到类似下面的返回内容：

```json
{
  "latest": {
    "release": "1.19.3",
    "snapshot": "23w06a"
  },
  "versions": [
    {
      "id": "23w06a",
      "type": "snapshot",
      "url": "https://piston-meta.mojang.com/v1/packages/92ed97b686fe8904d8ec00fd486c435582fd0155/23w06a.json",
      "time": "2023-02-08T15:11:06+00:00",
      "releaseTime": "2023-02-08T15:00:04+00:00"
    },
    ...
  ]
}
```

Mojang 服务器将会返回一个 JSON 对象，**versions** 字段则是我们所需要的 Versions 数组

### 将 JSON 返回转换为 ProjBobcat 类型

如果您在您的项目中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）。
您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型：

```c#
// 从 Mojang API 请求数据（示例，非实际代码）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus]
var manifest = JsonConvert.DeserializeObject<VersionManifest>(responseJson); // [!code focus]

// 获取 Versions 列表 // [!code focus]
var versions = manifest.Versions; // [!code focus]
```

此处，**versions** 即是 Assets 解析器所需要的 `Versions` 数组。

## 初始化解析器

你可以通过下面的代码来初始化 Assets 解析器：

```c#
var resolver = new AssetInfoResolver
{
    AssetIndexUriRoot = "https://launchermeta.mojang.com/",
    AssetUriRoot = "https://resources.download.minecraft.net/",
    BasePath = "[GAME_ROOT_PATH]",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES],
    Versions = versions // 在上一步获取到的 Versions 数组
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|           项目            |               说明                |
|:-----------------------:|:-------------------------------:|
|    \[GAME\_ROOT\_PATH]     |   游戏根目录，通常为 .minecraft 文件夹的路径   |
| \[SEARCHED\_VERSION\_INFO] | 要检查的版本的 VersionInfo （通过游戏定位器获得） |
|   \[CHECK\_LOCAL\_FILES]   |    检查本地文件（如果为 false，则跳过所有检查）    |

---

---
url: /zhTW/projbobcat/resourceCompleter/resourceInfoResolver/assetInfoResolver.md
---
# Assets 解析器

\[\[toc]]

Assets 解析器提供了對遊戲資產檔案的解析和驗證功能, 這些檔案一般存放在
`.minecraft/assets` 目錄下

## 獲取 Version Manifest Versions 列表

首先, 您需要向 <https://launchermeta.mojang.com/mc/game/version_manifest.json>
傳送一個 **HTTP GET** 請求.

您將看到類似下面的返回內容：

```json

{
  "latest": {
    "release": "1.19.3",
    "snapshot": "23w06a"
  },
  "versions": [
    {
      "id": "23w06a",
      "type": "snapshot",
      "url": "https://piston-meta.mojang.com/v1/packages/92ed97b686fe8904d8ec00fd486c435582fd0155/23w06a.json",
      "time": "2023-02-08T15:11:06+00:00",
      "releaseTime": "2023-02-08T15:00:04+00:00"
    },
    ...
  ]
}

```

Mojang 伺服器將會返回一個 JSON 物件, **versions** 欄位則是我們所需要的 Versions 陣列

### 將 JSON 返回轉換為 ProjBobcat 型別

如果您在您的專案中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）.
您可以使用類似下面的程式碼來將您獲取到的伺服器響應轉換為對應的 ProjBobcat 型別：

```c#

// 從 Mojang API 請求資料（示例, 非實際程式碼）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 將 JSON 響應轉換為 ProjBobcat 型別 // [!code focus]
var manifest = JsonConvert.DeserializeObject<VersionManifest>(responseJson); // [!code focus]

// 獲取 Versions 列表 // [!code focus]
var versions = manifest.Versions; // [!code focus]

```

此處, **versions** 即是 Assets 解析器所需要的 `Versions` 陣列.

## 初始化解析器

你可以透過下面的程式碼來初始化 Assets 解析器：

```c#

var resolver = new AssetInfoResolver
{
    AssetIndexUriRoot = "https://launchermeta.mojang.com/",
    AssetUriRoot = "https://resources.download.minecraft.net/",
    BasePath = "[GAME_ROOT_PATH]",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES],
    Versions = versions // 在上一步獲取到的 Versions 陣列
};

```

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|           專案            |               說明                |
|:-----------------------:|:-------------------------------:|
|    \[GAME\_ROOT\_PATH]     |   遊戲根目錄, 通常為 .minecraft 資料夾的路徑   |
| \[SEARCHED\_VERSION\_INFO] | 要檢查的版本的 VersionInfo （透過遊戲定位器獲得） |
|   \[CHECK\_LOCAL\_FILES]   |    檢查本地檔案（如果為 false, 則跳過所有檢查）    |

---

---
url: /enUS/projbobcat/additionalParsers.md
---
# Attached parser

In order to maintain the same behavior as Mojang's official launcher, ProjBobcat has implemented some additional parsers to help us keep data and files in sync with the official launcher.

The following table shows the currently implemented parsers:

|              Name              |          Description           |
|:----------------------------:|:---------------------:|
| DefaultLauncherAccountParser | Configuration file used to write verification information to the official launcher  |
| DefaultLauncherProfileParser | Used to write the searched local games to the launcher's configuration file |

---

---
url: /enUS/projbobcat/authenticators.md
---
# Authentication model

In ProjBobcat, we have implemented for developers all the authentication scenarios you may encounter during MineCraft development.

## Support list

| Model | Applicable situations |
|:-----------------------:|:-----------------------:|
| OfflineAuthenticator | Offline authentication model |
| YggdrasilAuthenticator | Login model for older versions |
| MicrosoftAuthenticator | New version of Microsoft authentication model |

---

---
url: /enUS/projbobcat/beforeWeStart.md
---
# Before we begin

Before we officially start using ProjBobcat, you need to make necessary checks and adjustments to your project properties to meet the running needs of ProjBobcat.

\[\[toc]]

## Runtime requirements

You need to ensure that your project's dotNET framework is running at least .NET 6.0 and higher.

Currently supported .NET versions:

* .NET 6.0
* .NET 7.0 (recommended)

::: warning

We have removed support for the **.NET 5.0** runtime in a previous version update.

:::

## Project properties

Due to Windows system mechanics, you need to turn off the build option for **Prefer 32-bit** in the project properties. Otherwise, you may experience unexpected results when using some components of ProjBobcat.

You need to switch to the project's properties page in Visual Studio and find the checkbox for **Prefer 32-bit** and uncheck it.

## 32-bit system support

::: warning

ProjBobcat decided to give up all support for 32-bit systems from the beginning of the project because it is wayyyyyyy to old LMAO

:::

---

---
url: /zhCN/CMFS/servers/pure/survival.md
---
# CMFS Pure 原版群组-生存服

::: info 连接信息

地址：pure.craftmine.fun

备用：pure.cmfs.kami.su

游戏版本：原版1.20~1.21.5

服务器核心版本：Leaf/Paper, 1.21.4

群聊：`805935004`

:::

## 规则

* 不许开挂，不许恶意杀人，不许卡破坏性bug，不许卡服
* 玩家有权自行使用`/co i`进行查询
* 玩家可以借助木斧测距，但是没有其他建筑功能
* 禁止在历史问题遗留区域制造世吞等会造成连续爆炸和方块破坏的机械（区域：1752 6056; 1752 -312; 8384 -312; 8384 6056）
* 禁止其他违反公序良俗的行为

## 玩法

轻微修改的原版生存！服务端恢复了**无头活塞、刷线**等轻生电必备的【特性】，并且加入了一些扩展性的玩法和细节：

* 你可以对怪物扔砖头！有真实伤害的！
* 遇到险情？使用命令`/sos`广播呼救！
* 组织你的聚落！带上你的伙伴→准备一个聚落名称和合适的头衔文字颜色→向管理员申请创建你的聚落，即可为聚落成员启用唯一的聊天区标识！
* 彩色聊天文字！使用 `/setchatcolor <颜色代码>` (支持16进制颜色码) 为你的聊天文本应用颜色！
* 新手（死亡不掉落、禁用PVP）保护！（累计游玩50游戏日将自动移除新手保护）~ 如果觉得自己不需要，可以关闭自己的新手保护：命令 `/disable-my-protect`后在聊天区发送`y`来关闭
* 游戏日查询和全服游戏日榜单（命令 `/age`）
* 日历系统！记录日期，看自己的聚落每天成长的一点一滴
* 可以手动用腐肉进行堆肥！
* 试试用火矢点燃篝火！
* 幻翼骑乘！建筑玩家狂喜2333
* 双主世界！我们将旧时代的CMFS原版生存服的主世界接入到了此服务器，去参观以前内部人员的建造吧！
* 还有更多实用小命令等你尝试！`/report`、`/joke`、`/logoff`、`/random-info`...

---

---
url: /zhCN/CMFS/help.md
---
# CMFS 帮助

::: info

这里提供了一些您可能需要的服务器游戏帮助。

:::

---

---
url: /zhCN/CMFS/servers/pure/radost.md
---
# CMFS-Radost 小游戏共建生态

> 如果你有开服经验和玩法想法，我们可以一起实现！你将获得：1）对应子服OP；2）提交你的玩法并保留你的服务端自主权；3）与CMFS管理组一并协调管理玩法！加群【】

「Radost」一词来自俄语的“Радость”, 希望你在这里感受基于原版游戏的快节奏小游戏的快乐！此系列服务器与Pure共用群组入口。

::: info 连接信息

接受的游戏版本：

地址：`pure.craftmine.fun`

备用地址：`pure.cmfs.kami.su` | `pure.cmfs.vot.moe`

群聊：`805935004`

:::

---

---
url: /enUS/projbobcat/createNewAzureApp.md
---
# Configure Azure application

\[\[toc]]

## Start configuration

Before you get started, you first need a Microsoft account. There is no cost to register an Azure Active Directory app.

Sign in to [Azure Portal](https://portal.azure.com/#home) using your Microsoft account
After logging in, the page you see should look like this:

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_1.png)

Click **Azure Active Directory** under **Azure Services**

![Azure AD](/img/projbobcat/installationAndConfig/configMSAuth/azure_ad.png)

You will see a page similar to the following

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_2.png)

Then click **App Registration** on the left tool bar:

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/reg_app.png)

Click **New Registration** on the top toolbar and fill in the name of the application. And select **Microsoft Personal Account Only** in **Supported Account Types**.
Since we are not using URI callback based authentication. Therefore, you do not need to fill in the **Redirect URI** below the form.

::: warning
Please check the information in the form carefully, otherwise unexpected problems may occur in subsequent steps.
:::

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_3.png)

After clicking Create, wait for Azure AD to finish creating the app. Once created, the webpage will redirect you to the app's details page:

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_4.png)

Then click **Authentication** in the left column:

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/identity_verification.png)

Then find the **Advanced Settings** section on the right and make sure that **Advanced SDK Support** and **Allow Public Client Flow** in the section are turned on.
If they are not turned on, turn them on manually.

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/id_advanced_settings.png)

Then click the save button below and wait for the saving to complete.

## View Client ID

Congratulations! You have completed the application registration with Azure. Next, you only need to go to the **Overview** page to view the Client ID of the application.
Click the **Overview** button in the left column to view the basic information of the application:

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/about.png)

On the right you will see the details of your application, find the **Application (Client) ID** in **Summary**,
This ID will be the Client ID you need to use during the [Microsoft Authenticator Configuration](/enUS/projbobcat/installationAndConfig) phase.

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/about_block.png)

---

---
url: /zhCN/guide/standard/code-of-open-groups.md
---
# Corona Studio公开交流群管理规定和条款

违反本条款的行为将按情节予以“移出群聊”，“禁言”或”警告“处理，请全体成员遵守

原则：

1. 警告制度

   * 管理员除非遇到下文【严重行为】中描述的特别恶劣的情况可以立即适量执行之外，均采用“不再三”原则，即：【违反群规会被先警告，警告满第三次时由当时发出警告的管理员适量施加处罚，但事实违规情节严重者可不视警告次数直接执行】
   * 管理员须在警告时适当保留证据
   * 管理员自行决定是否警告并撤回信息

2. 处罚涵盖

   * 所有处罚手段允许数罪并罚

   * 口头警告。用于制止可能存在的违规

   * 警告。用于事实上的违规，但是违规群员的发言影响没必要被撤回。使用机器人计数

   * 正式警告。用于事实上的违规，并且需要消除影响。使用机器人计数

   * 禁言。需要在禁言前进行警告，使用机器人计数，并在警告后立刻禁言。实际禁言时长可以按影响程度、累计警告次数等因素而定，但是若群员违反的规则有定义最短时长，则必须长于该规定时长

   * 移出群聊。原则上，仅在积累第二次“三次警告”（即警告积累6次）才可能移出群聊。具体视实际违反的规定而定。

   * 移出群聊并全线拉黑。被如此处罚的人将无法加入任何日冕公开群聊。目前仅老腊肉和法棍有权执行

3. 反对条款

   * 管理员若发现有劣迹斑斑的人加入群聊，可以在群内列出该人的行为记录，然后由3名或以上的管理员讨论去留

***

一、严重行为（可被移出群聊）

1. 违法行为

   * 传播违法信息（政治敏感、暴力色情、诈骗赌博等）
   * 讨论可能违法的敏感技术
   * 传播病毒、钓鱼链接或血腥惊悚内容
   * 严重涉黄行为
   * 其他违反公序良俗行为

2. 骚扰行为和破坏秩序

   * 无故频繁@或戳戳他人或频繁给消息贴表情的

   * 发布无关广告/引流信息

   * 私下骚扰成员（经管理员观察确认或投诉核实）

   * 未经允许拉其他群成员进入私人团体或长期骚扰群友

   * 冒充他人发表言论

   * 故意引战、煽动对立、寻衅滋事

   * 顶撞、辱骂管理员或拒不配合处理，不知错不知改的

   * 抹黑工作室劳动成果的

***

二、应禁言处理的行为

1. 不当言论
   * 无礼争执持续超5分钟（禁言12小时）
   * 人身攻击/歧视/侮辱（禁言24小时）
   * 刷屏式倾倒负能量（禁言1小时）
     （我们理解您想要发泄您自己的情绪，但是请不要在公共的网络空间内随意倾泻）
2. 刷屏与滥用
   * 表情刷屏（5个及以上）：
     警告满后加禁言12小时及以上，情节极其严重者移出
   * 恶意发许多未经脑子思考的无意义内容：禁言1天
   * 管理员索取解决错误的线索但是超6小时未回复的（例外和详细条款见通用条款）：禁言一个月
3. 广告违规
   * 广告推广：警告满后撤回并禁言1-3天，情节特别严重者移出群聊
     （日冕工作室成员及日冕工作室合作方发布的除外）
   * 任何涉及其他不相关启动器或MC服务器的言论（除非由管理员或确认的日冕成员发起。对其他启动器的吹捧和诋毁均算在此类。）：禁言10分钟
     * 附录：相关启动器：Fluent Launcher，Minecraft Launcher(官方)，XMCL，
     * 一些广为人知的MC服务器不在此条限制范围内。比如：Hypixel

***

三、通用条款

1. 进入本群我们即默认视为您已看过且同意本群管理条款，修订后以群公告为准
2. 管理员有权依规灵活处置
3. 对处理有异议者，须私聊群主或者指定管理员申诉，禁止群内争执
4. 未列明但严重破坏群秩序的行为，管理员有权进行处置
5. 若您提出有问题，但在6小时内未提供解决错误的信息，我们将给予一次警告处分
   （若因为意外，比如返校、收手机等，则必须事先说明）
6. 在群里提出问题前请您先查询日冕知识库
7. 本文解释权归日冕工作室全体成员所有
8. 管理员无义务处理当前群所相关问题之外的问题。请您在询问问题时提供必要的日志和信息等线索，并且配合有意帮助的群成员或管理员的线索要求。
9. 一些简单的使用方法请您先前往CSKB查找，只有在无法访问/对应文档无效/无对应文档才能就功能相关的问题提问。

***

请共同维护友善，和谐，包容的社区环境。

## 简化版：适用于群规

简而言之，**违规按情节处罚：警告/禁言/移出群聊**。

***

### 一、核心原则

1. **三次警告原则**：违规先警告，满3次后处罚（情节严重者直接处罚）
2. **处罚类型**：警告（含口头/正式警告，机器人计数）、禁言（需先警告，时长≥规则下限）、移出群聊（警告累计6次或触犯红线）、全线拉黑
3. **管理员有权**：灵活处置、撤回消息、处理未列明但破坏秩序的行为

***

### 二、严重行为（可立即移出群聊）

1. **违法内容**：敏感政治、暴力色情、诈骗赌博、病毒/钓鱼链接、违反公序良俗
2. **严重破坏**：骚扰成员、广告引流、冒充他人、煽动对立、寻衅滋事
3. **抗拒管理**：辱骂管理员、拒不认错、抹黑工作室成果

***

### 三、禁言行为（附最低时长）

* **不当言论**：人身攻击（24h）、无礼争执（12h）、刷屏负能量（1h）
* **刷屏滥用**：表情刷屏（≥12h）、无意义刷屏（1天）、超6小时未回复线索（1个月）
* **违规广告**：非合作方推广（1-3天），提及无关启动器/服务器（10分钟）  （知名服务器和以下启动器：XMCL、Fluent Launcher 除外）

***

### 四、通用条款

1. 进群即视为同意本规，修订以公告为准
2. **申诉需私聊管理员**，禁止群内争执
3. **提问前**：先查日冕知识库（CSKB），提问需提供必要日志线索
4. 管理员仅处理当前群相关问题，无义务解答其他

***

**请共同维护友善、和谐、包容的社区环境！**（解释权归日冕工作室所有）

## 简化版 - 纯文字

```
简而言之，违规按情节处罚：警告/禁言/移出群聊

一、核心原则
1. 三次警告原则：违规先警告，满3次处罚（情节严重直接处罚）
2. 处罚类型：警告（含口头/正式警告，机器人计数）、禁言（需先警告，时长≥规则下限）、移出群聊（警告累计6次或触犯红线）、全线拉黑
3. 管理员有权：灵活处置、撤回消息、处理未列明但破坏秩序的行为

二、严重行为（可立即移出群聊）
1. 违法内容：敏感政治、暴力色情、诈骗赌博、病毒/钓鱼链接、违反公序良俗
2. 严重破坏：骚扰成员、广告引流、冒充他人、煽动对立、寻衅滋事
3. 抗拒管理：辱骂管理员、拒不认错、抹黑工作室成果

三、禁言行为（附最低时长）
- 不当言论：人身攻击（24h）、无礼争执（12h）、刷屏负能量（1h）
- 刷屏滥用：表情刷屏（≥12h）、无意义刷屏（1天）、超6小时未回复线索（1个月，特殊情况除外）
- 违规广告：非合作方推广（1-3天），提及无关启动器/服务器（10分钟）（知名服务器和以下启动器：XMCL、Fluent Launcher 除外）

四、通用条款
1. 进群即视为同意本规，修订以公告为准
2. 申诉需私聊管理员，禁止群内争执
3. 提问前：先查日冕知识库（CSKB），提问需提供必要日志线索。管理员仅有义务处理当前群相关问题。

详见CSKB《标准和规则》，解释权归日冕工作室所有
```

---

---
url: /enUS/projbobcat/resourceCompleter/createAndConfigCompleter.md
---
# Create and configure completers

\[\[toc]]

## Initialize the completer

The method of creating a resource completer is very simple. You only need to use the following code to complete the initialization of the completer:

```c#

var completer = new DefaultResourceCompleter
{
    MaxDegreeOfParallelism = [MAX_DEGREE_OF_PARALLELISM],
    ResourceInfoResolvers = new List<IResourceInfoResolver>
    {
        ... // Initialization of resource information resolvers
    },
    TotalRetry = [NUMBER_OF_TOTAL_RETRY],
    CheckFile = [CHECK_FILE_AFTER_DOWNLOADED],
    DownloadParts = [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE]
};

```

::: tip

For tutorials on the initialization of the resource information resolver, please refer to the chapter [Resource Information Resolver](/enUS/projbobcat/resourceCompleter/resourceInfoResolver/index)
:::

In the above code block, please replace these parameters according to your actual situation:

| Project | Data Type | Description |
|:------------------------------------------------:|:--------|:----------------------------:|
| \[MAX\_DEGREE\_OF\_PARALLELISM] | INT | Resource check parallelism (check the number of game resources at the same time) |
| \[CHECK\_FILE\_AFTER\_DOWNLOADED] | BOOLEAN | Check file integrity after file download is complete (if resource checksum exists) |
| \[TOTAL\_DOWNLOAD\_SEGMENTS\_FOR\_LARGE\_FILE] | INT | Number of fragments when downloading large files |

::: warning

**\[MAX\_DEGREE\_OF\_PARALLELISM]** and **\[TOTAL\_DOWNLOAD\_SEGMENTS\_FOR\_LARGE\_FILE]**
Please adjust the value according to the hardware performance as appropriate. Setting a value that is too large may cause a decrease in throughput.

:::

## Complete game resources

After initializing the resource completer, you only need to call the completion method to start checking and completing operations:

In an asynchronous context, use **CheckAndDownloadTaskAsync** to complete the installation:

```c#

var result = await completer.CheckAndDownloadTaskAsync(); // [!code focus]

if (result.TaskStatus == TaskResultStatus.Error && (result.Value?.IsLibDownloadFailed ?? false))
{
     // After completing the completion, the resource inspector will return the execution results.
     // You can check the property value in result to determine whether completion is complete
    
     // IsLibDownloadFailed will reflect whether the library files necessary for startup have been successfully completed.
     // Generally speaking, if the completion of the library file fails, it is likely to cause the game to fail to start.
}

```

In a sync context, use **CheckAndDownload** to complete the installation:

```c#

var result = completer.CheckAndDownload(); // [!code focus]

```

## Report progress

In some cases, the resource completer may take several minutes to complete checking and downloading the resource.
Therefore, you may need to report the completer's current progress to the user in real time.

### Report Resource Inspector progress

You can get real-time check progress by registering the event **GameResourceInfoResolveStatus**:

```c#

completer.GameResourceInfoResolveStatus += (_, args) => 
    { ReportProgress(args.Progress, args.Status); };

```

Among them, **args.Progress** indicates the current percentage progress of the checker. **args.Status** is a text description of the current progress of the checker.

### Report completion file download progress

You can get real-time check progress by registering the event **DownloadFileCompletedEvent**:

```c#

completer.DownloadFileCompletedEvent += (sender, args) =>
{
     // The sender parameter is the last successfully downloaded file of the completer, the type is DownloadFile
     // args returns the download status of the file (success/failure), and the retry count of the file,
     // Type is DownloadFileCompletedEventArgs
};

```

::: tip

* [DownloadFile Class Structure](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/DownloadFile.cs)
* [DownloadFileCompletedEventArgs Event Structure](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Event/DownloadFileCompletedEventArgs.cs)

:::

### Report progress information for files being downloaded

You can get real-time check progress by registering the event **DownloadFileChangedEvent**:

```c#

rC.DownloadFileChangedEvent += (_, args) =>
{
    // args returns the specific information of the file being downloaded (number of bytes received, total number of bytes, current speed, percentage progress)
     // Type is DownloadFileChangedEventArgs
};

```

::: tip

* [DownloadFileChangedEventArgs Event Structure](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Event/DownloadFileChangedEventArgs.cs)

:::

---

---
url: /enUS/projbobcat/installers/curseforge.md
---
# CurseForge integration package installer

\[\[toc]]

::: tip

Please note that ProjBobcat only implements the automated installation process of the CurseForge integration package. You still need to implement the search, download, and save process of the CurseForge integration package yourself.

:::

## Resources

* [CurseForge Website](https://www.curseforge.com/)
* [CurseForge API](https://docs.curseforge.com/)

## Initialize the installer

The way to initialize the CurseForge installer is very simple:

```c#

var curseForgeInstaller = new CurseForgeInstaller
{
    GameId = "[CUSTOM_INSTALL_GAME_ID]",
    ModPackPath = "[PATH_TO_YOUR_MODPACK]",
    RootPath = "[GAME_ROOT_PATH]"
};

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:-----------------------------------------:|:----------------------:|
| \[GAME\_ROOT\_PATH] | The game root directory, usually the path to the **.minecraft** folder |
| \[CUSTOM\_INSTALL\_GAME\_ID] | Optional, customize the name of the game to be installed |
| \[PATH\_TO\_YOUR\_MODPACK] | The path where the CurseForge integration package is located |

## Start installation

After you complete the initialization of the installer, you only need to call the installation method of the CurseForge installer to complete the installation.

In an asynchronous context, use **InstallTaskAsync** to complete the installation:

```c#

await curseForgeInstaller.InstallTaskAsync();

```

In a sync context, use **Install** to complete the installation:

```c#

curseForgeInstaller.Install();

```

## Report installation progress

In some cases, the CurseForge installer may take several minutes to complete the installation.
Therefore, you may need to report the current progress of the installer to the user in real time.
For this purpose, the CurseForge installer provides the **StageChangedEventDelegate** event to help you implement task reporting.
You simply need to register for the following event **before starting the installation**:

```c#

curseForgeInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

Among them, **args.Progress** indicates the current percentage progress of the installer. **args.CurrentStage** is a text description of the current progress of the installer.

---

---
url: /ruRU/projbobcat/installers/curseforge.md
---
# CurseForge 整合包安装器

\[\[toc]]

::: tip

请注意, ProjBobcat 仅实现了 CurseForge 整合包的自动化安装流程, 您仍然需要自己实现 CurseForge 整合包的搜索、下载、保存流程.

:::

## 实用资源

* [CurseForge 官方网站](https://www.curseforge.com/)
* [CurseForge API](https://docs.curseforge.com/)

## 初始化安装器

初始化 CurseForge 安装器的方式非常简单：

```c#

var curseForgeInstaller = new CurseForgeInstaller
{
    GameId = "[CUSTOM_INSTALL_GAME_ID]",
    ModPackPath = "[PATH_TO_YOUR_MODPACK]",
    RootPath = "[GAME_ROOT_PATH]"
};

```

在上述代码块中, 请将这些参数按照您的实际情况替换：

|                  项目                  |             说明              |
|:------------------------------------:|:---------------------------:|
|           \[GAME\_ROOT\_PATH]           | 游戏根目录, 通常为 .minecraft 文件夹的路径 |
|       \[CUSTOM\_INSTALL\_GAME\_ID]       |     可选项, 自定义即将要安装的游戏的名称      |
|        \[PATH\_TO\_YOUR\_MODPACK]        |     CurseForge 整合包所在的路径     |

## 开始安装

在您完成安装器的初始化后, 您只需要调用 CurseForge 安装器的安装方法来完成安装.

在异步上下文中, 使用 **InstallTaskAsync** 来完成安装：

```c#

await curseForgeInstaller.InstallTaskAsync();

```

在同步上下文中, 使用 **Install** 来完成安装：

```c#

curseForgeInstaller.Install();

```

## 报告安装进度

在某些情况下, CurseForge 安装器可能会需要数分钟的时间来完成安装.
因此, 您可能需要实时向用户汇报安装器目前的进度.
为此, CurseForge 安装器提供了 **StageChangedEventDelegate** 事件来帮助您实现任务汇报.
您只需要简单地在 **开始安装之前** 注册下面的事件：

```c#

curseForgeInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

其中,  **args.Progress** 指示了安装器当前的百分比进度. **args.CurrentStage** 则是安装器当前进度的文字描述.

---

---
url: /zhCN/projbobcat/installers/curseforge.md
---
# CurseForge 整合包安装器

\[\[toc]]

::: tip

请注意，ProjBobcat 仅实现了 CurseForge 整合包的自动化安装流程，您仍然需要自己实现 CurseForge 整合包的搜索、下载、保存流程。

:::

## 实用资源

* [CurseForge 官方网站](https://www.curseforge.com/)
* [CurseForge API](https://docs.curseforge.com/)

## 初始化安装器

初始化 CurseForge 安装器的方式非常简单：

```c#
var curseForgeInstaller = new CurseForgeInstaller
{
    GameId = "[CUSTOM_INSTALL_GAME_ID]",
    ModPackPath = "[PATH_TO_YOUR_MODPACK]",
    RootPath = "[GAME_ROOT_PATH]"
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|                  项目                  |             说明              |
|:------------------------------------:|:---------------------------:|
|           \[GAME\_ROOT\_PATH]           | 游戏根目录，通常为 .minecraft 文件夹的路径 |
|       \[CUSTOM\_INSTALL\_GAME\_ID]       |     可选项，自定义即将要安装的游戏的名称      |
|        \[PATH\_TO\_YOUR\_MODPACK]        |     CurseForge 整合包所在的路径     |

## 开始安装

在您完成安装器的初始化后，您只需要调用 CurseForge 安装器的安装方法来完成安装。

在异步上下文中，使用 **InstallTaskAsync** 来完成安装：

```c#
await curseForgeInstaller.InstallTaskAsync();
```

在同步上下文中，使用 **Install** 来完成安装：

```c#
curseForgeInstaller.Install();
```

## 报告安装进度

在某些情况下，CurseForge 安装器可能会需要数分钟的时间来完成安装。
因此，您可能需要实时向用户汇报安装器目前的进度。
为此，CurseForge 安装器提供了 **StageChangedEventDelegate** 事件来帮助您实现任务汇报。
您只需要简单地在 **开始安装之前** 注册下面的事件：

```c#
curseForgeInstaller.StageChangedEventDelegate += (_,  args) => {
    ReportProgress(args.Progress,  args.CurrentStage);
};
```

其中， **args.Progress** 指示了安装器当前的百分比进度。**args.CurrentStage** 则是安装器当前进度的文字描述。

---

---
url: /zhTW/projbobcat/installers/curseforge.md
---
# CurseForge 整合包安裝器

\[\[toc]]

::: tip

請注意, ProjBobcat 僅實現了 CurseForge 整合包的自動化安裝流程, 您仍然需要自己實現 CurseForge 整合包的搜尋、下載、儲存流程.

:::

## 實用資源

* [CurseForge 官方網站](https://www.curseforge.com/)
* [CurseForge API](https://docs.curseforge.com/)

## 初始化安裝器

初始化 CurseForge 安裝器的方式非常簡單：

```c#

var curseForgeInstaller = new CurseForgeInstaller
{
    GameId = "[CUSTOM_INSTALL_GAME_ID]",
    ModPackPath = "[PATH_TO_YOUR_MODPACK]",
    RootPath = "[GAME_ROOT_PATH]"
};

```

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|                  專案                  |             說明              |
|:------------------------------------:|:---------------------------:|
|           \[GAME\_ROOT\_PATH]           | 遊戲根目錄, 通常為 .minecraft 資料夾的路徑 |
|       \[CUSTOM\_INSTALL\_GAME\_ID]       |     可選項, 自定義即將要安裝的遊戲的名稱      |
|        \[PATH\_TO\_YOUR\_MODPACK]        |     CurseForge 整合包所在的路徑     |

## 開始安裝

在您完成安裝器的初始化後, 您只需要呼叫 CurseForge 安裝器的安裝方法來完成安裝.

在非同步上下文中, 使用 **InstallTaskAsync** 來完成安裝：

```c#

await curseForgeInstaller.InstallTaskAsync();

```

在同步上下文中, 使用 **Install** 來完成安裝：

```c#

curseForgeInstaller.Install();

```

## 報告安裝進度

在某些情況下, CurseForge 安裝器可能會需要數分鐘的時間來完成安裝.
因此, 您可能需要實時向用戶彙報安裝器目前的進度.
為此, CurseForge 安裝器提供了 **StageChangedEventDelegate** 事件來幫助您實現任務彙報.
您只需要簡單地在 **開始安裝之前** 註冊下面的事件：

```c#

curseForgeInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

其中,  **args.Progress** 指示了安裝器當前的百分比進度. **args.CurrentStage** 則是安裝器當前進度的文字描述.

---

---
url: /README.md
---
# docs [![Deploy](https://github.com/Corona-Studio/CSKB_Hosting/actions/workflows/deploy.yml/badge.svg)](https://github.com/Corona-Studio/CSKB_Hosting/actions/workflows/deploy.yml)

日冕知识库文档, 使用 Markdown 撰写.

## 简介

这里是日冕知识库官方仓库, 里面包含了有关于团队项目的详细介绍以及开发文档. 同时也包含部分 MineCraft 游戏内容的相关规范.
目前已经支持包括 简体中文、繁体中文、俄罗斯语等语言. 项目使用 MIT 协议开源, 欢迎广大热心网友帮助我们支持更多的语言！

## 帮助我们添加一个新语言支持？

1. 首先, 您需要点击右上方的 `Fork` 来取得可修改的仓库副本
2. 将项目克隆到本地, 使用您常用的 IDE 打开项目
3. [确定您即将翻译的语言的 i18n 缩写](https://segmentfault.com/a/1190000019287972). 假如您即将翻译的语言是 **繁体中文（台湾）**, 您在之后使用到的名称则是 **zhTW**, 呈现在页面中的语言名称必须对应的是“繁体中文（台湾）”（或“台湾繁体”）. “繁体中文（香港）”、简体中文（新加坡）与Español(Mexico)、Русский(Украина)同理.
   \*\*请注意, 您将要为一个或多个地区适配适合当地语言习惯的本地化文本. 您首先需要考虑的即是国际承认和地区习惯之间的平衡. 任何我们认为会造成不良影响的内容均会被移除, 且制造此内容者将会被移出贡献者列表. \*\*
4. 跳转到项目目录下的 `docs/.vitepress` 文件夹, 您将在这个目录下找到如下内容：

* navBar（用于存放顶部导航条的翻译内容）
* searchBar（用于存放搜索条的翻译内容）
* sideBar（用于存放侧边导航栏的翻译内容）
* `i18n 缩写`.ts（用于整合上述翻译内容）
* config.ts（配置文件总成）

5. 您需要分别在 `navBar`、`searchBar`、`sideBar` 下创建新的翻译配置文件, 代码定义参照各目录下的 `zhCN.ts`, **部分代码变量名可能包含 i18n 字段**, 请将其修改为您将要翻译的语言的 i18n 缩写！
6. 在完成上一步的文件创建和翻译工作后, 您需要在 `docs/.vitepress` 目录下创建 `i18n 缩写`.ts`, 代码定义参照与同目录下的 `zhCN.ts\` 保持一致, **代码变量名包含 i18n 字段**, 请将其修改为您将要翻译的语言的 i18n 缩写！
7. 在 `docs/.vitepress/sharedConfig.ts` 文件中找到如下内容：

**注意在顶部添加相应的 import**

```typescript

algolia: {
  appId: '-',
  apiKey: '-',
  indexName: 'kb-corona',
  locales: {
    root: zhSearchBarLocale,
    ruRU: ruSearchBarLocale,
    zhTW: zhTWSearchBarLocale,
    enUS: enUSSearchBarLocale,
    /* 在此处添加您的搜索条的翻译内容 */
  }
}

```

8. 在 `docs/.vitepress/config.ts` 中找到如下内容：

**注意在顶部添加相应的 import**

```typescript

locales: {
  root: { label: '简体中文', lang: 'zh-CN', ...zhConfig },
  ruRU: { label: 'Русский', lang: 'ru-RU', ...ruConfig },
  zhTW: { label: '繁體中文(台)', lang: 'zh-TW', ...zhTWConfig },
  enUS: { label: 'English(US)', lang: 'en-US', ...enUSConfig },
  /* 在此处添加您的翻译内容整合 */
},

```

9. 最后, 在 `docs` 目录下创建一个新的文件夹, 文件夹名称为您将要翻译的语言的 **i18n 缩写**, 并将同目录下 `zhCN` 文件夹中的内容 **复制** 到您刚刚创建的文件夹中.
   \*\*请注意：翻译文稿命名需要符合国际公认的标准. \*\*
10. 同时, 将 `docs` 目录下的 index.md 也复制到在上一步创建的文件夹中.
11. 将文件夹中的所有内容翻译为目标语言. 在完成后, 您即可向本仓库提交 PR！
12. 在我们审核完成后, 将会决定是否合并到主分支. 感谢您的参与！

请注意！我们强烈建议您在提交前对自己的撰文进行测试. 您需要先下载[我们配置好的环境](https://github.com/Corona-Studio/CSKB_Hosting), 然后将您的docs克隆到这个仓库本地副本的根目录（覆盖docs）, 并根据那里的`readme.md`安装好调试环境. 然后, 运行调试环境来进行测试.

## 贡献

感谢每一位翻译作者的无私奉献！

### 多语言贡献者

* [法棍面包](https://github.com/fr1g)
  * 俄罗斯语（ru-RU）
* [KormiMeiko](https://github.com/KormiMeiko)
  * 繁体中文（zh-TW）
* [Japerz](https://github.com/japerz12138)
  * 英语(美国) (en-US)

![Alt](https://repobeats.axiom.co/api/embed/243ea556dfcaf8738e432d5347cbcf91855f6ddd.svg "Repobeats analytics image")

---

---
url: /enUS/projbobcat/installers/fabric.md
---
# Fabric installer

\[\[toc]]

::: tip

Please note that ProjBobcat only implements the Fabric automated installation process. You still need to implement the search, download, and save process of the Fabric installation package yourself.

:::

## Resources

* [Fabric Website](https://fabricmc.net/)
* [Fabric Meta API](https://meta.fabricmc.net/)

## Get Fabric Loader Artifact

Because ProjBobcat's Fabric installer requires you to provide the official Loader Artifact information from Fabric when initializing the installer.
Therefore, we will briefly describe here how to obtain this information based on a given MineCraft version.

::: info

In this example, we'll be using Minecraft version 1.19.2 to show you how to get it.

:::

### Send request to Fabric Meta API

First, you need to send an **HTTP GET** request to [https://meta.fabricmc.net/v2/versions/loader/\[MC\_VERSION\]](https://meta.fabricmc.net/v2/versions/loader/1.19.2).
Replace `[MC_VERSION]` with the Minecraft version you want to install. Here we will use 1.19.2 for exmaple.

You will see something similar to the following returned:

```json

[
  {
    "loader": {
      "separator": ".",
      "build": 11,
      "maven": "net.fabricmc:fabric-loader:0.14.11",
      "version": "0.14.11",
      "stable": true
    },
    "intermediary": {
      "maven": "net.fabricmc:intermediary:1.19.2",
      "version": "1.19.2",
      "stable": true
    },
    "launcherMeta": {
      "version": 1,
      "libraries": {...},
      "mainClass": {...}
    }
  },
  {...},
  {...}
]

```

Fabric Meta API will return a JSON array, and each element in the array is the Loader Artifact we need.

#### Convert JSON return to ProjBobcat type

If you are using [JSON.NET](https://www.newtonsoft.com/json)(Newtonsoft.JSON) in your project.
You can use code similar to the following to convert the server response you get into the corresponding ProjBobcat type:

```c#

// Requesting data from the Fabric Meta API (example, not actual code)
...
var responseJson = await res.Content.ReadAsStringAsync();

// Convert JSON response to ProjBobcat type // [!code focus]
var artifacts = JsonConvert.DeserializeObject<List<FabricLoaderArtifactModel>>(responseJson); // [!code focus]

// Get the version the user wants to install (example, not actual code)
var userSelect = vm.SelectedArtifactIndex;

// Get a single Loader Artifact // [!code focus]
var selectedArtifact = artifacts[userSelect]; // [!code focus]

```

Here, **selectedArtifact** is what the Fabric installer requires `FabricLoaderArtifactModel`.

## Initialize the installer

The way to initialize the Fabric installer is very simple. You need to use the `selectedArtifact` obtained in the previous step to initialize the installer:

```c#

var fabricInstaller = new FabricInstaller
{
    LoaderArtifact = selectedArtifact,
    VersionLocator = [VERSION_LOCATOR_INST],
    RootPath = "[GAME_ROOT_PATH]",
    CustomId = "[CUSTOM_INSTALL_GAME_ID]",
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
};

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:----------------------------------:|:-------------------------------:|
| \[GAME\_ROOT\_PATH] | The game root directory, usually the path to the .minecraft folder |
| \[CUSTOM\_INSTALL\_GAME\_ID] | Optional, customize the name of the game to be installed |
| \[MC\_VERSION\_OR\_GAME\_ID] | The MineCraft original game version inherited by Forge, usually the game version. For example: 1.19.2 |
| \[VERSION\_LOCATOR\_INST] | Game version locator instance, that is, the **VersionLocator** attribute when initializing the game core |

## start installation

After you complete the initialization of the installer, you only need to call the installation method of the Fabric installer to complete the installation.

In an asynchronous context, use **InstallTaskAsync** to complete the installation:

```c#

await fabricInstaller.InstallTaskAsync();

```

In a sync context, use **Install** to complete the installation:

```c#

fabricInstaller.Install();

```

## Report installation progress

In some cases, the Fabric installer may take several minutes to complete the installation.
Therefore, you may need to report the current progress of the installer to the user in real time.
To this end, the Fabric installer provides the **StageChangedEventDelegate** event to help you implement task reporting.
You simply need to register for the following event **before starting the installation**:

```c#

fabricInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

Among them, **args.Progress** indicates the current percentage progress of the installer. **args.CurrentStage** is a text description of the current progress of the installer.

---

---
url: /ruRU/projbobcat/installers/fabric.md
---
# Fabric 安装器

\[\[toc]]

::: tip

请注意, ProjBobcat 仅实现了 Fabric 自动化安装流程, 您仍然需要自己实现 Fabric 安装包的搜索、下载、保存流程.

:::

## 实用资源

* [Fabric 官方网站](https://fabricmc.net/)
* [Fabric Meta API](https://meta.fabricmc.net/)

## 获取 Fabric Loader Artifact

由于 ProjBobcat 的 Fabric 安装器要求您在初始化安装器时提供来自 Fabric 官方的 Loader Artifact 信息.
因此, 我们将在这里简要描述如何根据指定的 MineCraft 版本来获取该信息.

::: info

在该示例中, 我们将使用 MineCraft 1.19.2 来向您展示如何获取.

:::

### 向 Fabric Meta API 发送请求

首先, 您需要向 [https://meta.fabricmc.net/v2/versions/loader/\[MC\_VERSION\]](https://meta.fabricmc.net/v2/versions/loader/1.19.2) 发送一个 **HTTP GET** 请求.
将 `[MC_VERSION]` 替换为您想要安装的 MineCraft 版本. 在这里, 我们将使用 1.19.2.

您将看到类似下面的返回内容：

```json

[
  {
    "loader": {
      "separator": ".",
      "build": 11,
      "maven": "net.fabricmc:fabric-loader:0.14.11",
      "version": "0.14.11",
      "stable": true
    },
    "intermediary": {
      "maven": "net.fabricmc:intermediary:1.19.2",
      "version": "1.19.2",
      "stable": true
    },
    "launcherMeta": {
      "version": 1,
      "libraries": {...},
      "mainClass": {...}
    }
  },
  {...},
  {...}
]

```

Fabric Meta API 将返回一个 JSON 数组, 数组中的每一个元素即是我们需要的 Loader Artifact.

#### 将 JSON 返回转换为 ProjBobcat 类型

如果您在您的项目中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）.
您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型：

```c#

// 从 Fabric Meta API 请求数据（示例, 非实际代码）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus]
var artifacts = JsonConvert.DeserializeObject<List<FabricLoaderArtifactModel>>(responseJson); // [!code focus]

// 获取用户想要安装的版本（示例, 非实际代码）
var userSelect = vm.SelectedArtifactIndex;

// 获取单个 Loader Artifact // [!code focus]
var selectedArtifact = artifacts[userSelect]; // [!code focus]

```

此处, **selectedArtifact** 即是 Fabric 安装器所需要的 `FabricLoaderArtifactModel`.

## 初始化安装器

初始化 Fabric 安装器的方式非常简单. 您需要使用到在先前步骤中取得的 `selectedArtifact` 来初始化安装器：

```c#

var fabricInstaller = new FabricInstaller
{
    LoaderArtifact = selectedArtifact,
    VersionLocator = [VERSION_LOCATOR_INST],
    RootPath = "[GAME_ROOT_PATH]",
    CustomId = "[CUSTOM_INSTALL_GAME_ID]",
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
};

```

在上述代码块中, 请将这些参数按照您的实际情况替换：

|                 项目                  |                      说明                       |
|:-----------------------------------:|:---------------------------------------------:|
|          \[GAME\_ROOT\_PATH]           |          游戏根目录, 通常为 .minecraft 文件夹的路径          |
|      \[CUSTOM\_INSTALL\_GAME\_ID]       |              可选项, 自定义即将要安装的游戏的名称               |
|       \[MC\_VERSION\_OR\_GAME\_ID]       | Forge 继承的 MineCraft 原版游戏版本, 通常为游戏版本. 例如：1.19.2  |
|       \[VERSION\_LOCATOR\_INST]        |  游戏版本定位器实例, 即初始化游戏核心时的 **VersionLocator** 属性   |

## 开始安装

在您完成安装器的初始化后, 您只需要调用 Fabric 安装器的安装方法来完成安装.

在异步上下文中, 使用 **InstallTaskAsync** 来完成安装：

```c#

await fabricInstaller.InstallTaskAsync();

```

在同步上下文中, 使用 **Install** 来完成安装：

```c#

fabricInstaller.Install();

```

## 报告安装进度

在某些情况下, Fabric 安装器可能会需要数分钟的时间来完成安装.
因此, 您可能需要实时向用户汇报安装器目前的进度.
为此, Fabric 安装器提供了 **StageChangedEventDelegate** 事件来帮助您实现任务汇报.
您只需要简单地在 **开始安装之前** 注册下面的事件：

```c#

fabricInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

其中,  **args.Progress** 指示了安装器当前的百分比进度. **args.CurrentStage** 则是安装器当前进度的文字描述.

---

---
url: /zhCN/projbobcat/installers/fabric.md
---
# Fabric 安装器

\[\[toc]]

::: tip

请注意，ProjBobcat 仅实现了 Fabric 自动化安装流程，您仍然需要自己实现 Fabric 安装包的搜索、下载、保存流程。

:::

## 实用资源

* [Fabric 官方网站](https://fabricmc.net/)
* [Fabric Meta API](https://meta.fabricmc.net/)

## 获取 Fabric Loader Artifact

由于 ProjBobcat 的 Fabric 安装器要求您在初始化安装器时提供来自 Fabric 官方的 Loader Artifact 信息。
因此，我们将在这里简要描述如何根据指定的 MineCraft 版本来获取该信息。

::: info

在该示例中，我们将使用 MineCraft 1.19.2 来向您展示如何获取。

:::

### 向 Fabric Meta API 发送请求

首先，您需要向 [https://meta.fabricmc.net/v2/versions/loader/\[MC\_VERSION\]](https://meta.fabricmc.net/v2/versions/loader/1.19.2) 发送一个 **HTTP GET** 请求。
将 `[MC_VERSION]` 替换为您想要安装的 MineCraft 版本。在这里，我们将使用 1.19.2。

您将看到类似下面的返回内容：

```json
[
  {
    "loader": {
      "separator": ".",
      "build": 11,
      "maven": "net.fabricmc:fabric-loader:0.14.11",
      "version": "0.14.11",
      "stable": true
    },
    "intermediary": {
      "maven": "net.fabricmc:intermediary:1.19.2",
      "version": "1.19.2",
      "stable": true
    },
    "launcherMeta": {
      "version": 1,
      "libraries": {...},
      "mainClass": {...}
    }
  },
  {...},
  {...}
]
```

Fabric Meta API 将返回一个 JSON 数组，数组中的每一个元素即是我们需要的 Loader Artifact。

#### 将 JSON 返回转换为 ProjBobcat 类型

如果您在您的项目中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）。
您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型：

```c#
// 从 Fabric Meta API 请求数据（示例，非实际代码）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus]
var artifacts = JsonConvert.DeserializeObject<List<FabricLoaderArtifactModel>>(responseJson); // [!code focus]

// 获取用户想要安装的版本（示例，非实际代码）
var userSelect = vm.SelectedArtifactIndex;

// 获取单个 Loader Artifact // [!code focus]
var selectedArtifact = artifacts[userSelect]; // [!code focus]
```

此处，**selectedArtifact** 即是 Fabric 安装器所需要的 `FabricLoaderArtifactModel`。

## 初始化安装器

初始化 Fabric 安装器的方式非常简单。您需要使用到在先前步骤中取得的 `selectedArtifact` 来初始化安装器：

```c#
var fabricInstaller = new FabricInstaller
{
    LoaderArtifact = selectedArtifact,
    VersionLocator = [VERSION_LOCATOR_INST],
    RootPath = "[GAME_ROOT_PATH]",
    CustomId = "[CUSTOM_INSTALL_GAME_ID]",
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|                 项目                  |                      说明                       |
|:-----------------------------------:|:---------------------------------------------:|
|          \[GAME\_ROOT\_PATH]           |          游戏根目录，通常为 .minecraft 文件夹的路径          |
|      \[CUSTOM\_INSTALL\_GAME\_ID]       |              可选项，自定义即将要安装的游戏的名称               |
|       \[MC\_VERSION\_OR\_GAME\_ID]       | Forge 继承的 MineCraft 原版游戏版本，通常为游戏版本。例如：1.19.2  |
|       \[VERSION\_LOCATOR\_INST]        |  游戏版本定位器实例，即初始化游戏核心时的 **VersionLocator** 属性   |

## 开始安装

在您完成安装器的初始化后，您只需要调用 Fabric 安装器的安装方法来完成安装。

在异步上下文中，使用 **InstallTaskAsync** 来完成安装：

```c#
await fabricInstaller.InstallTaskAsync();
```

在同步上下文中，使用 **Install** 来完成安装：

```c#
fabricInstaller.Install();
```

## 报告安装进度

在某些情况下，Fabric 安装器可能会需要数分钟的时间来完成安装。
因此，您可能需要实时向用户汇报安装器目前的进度。
为此，Fabric 安装器提供了 **StageChangedEventDelegate** 事件来帮助您实现任务汇报。
您只需要简单地在 **开始安装之前** 注册下面的事件：

```c#
fabricInstaller.StageChangedEventDelegate += (_,  args) => {
    ReportProgress(args.Progress,  args.CurrentStage);
};
```

其中， **args.Progress** 指示了安装器当前的百分比进度。**args.CurrentStage** 则是安装器当前进度的文字描述。

---

---
url: /zhTW/projbobcat/installers/fabric.md
---
# Fabric 安裝器

\[\[toc]]

::: tip

請注意, ProjBobcat 僅實現了 Fabric 自動化安裝流程, 您仍然需要自己實現 Fabric 安裝包的搜尋、下載、儲存流程.

:::

## 實用資源

* [Fabric 官方網站](https://fabricmc.net/)
* [Fabric Meta API](https://meta.fabricmc.net/)

## 獲取 Fabric Loader Artifact

由於 ProjBobcat 的 Fabric 安裝器要求您在初始化安裝器時提供來自 Fabric 官方的 Loader Artifact 資訊.
因此, 我們將在這裡簡要描述如何根據指定的 MineCraft 版本來獲取該資訊.

::: info

在該示例中, 我們將使用 MineCraft 1.19.2 來向您展示如何獲取.

:::

### 向 Fabric Meta API 傳送請求

首先, 您需要向 [https://meta.fabricmc.net/v2/versions/loader/\[MC\_VERSION\]](https://meta.fabricmc.net/v2/versions/loader/1.19.2) 傳送一個 **HTTP GET** 請求.
將 `[MC_VERSION]` 替換為您想要安裝的 MineCraft 版本. 在這裡, 我們將使用 1.19.2.

您將看到類似下面的返回內容：

```json

[
  {
    "loader": {
      "separator": ".",
      "build": 11,
      "maven": "net.fabricmc:fabric-loader:0.14.11",
      "version": "0.14.11",
      "stable": true
    },
    "intermediary": {
      "maven": "net.fabricmc:intermediary:1.19.2",
      "version": "1.19.2",
      "stable": true
    },
    "launcherMeta": {
      "version": 1,
      "libraries": {...},
      "mainClass": {...}
    }
  },
  {...},
  {...}
]

```

Fabric Meta API 將返回一個 JSON 陣列, 陣列中的每一個元素即是我們需要的 Loader Artifact.

#### 將 JSON 返回轉換為 ProjBobcat 型別

如果您在您的專案中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）.
您可以使用類似下面的程式碼來將您獲取到的伺服器響應轉換為對應的 ProjBobcat 型別：

```c#

// 從 Fabric Meta API 請求資料（示例, 非實際程式碼）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 將 JSON 響應轉換為 ProjBobcat 型別 // [!code focus]
var artifacts = JsonConvert.DeserializeObject<List<FabricLoaderArtifactModel>>(responseJson); // [!code focus]

// 獲取使用者想要安裝的版本（示例, 非實際程式碼）
var userSelect = vm.SelectedArtifactIndex;

// 獲取單個 Loader Artifact // [!code focus]
var selectedArtifact = artifacts[userSelect]; // [!code focus]

```

此處, **selectedArtifact** 即是 Fabric 安裝器所需要的 `FabricLoaderArtifactModel`.

## 初始化安裝器

初始化 Fabric 安裝器的方式非常簡單. 您需要使用到在先前步驟中取得的 `selectedArtifact` 來初始化安裝器：

```c#

var fabricInstaller = new FabricInstaller
{
    LoaderArtifact = selectedArtifact,
    VersionLocator = [VERSION_LOCATOR_INST],
    RootPath = "[GAME_ROOT_PATH]",
    CustomId = "[CUSTOM_INSTALL_GAME_ID]",
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
};

```

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|                 專案                  |                      說明                       |
|:-----------------------------------:|:---------------------------------------------:|
|          \[GAME\_ROOT\_PATH]           |          遊戲根目錄, 通常為 .minecraft 資料夾的路徑          |
|      \[CUSTOM\_INSTALL\_GAME\_ID]       |              可選項, 自定義即將要安裝的遊戲的名稱               |
|       \[MC\_VERSION\_OR\_GAME\_ID]       | Forge 繼承的 MineCraft 原版遊戲版本, 通常為遊戲版本. 例如：1.19.2  |
|       \[VERSION\_LOCATOR\_INST]        |  遊戲版本定位器例項, 即初始化遊戲核心時的 **VersionLocator** 屬性   |

## 開始安裝

在您完成安裝器的初始化後, 您只需要呼叫 Fabric 安裝器的安裝方法來完成安裝.

在非同步上下文中, 使用 **InstallTaskAsync** 來完成安裝：

```c#

await fabricInstaller.InstallTaskAsync();

```

在同步上下文中, 使用 **Install** 來完成安裝：

```c#

fabricInstaller.Install();

```

## 報告安裝進度

在某些情況下, Fabric 安裝器可能會需要數分鐘的時間來完成安裝.
因此, 您可能需要實時向用戶彙報安裝器目前的進度.
為此, Fabric 安裝器提供了 **StageChangedEventDelegate** 事件來幫助您實現任務彙報.
您只需要簡單地在 **開始安裝之前** 註冊下面的事件：

```c#

fabricInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

其中,  **args.Progress** 指示了安裝器當前的百分比進度. **args.CurrentStage** 則是安裝器當前進度的文字描述.

---

---
url: /enUS/projbobcat/installers/forge.md
---
# Forge installer

In ProjBobcat, we support automated Forge installations for almost all major MineCraft versions.

\[\[toc]]

::: tip

Please note that ProjBobcat only implements the Forge automated installation process. You still need to implement the search, download, and save process of the Forge installation package yourself.

:::

## Determine which Forge installer should be used

Because the Forge team has modified Forge's packaging specifications and installation process in subsequent versions. Therefore, you need to manually determine which installer to use.
In ProjBobcat, we have implemented the relevant judgment logic for you. You just need to simply call the following method:

```c#

var mcVersion = "[MC_VERSION]";
var forgeJarPath = "[PATH_TO_YOUR_FORGE_INSTALLER]";
var forgeVersion = ForgeInstallerFactory.GetForgeArtifactVersion(mcVersion, "[FORGE_VERSION]");

var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath, forgeVersion);  // [!code focus]

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:----------------------------------:|:-----------------------------------:|
| \[MC\_VERSION] | The Minecraft version to install Forge into, for example: 1.19.2 |
| \[PATH\_TO\_YOUR\_FORGE\_INSTALLER] | The path to the Forge installer .jar file |
| \[FORGE\_VERSION] | The specific version of Forge, usually XX.X.X, for example: 43.2.0 |

After you complete the replacement and successfully execute the above code snippet, **isLegacy** will indicate which Forge installer the current Forge installer should use.

## Initialize legacy installer

If in the above process, the value of **isLegacy** is **true**, it means that you need to use a legacy installer to complete the Forge installation.
To initialize the legacy installer, simply instantiate **LegacyForgeInstaller** and provide the appropriate parameters:

```c#

IForgeInstaller forgeInstaller =
    new LegacyForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                RootPath = "[GAME_ROOT_PATH]",
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                ForgeVersion = "[FORGE_VERSION]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            };

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:----------------------------------:|:-------------------------------:|
| \[GAME\_ROOT\_PATH] | The game root directory, usually the path to the **.minecraft** folder |
| \[CUSTOM\_INSTALL\_GAME\_ID] | Optional, customize the name of the game to be installed |
| \[MC\_VERSION\_OR\_GAME\_ID] | The MineCraft original game version inherited by Forge, usually the game version. For example: 1.19.2 |

## Initialize the new version of the installer

```c#

IForgeInstaller forgeInstaller =
    new HighVersionForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                JavaExecutablePath = "[PATH_TO_YOUR_JAVA_RUNTIME]",
                RootPath = "[GAME_ROOT_PATH]",
                VersionLocator = [VERSION_LOCATOR_INST],
                DownloadUrlRoot = “[LIBRARIES_URL_ROOT]”,
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                MineCraftVersion = "[MC_VERSION]",
                MineCraftVersionId = "[ACTUAL_MC_GAME_ID]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            };

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:----------------------------------:|:------------------------------------:|
| \[PATH\_TO\_YOUR\_JAVA\_RUNTIME] | The path where Java (javaw.exe) runtime is located |
| \[LIBRARIES\_URL\_ROOT] | The root URL of the download source, for example: "https://bmclapi2.bangbang93.com/" |
| \[VERSION\_LOCATOR\_INST] | Game version locator instance, that is, the **VersionLocator** attribute when initializing the game core |
| \[ACTUAL\_MC\_GAME\_ID] | The actual MineCraft game name, the name of the original game in the **version** folder. Normally, this value is consistent with **\[MC\_VERSION]**. |

## Uniform initialization based on **isLegacy** value

Because **LegacyForgeInstaller** and **HighVersionForgeInstaller** both implement the **IForgeInstaller** interface.
Therefore, you can easily use a ternary operator to selectively initialize the corresponding installer:

```c#{4-100}

var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath, forgeVersion);

IForgeInstaller forgeInstaller = isLegacy
            ? new LegacyForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                RootPath = "[GAME_ROOT_PATH]",
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                ForgeVersion = "[FORGE_VERSION]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            }
            : new HighVersionForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                JavaExecutablePath = "[PATH_TO_YOUR_JAVA_RUNTIME]",
                RootPath = "[GAME_ROOT_PATH]",
                VersionLocator = [VERSION_LOCATOR_INST],
                DownloadUrlRoot = “[LIBRARIES_URL_ROOT]”,
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                MineCraftVersion = "[MC_VERSION]",
                MineCraftVersionId = "[ACTUAL_MC_GAME_ID]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            };

```

## Start installation

After you complete the initialization of the installer, you only need to call the installation method of the Forge installer to complete the installation.

In an asynchronous context, use **InstallForgeTaskAsync** to complete the installation:

```c#

await forgeInstaller.InstallForgeTaskAsync();

```

In a sync context, use **InstallForge** to complete the installation:

```c#

forgeInstaller.InstallForge();

```

## Report installation progress

In some cases, the Forge installer may take several minutes to complete the installation.
Therefore, you may need to report the current progress of the installer to the user in real time.
For this purpose, the Forge installer provides the **StageChangedEventDelegate** event to help you implement task reporting.
You simply need to register for the following event **before starting the installation**:

```c#

((InstallerBase)forgeInstaller).StageChangedEventDelegate += (_, args) =>
{
    ReportProgress(args.Progress * 100, args.CurrentStage);
};

```

Among them, **args.Progress** indicates the current percentage progress of the installer. **args.CurrentStage** is a text description of the current progress of the installer.

---

---
url: /ruRU/projbobcat/installers/forge.md
---
# Forge 安装器

在 ProjBobcat 中, 我们支持了几乎所有主流 MineCraft 版本的 Forge 自动化安装.

\[\[toc]]

::: tip

请注意, ProjBobcat 仅实现了 Forge 自动化安装流程, 您仍然需要自己实现 Forge 安装包的搜索、下载、保存流程.

:::

## 判断应该使用哪一种 Forge 安装器

由于 Forge 团队在后续的版本中修改了 Forge 的打包规范以及安装流程. 因此, 您需要手动判断应该使用哪一种安装器.
在 ProjBobcat 中, 我们已经为您实现了相关的判断逻辑. 您只需要简单地调用下面的方法：

```c#

var mcVersion = "[MC_VERSION]";
var forgeJarPath = "[PATH_TO_YOUR_FORGE_INSTALLER]";
var forgeVersion = ForgeInstallerFactory.GetForgeArtifactVersion(mcVersion, "[FORGE_VERSION]");

var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath, forgeVersion);  // [!code focus]

```

在上述代码块中, 请将这些参数按照您的实际情况替换：

|               项目                |                     说明                     |
|:-------------------------------:|:------------------------------------------:|
|          \[MC\_VERSION]           |    将 Forge 安装到的 MineCraft 版本, 例如：1.19.2     |
| \[PATH\_TO\_YOUR\_FORGE\_INSTALLER]  |           Forge 安装器 .jar 文件所在的路径           |
|         \[FORGE\_VERSION]         |      Forge 的具体版本, 通常为 XX.X.X, 例如：43.2.0      |

在您完成替换并成功执行上述的代码片段之后, **isLegacy** 会指示当前 Forge 安装器应当使用哪一种 Forge 安装器.

## 初始化旧版安装器

如果在上面的流程中, **isLegacy** 的值为 **true**, 这意味着您需要使用旧版安装器来完成 Forge 的安装.
要初始化旧版安装器, 只需实例化 **LegacyForgeInstaller** 并提供相应的参数：

```c#

IForgeInstaller forgeInstaller =
    new LegacyForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                RootPath = "[GAME_ROOT_PATH]",
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                ForgeVersion = "[FORGE_VERSION]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            };

```

在上述代码块中, 请将这些参数按照您的实际情况替换：

|                 项目                 |                      说明                      |
|:----------------------------------:|:--------------------------------------------:|
|          \[GAME\_ROOT\_PATH]          |         游戏根目录, 通常为 .minecraft 文件夹的路径          |
|      \[CUSTOM\_INSTALL\_GAME\_ID]      |              可选项, 自定义即将要安装的游戏的名称              |
|      \[MC\_VERSION\_OR\_GAME\_ID]       | Forge 继承的 MineCraft 原版游戏版本, 通常为游戏版本. 例如：1.19.2 |

## 初始化新版安装器

```c#

IForgeInstaller forgeInstaller =
    new HighVersionForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                JavaExecutablePath = "[PATH_TO_YOUR_JAVA_RUNTIME]",
                RootPath = "[GAME_ROOT_PATH]",
                VersionLocator = [VERSION_LOCATOR_INST],
                DownloadUrlRoot = “[LIBRARIES_URL_ROOT]”,
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                MineCraftVersion = "[MC_VERSION]",
                MineCraftVersionId = "[ACTUAL_MC_GAME_ID]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            };

```

在上述代码块中, 请将这些参数按照您的实际情况替换：

|                 项目                  |                                      说明                                       |
|:-----------------------------------:|:-----------------------------------------------------------------------------:|
|     \[PATH\_TO\_YOUR\_JAVA\_RUNTIME]     |                           Java （javaw.exe） 运行时所在的路径                           |
|        \[LIBRARIES\_URL\_ROOT]         |                下载源的根 URL, 例如："https://bmclapi2.bangbang93.com/"                |
|       \[VERSION\_LOCATOR\_INST]        |                  游戏版本定位器实例, 即初始化游戏核心时的 **VersionLocator** 属性                   |
|         \[ACTUAL\_MC\_GAME\_ID]         | 实际的 MineCraft 游戏名称, 即原版游戏在 **version** 文件夹下的名称. 一般情况下, 这个值和 **\[MC\_VERSION]** 一致.  |

## 根据 **isLegacy** 值进行统一初始化

由于 **LegacyForgeInstaller** 和 **HighVersionForgeInstaller** 同时实现了 **IForgeInstaller** 接口.
因此, 您可以很方便的使用一个三元运算符来选择性的初始化对应的安装器：

```c#{4-100}

var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath, forgeVersion);

IForgeInstaller forgeInstaller = isLegacy
            ? new LegacyForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                RootPath = "[GAME_ROOT_PATH]",
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                ForgeVersion = "[FORGE_VERSION]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            }
            : new HighVersionForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                JavaExecutablePath = "[PATH_TO_YOUR_JAVA_RUNTIME]",
                RootPath = "[GAME_ROOT_PATH]",
                VersionLocator = [VERSION_LOCATOR_INST],
                DownloadUrlRoot = “[LIBRARIES_URL_ROOT]”,
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                MineCraftVersion = "[MC_VERSION]",
                MineCraftVersionId = "[ACTUAL_MC_GAME_ID]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            };

```

## 开始安装

在您完成安装器的初始化后, 您只需要调用 Forge 安装器的安装方法来完成安装.

在异步上下文中, 使用 **InstallForgeTaskAsync** 来完成安装：

```c#

await forgeInstaller.InstallForgeTaskAsync();

```

在同步上下文中, 使用 **InstallForge** 来完成安装：

```c#

forgeInstaller.InstallForge();

```

## 报告安装进度

在某些情况下, Forge 安装器可能会需要数分钟的时间来完成安装.
因此, 您可能需要实时向用户汇报安装器目前的进度.
为此, Forge 安装器提供了 **StageChangedEventDelegate** 事件来帮助您实现任务汇报.
您只需要简单地在 **开始安装之前** 注册下面的事件：

```c#

((InstallerBase)forgeInstaller).StageChangedEventDelegate += (_, args) =>
{
    ReportProgress(args.Progress * 100, args.CurrentStage);
};

```

其中,  **args.Progress** 指示了安装器当前的百分比进度. **args.CurrentStage** 则是安装器当前进度的文字描述.

---

---
url: /zhCN/projbobcat/installers/forge.md
---
# Forge 安装器

在 ProjBobcat 中，我们支持了几乎所有主流 MineCraft 版本的 Forge 自动化安装。

\[\[toc]]

::: tip

请注意，ProjBobcat 仅实现了 Forge 自动化安装流程，您仍然需要自己实现 Forge 安装包的搜索、下载、保存流程。

:::

## 判断应该使用哪一种 Forge 安装器

由于 Forge 团队在后续的版本中修改了 Forge 的打包规范以及安装流程。因此，您需要手动判断应该使用哪一种安装器。
在 ProjBobcat 中，我们已经为您实现了相关的判断逻辑。您只需要简单地调用下面的方法：

```c#
var mcVersion = "[MC_VERSION]";
var forgeJarPath = "[PATH_TO_YOUR_FORGE_INSTALLER]";
var forgeVersion = ForgeInstallerFactory.GetForgeArtifactVersion(mcVersion，"[FORGE_VERSION]");

var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath，forgeVersion);  // [!code focus]
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|               项目                |                     说明                     |
|:-------------------------------:|:------------------------------------------:|
|          \[MC\_VERSION]           |    将 Forge 安装到的 MineCraft 版本，例如：1.19.2     |
| \[PATH\_TO\_YOUR\_FORGE\_INSTALLER]  |           Forge 安装器 .jar 文件所在的路径           |
|         \[FORGE\_VERSION]         |      Forge 的具体版本，通常为 XX.X.X，例如：43.2.0      |

在您完成替换并成功执行上述的代码片段之后，**isLegacy** 会指示当前 Forge 安装器应当使用哪一种 Forge 安装器。

## 初始化旧版安装器

如果在上面的流程中，**isLegacy** 的值为 **true**，这意味着您需要使用旧版安装器来完成 Forge 的安装。
要初始化旧版安装器，只需实例化 **LegacyForgeInstaller** 并提供相应的参数：

```c#
IForgeInstaller forgeInstaller =
    new LegacyForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                RootPath = "[GAME_ROOT_PATH]",
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                ForgeVersion = "[FORGE_VERSION]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            };
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|                 项目                 |                      说明                      |
|:----------------------------------:|:--------------------------------------------:|
|          \[GAME\_ROOT\_PATH]          |         游戏根目录，通常为 .minecraft 文件夹的路径          |
|      \[CUSTOM\_INSTALL\_GAME\_ID]      |              可选项，自定义即将要安装的游戏的名称              |
|      \[MC\_VERSION\_OR\_GAME\_ID]       | Forge 继承的 MineCraft 原版游戏版本，通常为游戏版本。例如：1.19.2 |

## 初始化新版安装器

```c#
IForgeInstaller forgeInstaller =
    new HighVersionForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                JavaExecutablePath = "[PATH_TO_YOUR_JAVA_RUNTIME]",
                RootPath = "[GAME_ROOT_PATH]",
                VersionLocator = [VERSION_LOCATOR_INST],
                DownloadUrlRoot = "[LIBRARIES_URL_ROOT]",
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                MineCraftVersion = "[MC_VERSION]",
                MineCraftVersionId = "[ACTUAL_MC_GAME_ID]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            };
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|                 项目                  |                                      说明                                       |
|:-----------------------------------:|:-----------------------------------------------------------------------------:|
|     \[PATH\_TO\_YOUR\_JAVA\_RUNTIME]     |                           Java （javaw.exe） 运行时所在的路径                           |
|        \[LIBRARIES\_URL\_ROOT]         |                下载源的根 URL，例如："https://bmclapi2.bangbang93.com/"                |
|       \[VERSION\_LOCATOR\_INST]        |                  游戏版本定位器实例，即初始化游戏核心时的 **VersionLocator** 属性                   |
|         \[ACTUAL\_MC\_GAME\_ID]         | 实际的 MineCraft 游戏名称，即原版游戏在 **version** 文件夹下的名称。一般情况下，这个值和 **\[MC\_VERSION]** 一致。 |

## 根据 **isLegacy** 值进行统一初始化

由于 **LegacyForgeInstaller** 和 **HighVersionForgeInstaller** 同时实现了 **IForgeInstaller** 接口。
因此，您可以很方便的使用一个三元运算符来选择性的初始化对应的安装器：

```c#{4-100}
var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath，forgeVersion);

IForgeInstaller forgeInstaller = isLegacy
            ? new LegacyForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                RootPath = "[GAME_ROOT_PATH]",
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                ForgeVersion = "[FORGE_VERSION]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            }
            : new HighVersionForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                JavaExecutablePath = "[PATH_TO_YOUR_JAVA_RUNTIME]",
                RootPath = "[GAME_ROOT_PATH]",
                VersionLocator = [VERSION_LOCATOR_INST],
                DownloadUrlRoot = "[LIBRARIES_URL_ROOT]",
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                MineCraftVersion = "[MC_VERSION]",
                MineCraftVersionId = "[ACTUAL_MC_GAME_ID]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            };
```

## 开始安装

在您完成安装器的初始化后，您只需要调用 Forge 安装器的安装方法来完成安装。

在异步上下文中，使用 **InstallForgeTaskAsync** 来完成安装：

```c#
await forgeInstaller.InstallForgeTaskAsync();
```

在同步上下文中，使用 **InstallForge** 来完成安装：

```c#
forgeInstaller.InstallForge();
```

## 报告安装进度

在某些情况下，Forge 安装器可能会需要数分钟的时间来完成安装。
因此，您可能需要实时向用户汇报安装器目前的进度。
为此，Forge 安装器提供了 **StageChangedEventDelegate** 事件来帮助您实现任务汇报。
您只需要简单地在 **开始安装之前** 注册下面的事件：

```c#
((InstallerBase)forgeInstaller).StageChangedEventDelegate += (_,  args) =>
{
    ReportProgress(args.Progress * 100,  args.CurrentStage);
};
```

其中， **args.Progress** 指示了安装器当前的百分比进度。**args.CurrentStage** 则是安装器当前进度的文字描述。

---

---
url: /zhTW/projbobcat/installers/forge.md
---
# Forge 安裝器

在 ProjBobcat 中, 我們支援了幾乎所有主流 MineCraft 版本的 Forge 自動化安裝.

\[\[toc]]

::: tip

請注意, ProjBobcat 僅實現了 Forge 自動化安裝流程, 您仍然需要自己實現 Forge 安裝包的搜尋、下載、儲存流程.

:::

## 判斷應該使用哪一種 Forge 安裝器

由於 Forge 團隊在後續的版本中修改了 Forge 的打包規範以及安裝流程. 因此, 您需要手動判斷應該使用哪一種安裝器.
在 ProjBobcat 中, 我們已經為您實現了相關的判斷邏輯. 您只需要簡單地呼叫下面的方法：

```c#

var mcVersion = "[MC_VERSION]";
var forgeJarPath = "[PATH_TO_YOUR_FORGE_INSTALLER]";
var forgeVersion = ForgeInstallerFactory.GetForgeArtifactVersion(mcVersion, "[FORGE_VERSION]");

var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath, forgeVersion);  // [!code focus]

```

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|               專案                |                     說明                     |
|:-------------------------------:|:------------------------------------------:|
|          \[MC\_VERSION]           |    將 Forge 安裝到的 MineCraft 版本, 例如：1.19.2     |
| \[PATH\_TO\_YOUR\_FORGE\_INSTALLER]  |           Forge 安裝器 .jar 檔案所在的路徑           |
|         \[FORGE\_VERSION]         |      Forge 的具體版本, 通常為 XX.X.X, 例如：43.2.0      |

在您完成替換併成功執行上述的程式碼片段之後, **isLegacy** 會指示當前 Forge 安裝器應當使用哪一種 Forge 安裝器.

## 初始化舊版安裝器

如果在上面的流程中, **isLegacy** 的值為 **true**, 這意味著您需要使用舊版安裝器來完成 Forge 的安裝.
要初始化舊版安裝器, 只需例項化 **LegacyForgeInstaller** 並提供相應的引數：

```c#

IForgeInstaller forgeInstaller =
    new LegacyForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                RootPath = "[GAME_ROOT_PATH]",
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                ForgeVersion = "[FORGE_VERSION]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            };

```

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|                 專案                 |                      說明                      |
|:----------------------------------:|:--------------------------------------------:|
|          \[GAME\_ROOT\_PATH]          |         遊戲根目錄, 通常為 .minecraft 資料夾的路徑          |
|      \[CUSTOM\_INSTALL\_GAME\_ID]      |              可選項, 自定義即將要安裝的遊戲的名稱              |
|      \[MC\_VERSION\_OR\_GAME\_ID]       | Forge 繼承的 MineCraft 原版遊戲版本, 通常為遊戲版本. 例如：1.19.2 |

## 初始化新版安裝器

```c#

IForgeInstaller forgeInstaller =
    new HighVersionForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                JavaExecutablePath = "[PATH_TO_YOUR_JAVA_RUNTIME]",
                RootPath = "[GAME_ROOT_PATH]",
                VersionLocator = [VERSION_LOCATOR_INST],
                DownloadUrlRoot = “[LIBRARIES_URL_ROOT]”,
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                MineCraftVersion = "[MC_VERSION]",
                MineCraftVersionId = "[ACTUAL_MC_GAME_ID]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            };

```

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|                 專案                  |                                      說明                                       |
|:-----------------------------------:|:-----------------------------------------------------------------------------:|
|     \[PATH\_TO\_YOUR\_JAVA\_RUNTIME]     |                           Java （javaw.exe） 執行時所在的路徑                           |
|        \[LIBRARIES\_URL\_ROOT]         |                下載源的根 URL, 例如："https://bmclapi2.bangbang93.com/"                |
|       \[VERSION\_LOCATOR\_INST]        |                  遊戲版本定位器例項, 即初始化遊戲核心時的 **VersionLocator** 屬性                   |
|         \[ACTUAL\_MC\_GAME\_ID]         | 實際的 MineCraft 遊戲名稱, 即原版遊戲在 **version** 資料夾下的名稱. 一般情況下, 這個值和 **\[MC\_VERSION]** 一致.  |

## 根據 **isLegacy** 值進行統一初始化

由於 **LegacyForgeInstaller** 和 **HighVersionForgeInstaller** 同時實現了 **IForgeInstaller** 介面.
因此, 您可以很方便的使用一個三元運算子來選擇性的初始化對應的安裝器：

```c#{4-100}

var isLegacy = ForgeInstallerFactory.IsLegacyForgeInstaller(forgeJarPath, forgeVersion);

IForgeInstaller forgeInstaller = isLegacy
            ? new LegacyForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                RootPath = "[GAME_ROOT_PATH]",
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                ForgeVersion = "[FORGE_VERSION]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            }
            : new HighVersionForgeInstaller
            {
                ForgeExecutablePath = "[PATH_TO_YOUR_FORGE_INSTALLER]",
                JavaExecutablePath = "[PATH_TO_YOUR_JAVA_RUNTIME]",
                RootPath = "[GAME_ROOT_PATH]",
                VersionLocator = [VERSION_LOCATOR_INST],
                DownloadUrlRoot = “[LIBRARIES_URL_ROOT]”,
                CustomId = "[CUSTOM_INSTALL_GAME_ID]",
                MineCraftVersion = "[MC_VERSION]",
                MineCraftVersionId = "[ACTUAL_MC_GAME_ID]",
                InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
            };

```

## 開始安裝

在您完成安裝器的初始化後, 您只需要呼叫 Forge 安裝器的安裝方法來完成安裝.

在非同步上下文中, 使用 **InstallForgeTaskAsync** 來完成安裝：

```c#

await forgeInstaller.InstallForgeTaskAsync();

```

在同步上下文中, 使用 **InstallForge** 來完成安裝：

```c#

forgeInstaller.InstallForge();

```

## 報告安裝進度

在某些情況下, Forge 安裝器可能會需要數分鐘的時間來完成安裝.
因此, 您可能需要實時向用戶彙報安裝器目前的進度.
為此, Forge 安裝器提供了 **StageChangedEventDelegate** 事件來幫助您實現任務彙報.
您只需要簡單地在 **開始安裝之前** 註冊下面的事件：

```c#

((InstallerBase)forgeInstaller).StageChangedEventDelegate += (_, args) =>
{
    ReportProgress(args.Progress * 100, args.CurrentStage);
};

```

其中,  **args.Progress** 指示了安裝器當前的百分比進度. **args.CurrentStage** 則是安裝器當前進度的文字描述.

---

---
url: /enUS/projbobcat/additionalParsers/accountProfileParser.md
---
# Game account parser

The game profile parser is responsible for outputing the user account into the official launcher configuration file.

## Initialize the parser

The way to initialize the parser is very simple:

```c#

var launcherAccountParser
    = new DefaultLauncherAccountParser(rootPath, clientToken)

```

Among them, **rootPath** is the root directory where the core is located (that is, the directory where the .minecraft folder is located).
**clientToken** is a randomly generated GUID.

---

---
url: /enUS/projbobcat/additionalParsers/gameProfileParser.md
---
# Game file parser

The game archive parser is responsible for outputing the searched local games into the configuration file of the official launcher.

## Initialize the parser

The way to initialize the parser is very simple:

```c#

var launcherProfileParser
    = new DefaultLauncherProfileParser(rootPath, clientToken)

```

Among them, **rootPath** is the root directory where the core is located (that is, the directory where the .minecraft folder is located).
**clientToken** is a randomly generated GUID.

---

---
url: /enUS/dashboard.md
---
# Here you can see some help about dashboard components

---

---
url: /enUS/dashboard/search.md
---
# How to use dashboard search

You can enter anything you want to find in the aggregate search box. After you entered something, smart prompts will pop up below to help you quickly navigate to the search results page.

## Use the specified search engine to find content

By default, LauncherX uses Bing to find your search.
If you want to specify the search engine used for aggregated searches, you can add the following prefix before your search content:

| Search Engine |  Key  |
|:----:|:---:|
|  Google  | g:  |
|  Bing  | b:  |
|  Baidu  | bd: |

### Examples

* Use Google to search "1.16.5 Texture Pack"：g:1.16.5 Texture Pack
* Use Bing to search "1.16.5 Texture Pack"：b:1.16.5 Texture Pack
* Use Baidu to search "1.16.5 Texture Pack"：bd:1.16.5 Texture Pack

---

---
url: /enUS/projbobcat/installationAndConfig.md
---
# Install and configure ProjBobcat

\[\[toc]]

## Install from distribution package

### Nuget

Currently, you can easily search and download the ProjBobcat package from Nuget. You can search for ProjBobcat in the package manager of Visual Studio and add it to your project.

```bash
NuGet\Install-Package ProjBobcat -Version 1.16.0
```

### .NET CLI

To install ProjBobcat via the .NET CLI, you just need to switch the terminal to the project directory containing the .csproj file and execute in the terminal：

```bash
dotnet add package ProjBobcat --version 1.16.0
```

### PackageReference

PackageReference is a new software package management specification launched by Microsoft for modern .NET projects.
Details can be found at [MSDN](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files)
View in

All you need to do is add in your project's **\[project name].csproj** file:

```xml
<PackageReference Include="ProjBobcat" Version="1.16.0" />
```

::: tip
Among them, **1.16.0** is the version number of ProjBobcat. You can replace it with other version numbers.
All released versions can be viewed at [ProjBobcat - Nuget](https://www.nuget.org/packages/ProjBobcat#versions-body-tab).
:::

## Get from source code

Another way to use ProjBobcat is to add the code repository directly to your project reference.

::: info
Before executing the following command, you may need to install [Git CLI](https://git-scm.com/)
:::

### Clone the ProjBobcat repository

Use the command line to switch to the root directory of the project solution and execute the following code in the command line to complete the cloning of the warehouse:

```bash
git clone https://github.com/Corona-Studio/ProjBobcat.git
```

### Use Git Submodule to pull ProjBobcat

::: tip
Git Submodule is a very practical feature, and here we only show its most basic use cases.
You can see more use cases in [Git Documentation](https://git-scm.com/book/en/v2/Git-Tools-Submodules).
:::

Use the command line to switch to the root directory of the project solution and execute the following code in the command line to complete the cloning of the warehouse:

```bash
git submodule add https://github.com/Corona-Studio/ProjBobcat.git
```

### Add a reference to ProjBobcat

Next, in Visual Studio's Solution Explorer view, right-click the solution name at the top of the tree.
And select **Add-"Existing Project"** and find **ProjBobcat.csproj** in the folder of the ProjBobcat project you just cloned in the file browser window.

Next, find the project you need to reference ProjBobcat in **Solution Explorer**, right-click, and select **"Add"-"Project Reference"**.
Finally, check ProjBobcat in the pop-up window to complete the reference.

\##Configure before use

### Modify the default number of connections

Before using ProjBobcat, you need to set the entry point of your program (usually **App.xaml.cs** or **Program.cs**)
Add some code to initialize ProjBobcat related services.

Due to the default maximum connection limit of the .NET runtime, you may encounter a performance bottleneck when using ProjBobcat to download modules.
Therefore, you need to add the following code at the entrance to modify the default maximum number of connections:

```c#{3}
 using System.Net;

 ServicePointManager.DefaultConnectionLimit = 512;
```

### Register and initialize basic services

Next, you need to add this code to the entry point to complete the initialization of the ProjBobcat service:

#### Initialize service container

```c#
ServiceHelper.Init();
```

#### Initialize CurseForge API service (optional)

This service is optional, if you are not using any CurseForge related services, you can ignore this step.

::: tip
Before registering for the CurseForge service, you need to prepare the API KEY officially issued by CurseForge.
If you haven't already, please go to the [Application Page - CurseForge](https://support.curseforge.com/en/support/solutions/articles/9000208346-about-the-curseforge-api-and-how-to-apply-for-a-key)
to get your API KEY.
:::

::: warning
API KEY is a sensitive personal credential. Please keep the API KEY properly and do not disclose it to others.
:::

```c#
CurseForgeAPIHelper.SetApiKey("[YOUR API KEY]");
```

Replace **\[YOUR API KEY]** with the API KEY you officially obtained from CurseForge.

#### Initialize download service

When initializing the download service, you can choose to customize the User Agent used when making requests (the default is "ProjBobcat").

```c#
HttpClientHelper.Ua = "[YOUR UA]"; // OPTIONAL
HttpClientHelper.Init();
```

### Configure Microsoft Login Authenticator

For specific registration methods for Azure Active Directory applications, please go to:
[Create New Azure Application](/enUS/projbobcat/createNewAzureApp)

::: tip
Before configuring Microsoft Authenticator, you need to register your app with Azure and configure it correctly.
After you complete the configuration, you will get a Client ID.

Relevant information:

* [Azure Website](https://azure.microsoft.com/en-us/)
* [Device code flow](https://learn.microsoft.com/en-us/azure/active-directory/develop/scenario-desktop-acquire-token-device-code-flow?tabs=dotnet)

:::

::: warning
The CLIENT ID is a sensitive personal credential, please keep the CLIENT ID properly and do not disclose it to others.
:::

```c#
MicrosoftAuthenticator.Configure(new MicrosoftAuthenticatorAPISettings
{
    ClientId = "[YOUR CLIENT ID]",
    TenentId = "consumers",
    Scopes = new[] { "XboxLive.signin", "offline_access", "openid", "profile", "email" }
});
```

After obtaining the Client ID, replace **\[YOUR CLIENT ID]** with your Client ID.

---

---
url: /zhCN/mc-starter/advanced/analyze-exception/1_environment.md
---
# Java Edition | 如何分析游戏崩溃问题 - 1: 游戏前检查

:::warning 转载文章

本文是转载文章，经过CSKB编辑细微修改后发布于此。如果你觉得这篇文章不错并想要引用或转载，请根据这些信息联系原作者。

原作者：Kamihakuyie

引用链接：[腾讯频道 - Kamihakuyie 的帖子](https://qun.qq.com/qqweb/qunpro/share?_wv=3&_wwv=128\&appChannel=share\&inviteCode=2muCpb408BT\&contentID=dwOtCX\&businessType=2\&jumpsource=shorturl)

转载信息上次更新于 2025年1月14日

:::

\[\[toc]]

## **//Preface  -  前话**

Minecraft Java Edition作为一个较大的Java依赖性软件，在进行游戏时，玩家们时常会碰到启动游戏时闪退、卡死等问题，而问题的形式种类繁多，有些问题解决起来极不容易。

对此，我根据自身理论知识以及部分解决游戏崩溃问题的实践经验逐步教会大家通过游戏前的检查以及对游戏崩溃日志的分析解决启动游戏时的问题，尽我所能帮助你成功启动游戏。

此外，由于本人专业知识有所不足，只提供力所能及的帮助以及建议方案，若碰到无法解决的问题烦请谅解！

## **//Body  Part1  -  正文1：Java环境问题检查**

### **① 版本对应**

我们已经知道Minecraft Java Edition依赖JAVA运行，而不同minecraft版本所选用的JAVA版本也有所不同，那么我们最开始要做的，便是检查系统中Java环境与minecraft版本是否对应，以下是各版本对应的JAVA版本(1)：

* 从**1.12（17w13a）** 开始，运行Minecraft的最低要求是**Java 8**

* 从**1.17（21w19a）** 开始，运行Minecraft的最低要求是Java 16

* 从**1.18（1.18-pre2） **开始，运行Minecraft的最低要求是**Java 17**

* 从**1.20.5（24w14a）** 开始，运行Minecraft的最低要求是**Java 21**，且操作系统要求为**64位**

:::tip 搬运补充

如果你不知道你的操作系统和位数，参见：[辨识计算机环境 | 日冕知识库](/zhCN/guide/general/check-system.html)

:::

### **② 检查版本**

那么我们如何检查**电脑**中的JAVA版本呢？一般采用以下方法：

1、Win+R键，输入cmd后回车

2、输入java --version （此处注意JAVA8以下的老版本用java -version否则报错）

3、出现以下界面即成功

可以看见我的Java为 JRE 1.8.0 Update341

![由于跨域阻止，此处换用了并非来自原文的图片](/img/mcstarter/java-version.png)

*对于Java8，作为长期支持的版本，其一直在更新。每个小更新都通过“1.8.0 Update xxx”来区分。在极端情况下，由于存在差异，不同小更新版本的Java8都可能引发不同的问题。*

在pojav与FCL等手机Java启动器中，请借助启动器自行查询Java版本

:::tip 搬运补充

对于现代的启动器，当您电脑中存在对应版本的JRE文件，一般都能做到自动切换。对于LauncherX，我们的自动切换是在发现版本对应有问题时候询问您是继续强制启动或是使用LauncherX判断出最合适的版本。

与此同时，要想查看LauncherX当前选中的Java版本，只需打开【设置-Java虚拟机设定】即可查看。关于这段设置，参见：[全局游戏设置 | 日冕知识库](/zhCN/lxguide/settings/item/global)

:::

### **③ JDK？JRE？**

关于Java，一般我们会碰到**JDK**与**JRE**两种

jdk是开发工具，jre则是运行环境，而开发工具自然包含了运行环境

所以实际上两者都能运行Minecraft，最大的差别在于jdk要稍微大些，**但是**

在**JAVA 17 及以上版本**中jre兼容性较差，建议使用jdk

此外，Java还存在不同公司的牌子，如Oracle、Bellsoft、Zulu等，但是实际上都差不多

（至少我现在没有分析因为Java牌子问题报错的）

### **④ 还是崩溃了！**

上述为游戏前检查Java环境，而如果Java环境存在问题导致崩溃，在崩溃日志中（游戏所在文件夹的logs里，或使用LauncherX右键点击游戏然后选择【打开-日志】，选择latest.log）你或许会发现以下内容：

```
The requested compatibility level **JAVA_21 could not be set**。Level is not supported by the active JRE or ASM version (**Java 17.0**，ASM 9.6 (ASM10_EXPERIMENTAL))
```

【 这是直接告诉你该用Java21而你用的是Java17 】

```
Error loading class: XXXXX (java.lang.IllegalArgumentException: **Class file major version 65** is not supported by active ASM (version 9.0 **supports class version 61**)，reading XXXXX)
```

【 这是由于ASM无法读取高版本Java导致的问题，需要切换到低版本Java 】

对于第二个问题，我们可以看到它提示了**Class编译版本号**，对于MC来说常见的与jdk版本对应如下(2)：

* Java 8 对应的class文件版本号是52

* Java 16 对应的class文件版本号是60

* Java 17 对应的class文件版本号是61

* Java 21 对应的class文件版本号是65

### **⑤ 借助启动器**

LauncherX等现代的（反正，就是这几年内更新过的（包括Minecraft官方推出的启动器 —— 这是一定会帮你准备好Java的））Minecraft启动器会提示并帮助你自动下载Java（关于如何使用LauncherX内置的Java下载功能，参见：[使用LauncherX下载JRE(仅限Windows)](/zhCN/lxguide/others/download-jre.html#使用launcherx内置的下载-windows-x64)），但当自动下载失效时请手动下载Java，参见：[如何手动下载Java环境](/zhCN/lxguide/others/download-jre)

## **//Body Part2  -  正文2：mods及其前置检查**

::: warning 这节内容经过编辑修改

要想阅读原文，参见[页首](#)的**引用信息**。

:::

**一般来说**，只有启用相应前置才能启动对应mods

（不一般的情况：用sodium以及iris兼容optifine+OptiFabric光影 等）(5)

此外，在进行游戏前检索你所安装mods的冲突关系并且避免之也是一种解决启动问题的重要方式。在LauncherX中下载到游戏的Mod会自动下载依赖，并且你可以在游戏Mod管理和Mod下载界面看到Mod的依赖关系。

## **//Epilogue  -  本篇结语**

现在你已经对游戏前必要环境的检查了然于心了，你可以试着启动游戏，如果游戏与模组正常启动，那么恭喜你学会了基本教程。如果游戏依旧崩溃，那也没关系，我们将继续深入学习崩溃日志的阅读理解并解决问题。

此外，本文系我知识、经验与时间的结晶，请尊重他人成果，如有不足之处还烦请补充，十分感谢！

**//References  -  参考文献**

(1)  社区团队  ，Minecraft wiki  ， https://zh.minecraft.wiki/w/Java%E7%89%88

(2)  lzhfdxhxm  ， CSDN  ， JDK version和class file version(Class编译版本号)对应关系-CSDN博客

(3)  @杉狐， 频道帖子   ， https://pd.qq.com/s/cqw2bzlul?shareSource=5

(4)   @SGfannr  ， 频道帖子  ，https://pd.qq.com/s/47d19raiu?shareSource=5

(5) Iris Shaders 、Sodium开发团队  ，  MC百科  ， github  Iris Shaders - MC百科|最大的Minecraft中文MOD百科 (mcmod.cn)

CaffeineMC/sodium-fabric: A Fabric mod designed to improve frame rates and reduce micro-stutter (github.com)

---

---
url: /zhCN/guide/standard/lx-stable-test-standard.md
---
# LauncherX 稳定版构建许可测试标准

为了确保稳定版和公众测试版的基本稳定性，制定此标准。在从上游构建分支向下合并时，最新的上游构建需要经过人为的此测试流程，并且满足此测试要求，方允许向下手动合并.

## 测试流程

在每月下旬，合并Higgs到Neutrino，以供在Neutrino开始评估版本。这是为了不影响Higgs分支的主线开发进程.

测试员需要在所有支持的操作系统平台上执行测试。为了确保基本可用性，在不同的操作系统需要作出不同的环境控制.

* Windows: 如果系统环境是测试员的日常工作环境，为了避免受到工作环境的影响，建议测试员开启新的Windows沙盒实例进行测试.
* macOS: 如果系统环境是测试员的日常工作环境，为了避免受到工作环境的影响，可以创建专用于测试的虚拟机，或新建用户账户来隔离测试环境.
* Linux: 建议测试员使用虚拟机准备测试环境。若有可能，应该创建全新的虚拟机。测试需要涵盖Ubuntu系列和Fedora系列，Arch系列可选.

从初次设置开始，对崭新启动的LauncherX进行功能测试。具体测试内容如下:

## 测试内容

* 从初次设置到启动器设置到具体游戏设置，按钮、输入框等需要依次测试并判断启动器行为是否符合预期.
* 测试个性化外观选项是否符合预期
* 测试游戏下载、安装、带游戏模组加载器的版本是否能正常安装
* 游戏是否能正常补全，补全游戏是否能正常启动
* 导入导出整合包是否正常工作
* 尝试触发崩溃，崩溃分析器和支持包生成是否正常工作

## 预期结果

* 所有输入框在编辑、清空、输入非预期内容后均不会导致启动器崩溃，所有按钮都可以正常唤起功能方法且不会引发崩溃
* 外观符合文字介绍的预期
* 游戏能正常下载安装
* 游戏能正常补全和启动
* 所有支持的整合包均正常可以导出和导入，导出的完整包内容可用
* 崩溃分析器按预期触发，支持包内容完整可用.

## 后续

以上测试内容全部通过，代表这个Neutrino版本可以向下合并到Proton，然后在每月(或每两个月)固定日期推送到Stable。一个阶段的稳定版审核通过，宣发人员开始在各平台更新启动器内容更新日志.

---

---
url: /zhCN/lxguide/features.md
---
# LauncherX有趣的功能

这里主要介绍了一些内置于LauncherX的独特功能。由许多实用、有趣、方便的功能点缀的启动器将能极大地提升您的体验。这一系列说明将帮助您更快地上手使用.

:::warning 这里的功能介绍可能随时出现细微变动。恕无法另行通知.

此外，这里还有一些使用LauncherX时候的“奇技淫巧”。

奇技具有以下特征：

* 通过有技巧性的操作实现原本LauncherX本不明确支持的功能
* 在原理上并未利用bug

如果你发现了什么新的奇技，可以和我们分享。我们或许会在整理后发布在这里。

---

---
url: /zhCN/lxguide/features/modpack-support.md
---
# LauncherX的整合包支持

> LauncherX对curseforge、modrinth格式整合包做出了相应的导入和导出支持。面对完整包分享者，LauncherX提供了可包含一个稳定版LauncherX、有许多附加导出选项可选的完整包打包功能。与此同时，LauncherX几乎没有对游戏目录作出魔改，确保了最高的兼容性.

\[\[toc]]

## 导入

### 一般导入

:::warning

LauncherX对较为主流的整合包格式做出了适配。但是，请注意，虽然MCBBS格式是基于Curseforge格式的，并且相关人员声称其与Curseforge格式相兼容，但是经过测试，LauncherX无法直接导入MCBBS格式整合包.

目前，LauncherX仅能识别 `.zip` 文件和 `.mrpack` 文件，且都必须为有效的Curseforge整合包或Modrinth整合包.

:::

您可以直接用“拖入”的方式来触发LauncherX的文件导入。准备好需要导入的文件，然后将其直接拖入到LauncherX窗体中。

**倘若** 没有触发导入提示框，则可能是您的系统或用户界面不支持拖入功能。无论如何，您都可以使用手动选择导入的方式来安装整合包。步骤如下:

* 点击“游戏列表”
* 点击左上角的“更多”
* 将鼠标移到“添加游戏资源”上方
* 点击扩展菜单中的“整合包”
* 在弹出窗口中选中需要导入的整合包并确认

此时您可以进行进行下一步操作了! 在LauncherX窗口中确认即将安装的整合包信息，然后点击安装，LauncherX将会完成后续操作.

:::info

如果系统存在x64兼容层，LauncherX会在ARM设备尝试打开x64构建时发出警告。在兼容层中运行将会带来巨大的性能损失，使用达成同等效果却功耗更大的方式运行程序将不利于减少能耗和碳排放.

:::

### 意外情况

:::warning

导入可能出现问题。下面解释了部分问题及其解决方法.

:::

1. 拖入/导入后界面中没有文字:请尝试再次导入。如果仍然出现此问题，可能是包文件损坏.
2. 导入时间过久或任务中心里出现任务错误:请检查网络连接，或更换下载服务器。因为部分整合包可能为了压缩体积而不包含mod本身，而是使用了指向本平台的下载链接，在导入时直接下载mod。*相关阅读: [专题: 检测网络](/zhCN/lxguide/settings/special/check-network)*
3. 其他:请依次尝试上述方法。如果无法解决，请保留错误报告、启动器日志，并通过[这里的反馈方法](/zhCN/lxguide/report-issue)向我们反馈.

## 导出

:::warning

请注意， LauncherX仅提供打包功能，对打包成品中引发的任何版权问题概不负责.

:::

要开始导出整合包，请先进入“游戏列表”，右键点击某一个具体的游戏，然后选中“导出为-” 并在接下来显示的次级菜单中点选您希望导出的格式.

### 导出完整包

LauncherX让您可以便捷地通过在游戏列表中右键点击游戏来将整个游戏版本导出为一个包含当前最新版本的LauncherX稳定版构建的完整包，并可选保留LauncherX的部分设置和游戏的部分内容。这使得发布包含完整启动环境的整合包更加便捷.

使用完整包导出引起的一切内容授权侵权纠纷均不由我们负责.

![exp\_cn](/img/lxguide/features/modpackSupport_exportAsFullPack_zhCN.png)

点击“导出为 - 完整包”后，将会弹出如图所示的窗口。接下来将解释导出前三个设置部分.

#### · 发布平台

这里可选择导出包中包含哪些版本的LauncherX。勾选对应的构建可以让玩家在解压后立刻能够使用内含的LauncherX打开游戏而无需另外寻找和下载兼容的启动器.

请注意，勾选的这些构建将在确认导出后开始下载并打包入压缩包，选择越多的构建将会使包体变大。如果一个也不选的话导出包将不包含任何LauncherX构建.

一般而言，首要推荐包含Windows x64，次要推荐包含macOS和Windows ARM。如果您的目标玩家有需要的话，选择性地包含其他构建.

#### · 启动器设置

导出的设置仅适用于LauncherX，如果导出的包不使用LauncherX进行游戏启动，则导出的设置不会有效.

**保存基础配置**: 包括所有的「全局游戏设置」、「外观设置」以及「网络设置」。除此之外的「已保存的账户」、「启动器账户」等设置均不保留。导出后的LauncherX会重新要求用户运行初次启动设置，但是已经预留的设置将作为默认值使用.

**保存壁纸**: 将会保存已经导入到LauncherX的壁纸。您可以为自己的整合包准备一张壁纸并设为LauncherX的图片背景，在设置中事先选中那个壁纸并勾选此选项将可以使导出的包可以在一打开时就使用此壁纸。但是请注意，这将会让导出包的体积随着已添加的壁纸增加.

#### · 游戏文件

**保留配置**: 是否保留当前游戏的设置。如果勾选此项，诸如按键绑定、视频设置、「OptiFine设置*未验证*」将会保留在导出的游戏目录中.

**保留默认配置**: *未验证* 是否保留(大多数由模组生成的) 默认设置。默认设置是用于部分情况下恢复默认设置的类似备份的配置文件.

**保留模组**: 是否包含此游戏中的模组目录及其中的文件.

**保留资源包**: 是否包含此游戏中的材质包目录及其中的文件.

**保留光影包**: 是否包含此游戏中的光影文件存储目录及其中的文件.

这个部分的选项基本与平台格式导出选项一致.

:::warning 关于「保留存档」

暂不支持「保留存档」。因为存档可能太大，请单独打包分享存档。如果需要LauncherX读区和打包存档，请通过[反馈方式](/zhCN/lxguide/report-issue) 向我们反馈，我们将在分析需求量后决定是否追加此项功能支持.

::: danger 此信息可能过时

:::

#### · 额外选项

![screenshot](data:image/png;base64,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)

**不允许玩家创建下列账户类型**：可选【离线账户、第三方登录、Microsoft】

**限制玩家所使用的第三方验证服务器**：输入框，接受外置登录验证服务器的URL地址

::: tip 关于上述两个选项

相关阅读见：[限制客户端 | 日冕知识库](/zhCN/lxguide/features/tricks/restricted-client.html#限制账户登录)

:::

**通过第三方API压缩完整包体积**：可选Modrinth和CurseForge，完成导出后，玩家将在初次启动启动器时安装游戏。

### 导出为平台格式

LauncherX目前对较为主流的整合包格式做出了导出适配.

#### 导出为Modrinth

:::tip

Modrinth格式的整合包导出后后缀名为 `.mrpack`。

:::

LauncherX支持将具体的游戏打包为Modrinth格式。这是由mod发布平台Modrinth设计的全新整合包格式，易于共享.

**打包步骤**:

* 打开“游戏列表”
* 右键选中一个游戏
* 点击“”
* 点击“Modrinth整合包”
* 选择需要保留的项目。您可以仅将mod打包，或者包含您的材质包等.
* 选择保存路径
* 在点击确认后，打包导出任务将在后台进行。导出完成后您应该会收到通知，如果导出成功，您将可在您之前选择的保存路径中找到对应导出的整合包文件.

#### 导出为Curseforge

:::tip

Curseforge格式的整合包导出后后缀名为 `.zip`。

:::

LauncherX同样支持将整合包导出为Curseforge格式。Curseforge格式是由Curseforge平台设计的可扩展的整合包格式，打包体积较小。

**打包步骤**:

* 打开“游戏列表”
* 右键选中一个游戏
* 点击“”
* 点击“CurseForge整合包”
* 选择需要保留的项目。您可以仅将mod打包，或者包含您的材质包等.
* 选择保存路径
* 在点击确认后，打包导出任务将在后台进行。导出完成后您应该会收到通知，如果导出成功，您将可在您之前选择的保存路径中找到对应导出的整合包文件.

### 目录规则

目录规则是LauncherX自有的一套规则，旨在将游戏目录中需要的文件夹包括进整合包，或阻止绝对不需要的文件夹被打包进整合包。

目录规则的文件名是`FOLDER_RULES`，你可以右键点击游戏列表中的任意游戏条目然后点击 “生成导出配置” 来生成新的模板配置文件或覆盖已有的配置文件，或点击 “编辑导出配置” 来让操作系统打开现有的配置文件（如果有）。

规则配置文件的格式如下：

```yaml{5-7}
# FOLDER_RULES
# 这个文件是用于控制 LauncherX 导出整合包时，哪些文件夹会被包含在内的。
# 如果想包含某个文件夹，则将其前面加上 + 号。
# 如果不想包含某个文件夹，则将其前面加上 - 号。
# '#' 开头的行会被视为注释。 
# 任何不是以 '+' 或 '-' 开头的条目都不会被视为有效的规则 
# 请在 '+'/'-' 后紧跟文件夹的名字，不要使用空格分割 
# 示例：

+tacz # 将包含tacz // [!code ++]
-schematics # 排除掉默认规则会包含的schematics // [!code --]

```

::: details 默认规则

下面的规则是默认规则，除非你覆盖了它们，否则它们会被应用。

* packmenu

* craftpresence

* patchouli\_books

* armourers\_workshop

* structures

* tacz

* modernfix

* scripts

* potionblender

* menu

* fancymenu\_setups

* fancymenu\_data

* global\_packs

* oresources

* configureddefaults

* fontfiles

* worldshape

* resources

* kubejs

* tlm\_custom\_pack

* openloader

* CustomSkinLoader

* journeymap

* minemenu

* paintings

* schematics

:::

导出为任意包均可通过选中【使用FOLDER\_RULES规则】来启用自定义的规则，除非文件夹本身是空的或不存在，否则导出的整合包将包含需要包含的文件夹。

## 完整包使用方法

:::info

下文引用了打包后压缩包内的说明文件并进行了细化.

:::

**免责声明**

此整合包由LauncherX生成，且由分享者选择了指定的LauncherX构建。LauncherX仅提供完整整合包打包功能，对打包内容不负侵权等法律责任，亦不对打包内容的安全性作出保证。

**使用说明**

您需要先为这个整合包准备一个新的文件夹。然后，将此压缩包中全部内容解压到这个新的文件夹中。

包内目录结构说明：

* .minecraft是包内包含的游戏本体的存储目录（macOS用户和Linux用户可能无法直接看到它）；
* LauncherX文件夹是LauncherX可携带运行文件存储的目录（如果存在）；
* \[LauncherX]\_Please\_Decompress\_This\_File.zip 压缩包 是由分享者选择的LauncherX稳定版构建，即启动器程序本体。请打开它并按照您的操作系统和架构选择具体的主程序。
* LauncherX.json 是LauncherX被导出时的设置（如果存在）；
* 一个readme.txt文件，是本页面内容的精简版，包含汉英双语版本.

接下来，倘若您是Windows用户，那么打开LauncherX.Avalonia.exe，即可开始体验这个完整包。（LauncherX可能会要求您进行初次设置，但是具体情况可能视分享者的导出配置而定。）;

**但** 如果您是macOS或Linux用户并且整合包内存在 “LauncherX的配置文件（LauncherX.json）和LauncherX文件夹” ，那么您需要将这两个项目保持同级地复制到指定的目录下：

```js
macOS = "~/documents/Library/Application Support/LauncherX/"       
// 两个项目均存放在这个路径中 
// (~是您用户文件夹的起始点。一般会在Finder中显示一个小房子的图标；
// Library可能会显示为其本地化名称“资源库”，而documents可能本地化叫做“文档”)

Linux = "~/documents/LauncherX/"       
// 两个项目均存放在这个路径中
```

然后，(**方法一**)

​	~您可以把.minecraft文件夹保留在解压后的原地（或者您如果看不见它的话，它就在原地），然后手动将这个文件夹作为新的游戏目录添加到LauncherX（在LauncherX的”游戏列表->\[左上角的]更多->基础设置“中，点击添加。如果您看不到.minecraft文件夹，选择它存在的上级目录，LauncherX将会自动选择到存在的.minecraft文件夹。【此功能要求LXIT issue #46移除Invalid并真正更新实装】）；

或者，(**方法二**)

​	~将它复制或移动到指定的目录下：

```js
macOS: "~/documents/Library/Application Support/"      
// .minecraft/ 存放在这个路径下 
// (~是您用户文件夹的起始点。一般会在Finder中显示一个小房子的图标；
// Library可能会显示为其本地化名称“资源库”，而documents可能本地化叫做“文档”)

Linux: "~/documents/"      
// .minecraft/ 存放在这个路径下
```

此目录是LauncherX和官方启动器都会使用的默认的游戏目录。如果您不希望整合包内容扰乱您的既有游戏目录，您应该使用第一个方法。

---

---
url: /enUS/projbobcat/resourceCompleter/resourceInfoResolver/libraryInfoResolver.md
---
# Libraries resolver

\[\[toc]]

The Libraries resolver provides parsing and verification functions for game asset files. These files are stored in
In the `.minecraft/libraries` directory, these files are the runtime files necessary to start MineCraft.

## Initialize the resolver

You can initialize the Libraries resolver with the following code:

```c#

var resolver = new LibraryInfoResolver
{
    BasePath = "[GAME_ROOT_PATH]",
    ForgeUriRoot = "https://files.minecraftforge.net/maven/",
    ForgeMavenUriRoot = "https://maven.minecraftforge.net/",
    ForgeMavenOldUriRoot = "https://files.minecraftforge.net/maven/",
    FabricMavenUriRoot = "https://maven.fabricmc.net/",
    LibraryUriRoot = "https://libraries.minecraft.net/",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES]
};

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:-----------------------:|:-------------------------------:|
| \[GAME\_ROOT\_PATH] | The game root directory, usually the path to the .minecraft folder |
| \[SEARCHED\_VERSION\_INFO] | VersionInfo of the version to check (obtained via game locator) |
| \[CHECK\_LOCAL\_FILES] | Check local files (if false, skip all checks) |

---

---
url: /ruRU/projbobcat/resourceCompleter/resourceInfoResolver/libraryInfoResolver.md
---
# Libraries 解析器

\[\[toc]]

Libraries 解析器提供了对游戏资产文件的解析和验证功能, 这些文件存放在
`.minecraft/libraries` 目录下, 这些文件是启动 MineCraft 所必需的运行时文件.

## 初始化解析器

你可以通过下面的代码来初始化 Libraries 解析器：

```c#

var resolver = new LibraryInfoResolver
{
    BasePath = "[GAME_ROOT_PATH]",
    ForgeUriRoot = "https://files.minecraftforge.net/maven/",
    ForgeMavenUriRoot = "https://maven.minecraftforge.net/",
    ForgeMavenOldUriRoot = "https://files.minecraftforge.net/maven/",
    FabricMavenUriRoot = "https://maven.fabricmc.net/",
    LibraryUriRoot = "https://libraries.minecraft.net/",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES]
};

```

在上述代码块中, 请将这些参数按照您的实际情况替换：

|           项目            |               说明                |
|:-----------------------:|:-------------------------------:|
|    \[GAME\_ROOT\_PATH]     |   游戏根目录, 通常为 .minecraft 文件夹的路径   |
| \[SEARCHED\_VERSION\_INFO] | 要检查的版本的 VersionInfo （通过游戏定位器获得） |
|   \[CHECK\_LOCAL\_FILES]   |    检查本地文件（如果为 false, 则跳过所有检查）    |

---

---
url: /zhCN/projbobcat/resourceCompleter/resourceInfoResolver/libraryInfoResolver.md
---
# Libraries 解析器

\[\[toc]]

Libraries 解析器提供了对游戏资产文件的解析和验证功能，这些文件存放在
`.minecraft/libraries` 目录下，这些文件是启动 MineCraft 所必需的运行时文件。

## 初始化解析器

你可以通过下面的代码来初始化 Libraries 解析器：

```c#
var resolver = new LibraryInfoResolver
{
    BasePath = "[GAME_ROOT_PATH]",
    ForgeUriRoot = "https://files.minecraftforge.net/maven/",
    ForgeMavenUriRoot = "https://maven.minecraftforge.net/",
    ForgeMavenOldUriRoot = "https://files.minecraftforge.net/maven/",
    FabricMavenUriRoot = "https://maven.fabricmc.net/",
    LibraryUriRoot = "https://libraries.minecraft.net/",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES]
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|           项目            |               说明                |
|:-----------------------:|:-------------------------------:|
|    \[GAME\_ROOT\_PATH]     |   游戏根目录，通常为 .minecraft 文件夹的路径   |
| \[SEARCHED\_VERSION\_INFO] | 要检查的版本的 VersionInfo （通过游戏定位器获得） |
|   \[CHECK\_LOCAL\_FILES]   |    检查本地文件（如果为 false，则跳过所有检查）    |

---

---
url: /zhTW/projbobcat/resourceCompleter/resourceInfoResolver/libraryInfoResolver.md
---
# Libraries 解析器

\[\[toc]]

Libraries 解析器提供了對遊戲資產檔案的解析和驗證功能, 這些檔案存放在
`.minecraft/libraries` 目錄下, 這些檔案是啟動 MineCraft 所必需的執行時檔案.

## 初始化解析器

你可以透過下面的程式碼來初始化 Libraries 解析器：

```c#

var resolver = new LibraryInfoResolver
{
    BasePath = "[GAME_ROOT_PATH]",
    ForgeUriRoot = "https://files.minecraftforge.net/maven/",
    ForgeMavenUriRoot = "https://maven.minecraftforge.net/",
    ForgeMavenOldUriRoot = "https://files.minecraftforge.net/maven/",
    FabricMavenUriRoot = "https://maven.fabricmc.net/",
    LibraryUriRoot = "https://libraries.minecraft.net/",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES]
};

```

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|           專案            |               說明                |
|:-----------------------:|:-------------------------------:|
|    \[GAME\_ROOT\_PATH]     |   遊戲根目錄, 通常為 .minecraft 資料夾的路徑   |
| \[SEARCHED\_VERSION\_INFO] | 要檢查的版本的 VersionInfo （透過遊戲定位器獲得） |
|   \[CHECK\_LOCAL\_FILES]   |    檢查本地檔案（如果為 false, 則跳過所有檢查）    |

---

---
url: /zhCN/lxguide/settings/special/linux-as-others.md
---
# Linux：干掉标题栏，还我一致感

不知道诸位Linux用户是否遇到过这样的烦人场景：

本来是希望LauncherX在Linux上也是简洁美观的，结果一打开发现窗口顶部有一个可憎的标题栏，盘踞在那里，破坏着LauncherX天生的和谐感？

抑或是打开LauncherX发现没有最小化、最大化、关闭 这三个按钮？

不要急！本文将给您一个“恢复LauncherX美貌”的方法。

\[\[toc]]

::: info 先决条件

* 您正在使用Wayland作为显示服务器。参见：[针对 Linux 系统的特殊设置 | 日冕知识库](/zhCN/lxguide/startup/perOsSetup/linux) 的最后一段
* 您已经将LauncherX更新到最新版本

:::

接下来以Manjaro KDE Plasma Wayland为基础示范如何让Linux上的LauncherX看起来和其他平台（Windows，macOS）一样。

1. 启动LauncherX，前往`设置 -> 外观 -> 基础设定`，找到`主界面按钮组可见性` 或 `窗口按钮组可见性` 设置项；
2. 【自动】将根据系统环境来判断是否应该显示按钮组。这个功能较为实验性，您可以考虑将其设置为“可见”：![这项设置的截图](/img/lxguide/killTitleBarLinux/an-optional-manual-operation.png)
3. 如果此时LauncherX存在系统给与的标题栏，请**右键**点击它，然后点击“配置特殊应用程序设置”：![这项设置的截图](/img/lxguide/killTitleBarLinux/be-sure-to-config.png)不要点击“无标题栏和边框”，因为这个设置在重启后就不会再生效了。
4. 按照下图进行配置：![这项设置的截图](/img/lxguide/killTitleBarLinux/config-forever.png)“外观和修正” 下方的 “无标题栏和边框” 需要先点击下方的 “添加属性” 来添加，然后如图配置。
5. 点击底部的 “应用” 和 “确定”，如果需要的话，请重启LauncherX。

一切顺利的话，您的LauncherX将可以是这个样子：

![这项设置的截图](/img/lxguide/killTitleBarLinux/done.png)

开始享用吧！

---

---
url: /zhCN/lxguide/startup/others/Linux-Guide.md
---
# Linux中LauncherX的配置指南

LauncherX是一款新生的MC启动器\
当它正式发布时，就成为了Linux上为数不多能愉快使用的MC启动器\
不过别慌，本文章就是为了讲解如何配置LauncherX而生\
接下来，让我们开始配置吧！

## 如何下载？

先更新系统
然后前往[Corona Studios](https://corona.studio/lx)官方网址下载\
下载完的文件应该叫"net9.0-linux.linux-x64.zip"\
解压，你会获得一个名为“LauncherX.Avalonia"的文件

## 如何打开？

将LauncherX.Avalonia文件移动到你想要放置的地方\
这里我建议放在/home下的一个不经常修改文件的文件夹，以便后面的工作易于进行，至于是什么嘛，猜去吧\
然后在文件管理器中右键选择打开命令行，或者打开命令行并cd到lx的文件所在目录\
输入：

```bash
./LauncherX.Avalonia
```

> 认为每次都要这么启动很麻烦？那快点往下看吧

当你看到如下页面时，说明你成功运行了LauncherX\
![欢迎界面](/img/lxguide/perOsSetup/start-page.png)

## 如何配置？

接下来，配置你需要的外观，登录你需要登录的账户，未登录不可进入

> :red\_circle:**请注意: 目前Linux稳定版有一个右键点击账户就会闪退的Bug，内测版已经修复，但截止于2025.06.09前稳定版暂未修复**

接下来就是要玩MC最重要的部分了：\
配置JVM运行环境\
在你登录好账户后，LauncherX会显示一个配置界面：
![配置文件](/img/lxguide/perOsSetup/choose-java-page.png)

这里有两种下载Java并配置的方法

**如果安装了Java，且LauncherX检测到了你的Java，那么可以跳过**

### 一.使用包管理器安装

```bash
sudo pacman -Sy jdk-openjdk //Arch系，Pacman会为你配置好一切
sudo dnf install java-latest-openjdk.x86_64 //RPM系，需要配置环境变量
sudo apt install openjdk-21-jdk //Deb系，需要较新系统，较老的请使用第二种方法
```

> 这里我建议用较新版Java，如果想要游玩老版本MC，或想要稳定，请选择其他Jdk包
> 如若无法使用上面的命令下载，请使用第二种方法

RPM系和DEB系下载完后请看这里：\
**配置Java环境变量：**\
将下面的环境变量加入.bashrc或.zshrc等shell配置文件

```bashrc
export JAVA_HOME=/usr/lib/jvm/java-21-openjdk
export PATH=$JAVA_HOME/bin:$PATH
export JAVA_TOOL_OPTIONS="-Dfile.encoding=UTF-8"
```

> 其中java-21-openjdk可修改为自己安装的JDK版本

然后重启电脑或在终端中运行：

```bash
source ~/.bashrc //bash用户运行这个
source ~/.zshrc //zsh用户运行这个
```

### 二.使用LauncherX下载

在全局游戏设置界面，点击下载Java，选择你需要的版本，点击下载\
LauncherX会用最快的速度为你下载并配置好Java\
当你配置完JVM运行环境时，选择是否遥测之后，如果显示出如下界面，那你就就把基本准备工作做完了\
![主页](/img/lxguide/perOsSetup/launcherx-main-page.png)

> Tips点不掉吗？重启启动器就消失了

## 现在就可以下载游戏啦

> 若在下载阶段出现问题，任务中心报错
> 那么点击设置，选择网络，将多重源补全关闭，将mojang官方服务器更换为TapXapi

**刚才说的工作马上就来**

## 创建.desktop文件（按需）

创建LauncherX.desktop文件，使用Kate或Vim等文本编辑软件编辑该文件，并把下面对应的部分粘贴进文件\
（文件中的路径需要填写自己的LauncherX所在路径和图片文件所在路径）\
LauncherX启动器图标在[这里](/img/lxguide/perOsSetup/launcherx.png)，请自行下载（如不需要请将下面的Desktop中的Icon留空）\
**悠闲的Intel显卡和AMD显卡用户：**

```Desktop
[Desktop Entry]
Name=LaucherX
Version=1.0
Exec=/LauncherX所在路径/LauncherX.Avalonia
Icon=/LauncherX的启动器图标所在路径/启动器图标文件
Type=Application
Terminal=false
Categories=Minecraft;Application;
```

**被万恶的NVIDIA显卡毒害的用户（NVIDIA Fuck YOU！！）：**

```Desktop
[Desktop Entry]
Name=LaucherX
Version=1.0
__NV_PRIME_RENDER_OFFLOAD=1
__GLX_VENDOR_LIBRARY_NAME=nvidia
Exec=/LauncherX所在路径/LauncherX.Avalonia
Icon=/LauncherX的启动器图标所在路径/启动器图标文件
Type=Application
Terminal=false
Categories=Minecraft;Application;
```

保存，然后在文件管理器中右键选择打开命令行，或者打开命令行并cd到desktop文件的所在目录，然后输入：

```bash
sudo mv LauncherX.desktop /usr/share/applications
```

> **温馨提醒：LauncherX在Linux系统下是手动覆盖更新的，请每次更新都放在同一个文件夹，不然会导致Desktop文件失效**

这样，你就可以通过应用程序菜单进行打开LauncherX的操作了
**到这里，你的LauncherX启动器已经可以正常使用了**

## 在wayland中使用LauncherX，并需要使用输入法？

如果配置了全局环境变量，请略过\
创建完**LauncherX.desktop**文件后，在其中的Exec行加入

```Desktop
env XMODIFIERS=@im=fcitx //fcitx用户
env XMODIFIERS=@im=ibus //ibus用户
```

> 请务必加空格后再复制

## 使用AUR安装LauncherX（Arch Linux用户可选）

除了手动安装，你也可以选择AUR仓库进行安装

```bash
paru -Sy launcherx-bin
```

（不过我本人并不建议使用AUR包，更新比官方更新稍慢，不易修复已知Bug）

## 结语

我个人觉得在Linux发行版中使用LauncherX十分容易\
所以，愉快的去游戏吧！

---

---
url: /enUS/projbobcat/installers/liteloader.md
---
# LiteLoader Installer

\[\[toc]]

::: tip

Please note that ProjBobcat only implements the LiteLoader automated installation process. You still need to implement the search, download, and save process of the LiteLoader installation package yourself.

:::

::: warning

LiteLoader, as the early Minecraft mod system, has lacked maintenance and follow-up support for a long time.
Therefore, we may remove support for LiteLoader installation in future release.

:::

## Resources

* [LiteLoader Versions API](https://dl.liteloader.com/versions/versions.json)
* [BMCLAPI Development documentation](https://bmclapidoc.bangbang93.com/)

## Get LiteLoader Download Version Model

Because ProjBobcat's LiteLoader installer requires you to provide download information from the LiteLoader when initializing the installer.
Therefore, we will briefly describe here how to obtain this information based on a given MineCraft version.

::: info

In this example, we'll be using Minecraft 1.7.10 to show you how to get it.

:::

::: warning

Since LiteLoader officially does not provide public API documentation. Therefore, in this process, we need to use a third-party mirror source to complete data acquisition.
Here, we use [BMCLAPI](https://bmclapidoc.bangbang93.com/) to obtain relevant version information.

:::

First, you need to send an **HTTP GET** request to [https://bmclapi2.bangbang93.com/liteloader/list?mcversion=\[MC\_VERSION\]](https://bmclapi2.bangbang93.com/liteloader/list?mcversion=1.7.10).
Replace `[MC_VERSION]` with the Minecraft version you want to install. Here we will use 1.7.10 for demostration.

You will see something similar to the following returned:

```json

{
  "_id": "59685511433f993503c1c879",
  "mcversion": "1.7.10",
  "build": {
    "tweakClass": "com.mumfrey.liteloader.launch.LiteLoaderTweaker",
    "libraries": [...],
    "stream": "RELEASE",
    "file": "liteloader-1.7.10.jar",
    "version": "1.7.10_04",
    "md5": "63ada46e033d0cb6782bada09ad5ca4e",
    "timestamp": "1414368553",
    "srcJar": "liteloader-1.7.10_04-mcpnames-sources.jar",
    "mcpJar": "liteloader-1.7.10_04-mcpnames.jar"
  },
  "hash": "63ada46e033d0cb6782bada09ad5ca4e",
  "type": "RELEASE",
  "version": "1.7.10_04",
  "__v": 0
}

```

BMCLAPI will return a JSON object, and deserializing the object into the ProjBobcat type is the `LiteLoaderDownloadVersionModel` we need.

#### Convert JSON return to ProjBobcat type

If you are using [JSON.NET](https://www.newtonsoft.com/json)(Newtonsoft.JSON) in your project.
You can use code similar to the following to convert the server response you get into the corresponding ProjBobcat type:

```c#

// Requesting data from BMCLAPI (example, not actual code)
...
var responseJson = await res.Content.ReadAsStringAsync();

// Convert JSON response to ProjBobcat type // [!code focus]
var versionModel = JsonConvert.DeserializeObject<LiteLoaderDownloadVersionModel>(responseJson); // [!code focus]

```

This **versionModel** is the `LiteLoaderDownloadVersionMode` required by the Fabric installer.

## Get RawVersionModel

When initializing the LiteLoader installer, the installer needs to use the raw JSON content of the MineCraft game version corresponding to the LiteLoader.
That is, the contents of the `[ROOT_PATH]/versions/[MC_VERSION]/[MC_VERSION].json` file.

If you have installed the original game corresponding to LiteLoader, you can get the `RawVersionModel` through the following code:

```c#

// Get the path to the version JSON file
var jsonPath = GamePathHelper.GetGameJsonPath(rP, id);

// Read the contents of the file
var jsonContent = await File.ReadAllTextAsync(jsonPath);

// Convert JSON content to RawVersionModel
var baseVersionModel = JsonConvert.DeserializeObject<RawVersionModel>(jsonContent);

```

This **baseVersionModel** is the `RawVersionModel` required by the LiteLoader installer.

## Initialize the installer

The way to initialize the LiteLoader installer is very simple.
You need to initialize the installer using the `versionModel` and `baseVersionModel` obtained in the previous steps:

```c#

var liteLoaderInstaller = new LiteLoaderInstaller
{
    InheritVersion = baseVersionModel,
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]",
    RootPath = "[GAME_ROOT_PATH]",
    VersionModel = versionModel,
    CustomId = "[CUSTOM_INSTALL_GAME_ID]"
};

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:----------------------------------:|:------------------------------------------:|
| \[GAME\_ROOT\_PATH] | The game root directory, usually the path to the **.minecraft** folder |
| \[CUSTOM\_INSTALL\_GAME\_ID] | Optional, customize the name of the game to be installed |
| \[MC\_VERSION\_OR\_GAME\_ID] | The Minecraft original game version inherited by Forge, usually the game version. For example: 1.19.2 |
| \[VERSION\_LOCATOR\_INST] | Game version locator instance, that is, the **VersionLocator** attribute when initializing the game core |

## start installation

After you complete the initialization of the installer, you only need to call the installation method of the LiteLoader installer to complete the installation.

In an asynchronous context, use **InstallTaskAsync** to complete the installation:

```c#

await liteLoaderInstaller.InstallTaskAsync();

```

In a sync context, use **Install** to complete the installation:

```c#

liteLoaderInstaller.Install();

```

## Report installation progress

In some cases, the LiteLoader installer may take several minutes to complete the installation.
Therefore, you may need to report the current progress of the installer to the user in real time.
To this end, the LiteLoader installer provides the **StageChangedEventDelegate** event to help you implement task reporting.
You simply need to register for the following event **before starting the installation**:

```c#

liteLoaderInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

Among them, **args.Progress** indicates the current percentage progress of the installer. **args.CurrentStage** is a text description of the current progress of the installer.

---

---
url: /ruRU/projbobcat/installers/liteloader.md
---
# LiteLoader 安装器

\[\[toc]]

::: tip

请注意, ProjBobcat 仅实现了 LiteLoader 自动化安装流程, 您仍然需要自己实现 LiteLoader 安装包的搜索、下载、保存流程.

:::

::: warning

LiteLoader 作为早期 MineCraft 的模组系统, 已经长期缺乏维护和后续支持.
因此, 我们可能会在后续的版本中移除对 LiteLoader 安装的支持.

:::

## 实用资源

* [LiteLoader Versions API](https://dl.liteloader.com/versions/versions.json)
* [BMCLAPI 开发文档](https://bmclapidoc.bangbang93.com/)

## 获取 LiteLoader Download Version Model

由于 ProjBobcat 的 LiteLoader 安装器要求您在初始化安装器时提供来自 LiteLoader 的下载信息.
因此, 我们将在这里简要描述如何根据指定的 MineCraft 版本来获取该信息.

::: info

在该示例中, 我们将使用 MineCraft 1.7.10 来向您展示如何获取.

:::

::: warning

由于 LiteLoader 官方没有提供公开的 API 文档. 因此, 在本流程中, 我们需要使用第三方的镜像源来完成数据的获取.
在这里, 我们使用 [BMCLAPI](https://bmclapidoc.bangbang93.com/) 来获取相关的版本信息.

:::

首先, 您需要向 [https://bmclapi2.bangbang93.com/liteloader/list?mcversion=\[MC\_VERSION\]](https://bmclapi2.bangbang93.com/liteloader/list?mcversion=1.7.10) 发送一个 **HTTP GET** 请求.
将 `[MC_VERSION]` 替换为您想要安装的 MineCraft 版本. 在这里, 我们将使用 1.7.10.

您将看到类似下面的返回内容：

```json

{
  "_id": "59685511433f993503c1c879",
  "mcversion": "1.7.10",
  "build": {
    "tweakClass": "com.mumfrey.liteloader.launch.LiteLoaderTweaker",
    "libraries": [...],
    "stream": "RELEASE",
    "file": "liteloader-1.7.10.jar",
    "version": "1.7.10_04",
    "md5": "63ada46e033d0cb6782bada09ad5ca4e",
    "timestamp": "1414368553",
    "srcJar": "liteloader-1.7.10_04-mcpnames-sources.jar",
    "mcpJar": "liteloader-1.7.10_04-mcpnames.jar"
  },
  "hash": "63ada46e033d0cb6782bada09ad5ca4e",
  "type": "RELEASE",
  "version": "1.7.10_04",
  "__v": 0
}

```

BMCLAPI 将返回一个 JSON 对象, 将该对象反序列化为 ProjBobcat 类型即是我们需要的 `LiteLoaderDownloadVersionModel`.

#### 将 JSON 返回转换为 ProjBobcat 类型

如果您在您的项目中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）.
您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型：

```c#

// 从 BMCLAPI 请求数据（示例, 非实际代码）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus]
var versionModel = JsonConvert.DeserializeObject<LiteLoaderDownloadVersionModel>(responseJson); // [!code focus]

```

此处, **versionModel** 即是 Fabric 安装器所需要的 `LiteLoaderDownloadVersionMode`.

## 获取 RawVersionModel

在初始化 LiteLoader 安装器时, 安装器需要使用 LiteLoader 对应的 MineCraft 游戏版本的原始 JSON 内容.
即 `[ROOT_PATH]/versions/[MC_VERSION]/[MC_VERSION].json` 文件的内容.

如果您已经安装了 LiteLoader 对应的原版游戏, 您可以通过下面的代码获取到 `RawVersionModel`：

```c#

// 获取版本 JSON 文件所在的路径
var jsonPath = GamePathHelper.GetGameJsonPath(rP, id);

// 读取该文件的内容
var jsonContent = await File.ReadAllTextAsync(jsonPath);

// 将 JSON 内容转换为 RawVersionModel
var baseVersionModel = JsonConvert.DeserializeObject<RawVersionModel>(jsonContent);

```

此处, **baseVersionModel** 即是 LiteLoader 安装器所需要的 `RawVersionModel`.

## 初始化安装器

初始化 LiteLoader 安装器的方式非常简单.
您需要使用到在先前步骤中取得的 `versionModel` 和 `baseVersionModel` 来初始化安装器：

```c#

var liteLoaderInstaller = new LiteLoaderInstaller
{
    InheritVersion = baseVersionModel,
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]",
    RootPath = "[GAME_ROOT_PATH]",
    VersionModel = versionModel,
    CustomId = "[CUSTOM_INSTALL_GAME_ID]"
};

```

在上述代码块中, 请将这些参数按照您的实际情况替换：

|                 项目                  |                      说明                       |
|:-----------------------------------:|:---------------------------------------------:|
|          \[GAME\_ROOT\_PATH]           |          游戏根目录, 通常为 .minecraft 文件夹的路径          |
|      \[CUSTOM\_INSTALL\_GAME\_ID]       |              可选项, 自定义即将要安装的游戏的名称               |
|       \[MC\_VERSION\_OR\_GAME\_ID]       | Forge 继承的 MineCraft 原版游戏版本, 通常为游戏版本. 例如：1.19.2  |
|       \[VERSION\_LOCATOR\_INST]        |  游戏版本定位器实例, 即初始化游戏核心时的 **VersionLocator** 属性   |

## 开始安装

在您完成安装器的初始化后, 您只需要调用 LiteLoader 安装器的安装方法来完成安装.

在异步上下文中, 使用 **InstallTaskAsync** 来完成安装：

```c#

await liteLoaderInstaller.InstallTaskAsync();

```

在同步上下文中, 使用 **Install** 来完成安装：

```c#

liteLoaderInstaller.Install();

```

## 报告安装进度

在某些情况下, LiteLoader 安装器可能会需要数分钟的时间来完成安装.
因此, 您可能需要实时向用户汇报安装器目前的进度.
为此, LiteLoader 安装器提供了 **StageChangedEventDelegate** 事件来帮助您实现任务汇报.
您只需要简单地在 **开始安装之前** 注册下面的事件：

```c#

liteLoaderInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

其中,  **args.Progress** 指示了安装器当前的百分比进度. **args.CurrentStage** 则是安装器当前进度的文字描述.

---

---
url: /zhCN/projbobcat/installers/liteloader.md
---
# LiteLoader 安装器

\[\[toc]]

::: tip

请注意，ProjBobcat 仅实现了 LiteLoader 自动化安装流程，您仍然需要自己实现 LiteLoader 安装包的搜索、下载、保存流程。

:::

::: warning

LiteLoader 作为早期 MineCraft 的模组系统，已经长期缺乏维护和后续支持。
因此，我们可能会在后续的版本中移除对 LiteLoader 安装的支持。

:::

## 实用资源

* [LiteLoader Versions API](https://dl.liteloader.com/versions/versions.json)
* [BMCLAPI 开发文档](https://bmclapidoc.bangbang93.com/)

## 获取 LiteLoader Download Version Model

由于 ProjBobcat 的 LiteLoader 安装器要求您在初始化安装器时提供来自 LiteLoader 的下载信息。
因此，我们将在这里简要描述如何根据指定的 MineCraft 版本来获取该信息。

::: info

在该示例中，我们将使用 MineCraft 1.7.10 来向您展示如何获取。

:::

::: warning

由于 LiteLoader 官方没有提供公开的 API 文档。因此，在本流程中，我们需要使用第三方的镜像源来完成数据的获取。
在这里，我们使用 [BMCLAPI](https://bmclapidoc.bangbang93.com/) 来获取相关的版本信息。

:::

首先，您需要向 [https://bmclapi2.bangbang93.com/liteloader/list?mcversion=\[MC\_VERSION\]](https://bmclapi2.bangbang93.com/liteloader/list?mcversion=1.7.10) 发送一个 **HTTP GET** 请求。
将 `[MC_VERSION]` 替换为您想要安装的 MineCraft 版本。在这里，我们将使用 1.7.10。

您将看到类似下面的返回内容：

```json
{
  "_id": "59685511433f993503c1c879",
  "mcversion": "1.7.10",
  "build": {
    "tweakClass": "com.mumfrey.liteloader.launch.LiteLoaderTweaker",
    "libraries": [...],
    "stream": "RELEASE",
    "file": "liteloader-1.7.10.jar",
    "version": "1.7.10_04",
    "md5": "63ada46e033d0cb6782bada09ad5ca4e",
    "timestamp": "1414368553",
    "srcJar": "liteloader-1.7.10_04-mcpnames-sources.jar",
    "mcpJar": "liteloader-1.7.10_04-mcpnames.jar"
  },
  "hash": "63ada46e033d0cb6782bada09ad5ca4e",
  "type": "RELEASE",
  "version": "1.7.10_04",
  "__v": 0
}
```

BMCLAPI 将返回一个 JSON 对象，将该对象反序列化为 ProjBobcat 类型即是我们需要的 `LiteLoaderDownloadVersionModel`。

#### 将 JSON 返回转换为 ProjBobcat 类型

如果您在您的项目中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）。
您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型：

```c#
// 从 BMCLAPI 请求数据（示例，非实际代码）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus]
var versionModel = JsonConvert.DeserializeObject<LiteLoaderDownloadVersionModel>(responseJson); // [!code focus]
```

此处，**versionModel** 即是 Fabric 安装器所需要的 `LiteLoaderDownloadVersionMode`。

## 获取 RawVersionModel

在初始化 LiteLoader 安装器时，安装器需要使用 LiteLoader 对应的 MineCraft 游戏版本的原始 JSON 内容。
即 `[ROOT_PATH]/versions/[MC_VERSION]/[MC_VERSION].json` 文件的内容。

如果您已经安装了 LiteLoader 对应的原版游戏，您可以通过下面的代码获取到 `RawVersionModel`：

```c#
// 获取版本 JSON 文件所在的路径
var jsonPath = GamePathHelper.GetGameJsonPath(rP，id);

// 读取该文件的内容
var jsonContent = await File.ReadAllTextAsync(jsonPath);

// 将 JSON 内容转换为 RawVersionModel
var baseVersionModel = JsonConvert.DeserializeObject<RawVersionModel>(jsonContent);
```

此处，**baseVersionModel** 即是 LiteLoader 安装器所需要的 `RawVersionModel`。

## 初始化安装器

初始化 LiteLoader 安装器的方式非常简单。
您需要使用到在先前步骤中取得的 `versionModel` 和 `baseVersionModel` 来初始化安装器：

```c#
var liteLoaderInstaller = new LiteLoaderInstaller
{
    InheritVersion = baseVersionModel,
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]",
    RootPath = "[GAME_ROOT_PATH]",
    VersionModel = versionModel,
    CustomId = "[CUSTOM_INSTALL_GAME_ID]"
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|                 项目                  |                      说明                       |
|:-----------------------------------:|:---------------------------------------------:|
|          \[GAME\_ROOT\_PATH]           |          游戏根目录，通常为 .minecraft 文件夹的路径          |
|      \[CUSTOM\_INSTALL\_GAME\_ID]       |              可选项，自定义即将要安装的游戏的名称               |
|       \[MC\_VERSION\_OR\_GAME\_ID]       | Forge 继承的 MineCraft 原版游戏版本，通常为游戏版本。例如：1.19.2  |
|       \[VERSION\_LOCATOR\_INST]        |  游戏版本定位器实例，即初始化游戏核心时的 **VersionLocator** 属性   |

## 开始安装

在您完成安装器的初始化后，您只需要调用 LiteLoader 安装器的安装方法来完成安装。

在异步上下文中，使用 **InstallTaskAsync** 来完成安装：

```c#
await liteLoaderInstaller.InstallTaskAsync();
```

在同步上下文中，使用 **Install** 来完成安装：

```c#
liteLoaderInstaller.Install();
```

## 报告安装进度

在某些情况下，LiteLoader 安装器可能会需要数分钟的时间来完成安装。
因此，您可能需要实时向用户汇报安装器目前的进度。
为此，LiteLoader 安装器提供了 **StageChangedEventDelegate** 事件来帮助您实现任务汇报。
您只需要简单地在 **开始安装之前** 注册下面的事件：

```c#
liteLoaderInstaller.StageChangedEventDelegate += (_，args) => {
    ReportProgress(args.Progress，args.CurrentStage);
};
```

其中， **args.Progress** 指示了安装器当前的百分比进度。**args.CurrentStage** 则是安装器当前进度的文字描述。

---

---
url: /zhTW/projbobcat/installers/liteloader.md
---
# LiteLoader 安裝器

\[\[toc]]

::: tip

請注意, ProjBobcat 僅實現了 LiteLoader 自動化安裝流程, 您仍然需要自己實現 LiteLoader 安裝包的搜尋、下載、儲存流程.

:::

::: warning

LiteLoader 作為早期 MineCraft 的模組系統, 已經長期缺乏維護和後續支援.
因此, 我們可能會在後續的版本中移除對 LiteLoader 安裝的支援.

:::

## 實用資源

* [LiteLoader Versions API](https://dl.liteloader.com/versions/versions.json)
* [BMCLAPI 開發文件](https://bmclapidoc.bangbang93.com/)

## 獲取 LiteLoader Download Version Model

由於 ProjBobcat 的 LiteLoader 安裝器要求您在初始化安裝器時提供來自 LiteLoader 的下載資訊.
因此, 我們將在這裡簡要描述如何根據指定的 MineCraft 版本來獲取該資訊.

::: info

在該示例中, 我們將使用 MineCraft 1.7.10 來向您展示如何獲取.

:::

::: warning

由於 LiteLoader 官方沒有提供公開的 API 文件. 因此, 在本流程中, 我們需要使用第三方的映象源來完成資料的獲取.
在這裡, 我們使用 [BMCLAPI](https://bmclapidoc.bangbang93.com/) 來獲取相關的版本資訊.

:::

首先, 您需要向 [https://bmclapi2.bangbang93.com/liteloader/list?mcversion=\[MC\_VERSION\]](https://bmclapi2.bangbang93.com/liteloader/list?mcversion=1.7.10) 傳送一個 **HTTP GET** 請求.
將 `[MC_VERSION]` 替換為您想要安裝的 MineCraft 版本. 在這裡, 我們將使用 1.7.10.

您將看到類似下面的返回內容：

```json

{
  "_id": "59685511433f993503c1c879",
  "mcversion": "1.7.10",
  "build": {
    "tweakClass": "com.mumfrey.liteloader.launch.LiteLoaderTweaker",
    "libraries": [...],
    "stream": "RELEASE",
    "file": "liteloader-1.7.10.jar",
    "version": "1.7.10_04",
    "md5": "63ada46e033d0cb6782bada09ad5ca4e",
    "timestamp": "1414368553",
    "srcJar": "liteloader-1.7.10_04-mcpnames-sources.jar",
    "mcpJar": "liteloader-1.7.10_04-mcpnames.jar"
  },
  "hash": "63ada46e033d0cb6782bada09ad5ca4e",
  "type": "RELEASE",
  "version": "1.7.10_04",
  "__v": 0
}

```

BMCLAPI 將返回一個 JSON 物件, 將該物件反序列化為 ProjBobcat 型別即是我們需要的 `LiteLoaderDownloadVersionModel`.

#### 將 JSON 返回轉換為 ProjBobcat 型別

如果您在您的專案中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）.
您可以使用類似下面的程式碼來將您獲取到的伺服器響應轉換為對應的 ProjBobcat 型別：

```c#

// 從 BMCLAPI 請求資料（示例, 非實際程式碼）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 將 JSON 響應轉換為 ProjBobcat 型別 // [!code focus]
var versionModel = JsonConvert.DeserializeObject<LiteLoaderDownloadVersionModel>(responseJson); // [!code focus]

```

此處, **versionModel** 即是 Fabric 安裝器所需要的 `LiteLoaderDownloadVersionMode`.

## 獲取 RawVersionModel

在初始化 LiteLoader 安裝器時, 安裝器需要使用 LiteLoader 對應的 MineCraft 遊戲版本的原始 JSON 內容.
即 `[ROOT_PATH]/versions/[MC_VERSION]/[MC_VERSION].json` 檔案的內容.

如果您已經安裝了 LiteLoader 對應的原版遊戲, 您可以透過下面的程式碼獲取到 `RawVersionModel`：

```c#

// 獲取版本 JSON 檔案所在的路徑
var jsonPath = GamePathHelper.GetGameJsonPath(rP, id);

// 讀取該檔案的內容
var jsonContent = await File.ReadAllTextAsync(jsonPath);

// 將 JSON 內容轉換為 RawVersionModel
var baseVersionModel = JsonConvert.DeserializeObject<RawVersionModel>(jsonContent);

```

此處, **baseVersionModel** 即是 LiteLoader 安裝器所需要的 `RawVersionModel`.

## 初始化安裝器

初始化 LiteLoader 安裝器的方式非常簡單.
您需要使用到在先前步驟中取得的 `versionModel` 和 `baseVersionModel` 來初始化安裝器：

```c#

var liteLoaderInstaller = new LiteLoaderInstaller
{
    InheritVersion = baseVersionModel,
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]",
    RootPath = "[GAME_ROOT_PATH]",
    VersionModel = versionModel,
    CustomId = "[CUSTOM_INSTALL_GAME_ID]"
};

```

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|                 專案                  |                      說明                       |
|:-----------------------------------:|:---------------------------------------------:|
|          \[GAME\_ROOT\_PATH]           |          遊戲根目錄, 通常為 .minecraft 資料夾的路徑          |
|      \[CUSTOM\_INSTALL\_GAME\_ID]       |              可選項, 自定義即將要安裝的遊戲的名稱               |
|       \[MC\_VERSION\_OR\_GAME\_ID]       | Forge 繼承的 MineCraft 原版遊戲版本, 通常為遊戲版本. 例如：1.19.2  |
|       \[VERSION\_LOCATOR\_INST]        |  遊戲版本定位器例項, 即初始化遊戲核心時的 **VersionLocator** 屬性   |

## 開始安裝

在您完成安裝器的初始化後, 您只需要呼叫 LiteLoader 安裝器的安裝方法來完成安裝.

在非同步上下文中, 使用 **InstallTaskAsync** 來完成安裝：

```c#

await liteLoaderInstaller.InstallTaskAsync();

```

在同步上下文中, 使用 **Install** 來完成安裝：

```c#

liteLoaderInstaller.Install();

```

## 報告安裝進度

在某些情況下, LiteLoader 安裝器可能會需要數分鐘的時間來完成安裝.
因此, 您可能需要實時向用戶彙報安裝器目前的進度.
為此, LiteLoader 安裝器提供了 **StageChangedEventDelegate** 事件來幫助您實現任務彙報.
您只需要簡單地在 **開始安裝之前** 註冊下面的事件：

```c#

liteLoaderInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

其中,  **args.Progress** 指示了安裝器當前的百分比進度. **args.CurrentStage** 則是安裝器當前進度的文字描述.

---

---
url: >-
  /enUS/projbobcat/resourceCompleter/resourceInfoResolver/gameLoggingInfoResolver.md
---
# log4j log formatting component resolver

\[\[toc]]

The log4j log formatting component resolver provides parsing and verification functions for game asset files. These files are stored in
`.minecraft/logging` directory

Using this resource resolver allows MineCraft to output log content formatted by log4j, similar to the following:

```xml

<log4j:Event logger="ekb" timestamp="1676012129" level="INFO" thread="Render thread">
    <log4j:Message>
        <![CDATA[Created: 512x512x4 minecraft:textures/atlas/shulker_boxes.png-atlas]]>
    </log4j:Message>
</log4j:Event>

```

## Initialize Resolver

You can initialize the log4j log formatting component resolver with the following code:

```c#

var resolver = new GameLoggingInfoResolver
{
    BasePath = "[GAME_ROOT_PATH]",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES]
};

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:-----------------------:|:-----------------------------:|
| \[GAME\_ROOT\_PATH] | The game root directory, usually the path to the **.minecraft** folder |
| \[SEARCHED\_VERSION\_INFO] | VersionInfo of the version to check (obtained via game locator) |
| \[CHECK\_LOCAL\_FILES] | Check local files (if false, skip all checks) |

---

---
url: >-
  /ruRU/projbobcat/resourceCompleter/resourceInfoResolver/gameLoggingInfoResolver.md
---
# log4j 日志格式化组件解析器

\[\[toc]]

log4j 日志格式化组件解析器提供了对游戏资产文件的解析和验证功能, 这些文件存放在
`.minecraft/logging` 目录下

使用该资源解析器可以使 MineCraft 输出经过 log4j 格式化后的日志内容, 类似于如下的内容：

```xml

<log4j:Event logger="ekb" timestamp="1676012129" level="INFO" thread="Render thread">
    <log4j:Message>
        <![CDATA[Created: 512x512x4 minecraft:textures/atlas/shulker_boxes.png-atlas]]>
    </log4j:Message>
</log4j:Event>

```

## 初始化解析器

你可以通过下面的代码来初始化 log4j 日志格式化组件解析器：

```c#

var resolver = new GameLoggingInfoResolver
{
    BasePath = "[GAME_ROOT_PATH]",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES]
};

```

在上述代码块中, 请将这些参数按照您的实际情况替换：

|           项目            |               说明                |
|:-----------------------:|:-------------------------------:|
|    \[GAME\_ROOT\_PATH]     |   游戏根目录, 通常为 .minecraft 文件夹的路径   |
| \[SEARCHED\_VERSION\_INFO] | 要检查的版本的 VersionInfo （通过游戏定位器获得） |
|   \[CHECK\_LOCAL\_FILES]   |    检查本地文件（如果为 false, 则跳过所有检查）    |

---

---
url: >-
  /zhCN/projbobcat/resourceCompleter/resourceInfoResolver/gameLoggingInfoResolver.md
---
# log4j 日志格式化组件解析器

\[\[toc]]

log4j 日志格式化组件解析器提供了对游戏资产文件的解析和验证功能，这些文件存放在
`.minecraft/logging` 目录下

使用该资源解析器可以使 MineCraft 输出经过 log4j 格式化后的日志内容，类似于如下的内容：

```xml
<log4j:Event logger="ekb" timestamp="1676012129" level="INFO" thread="Render thread">
    <log4j:Message>
        <![CDATA[Created: 512x512x4 minecraft:textures/atlas/shulker_boxes.png-atlas]]>
    </log4j:Message>
</log4j:Event>
```

## 初始化解析器

你可以通过下面的代码来初始化 log4j 日志格式化组件解析器：

```c#
var resolver = new GameLoggingInfoResolver
{
    BasePath = "[GAME_ROOT_PATH]",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES]
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|           项目            |               说明                |
|:-----------------------:|:-------------------------------:|
|    \[GAME\_ROOT\_PATH]     |   游戏根目录，通常为 .minecraft 文件夹的路径   |
| \[SEARCHED\_VERSION\_INFO] | 要检查的版本的 VersionInfo （通过游戏定位器获得） |
|   \[CHECK\_LOCAL\_FILES]   |    检查本地文件（如果为 false，则跳过所有检查）    |

---

---
url: >-
  /zhTW/projbobcat/resourceCompleter/resourceInfoResolver/gameLoggingInfoResolver.md
---
# log4j 日誌格式化元件解析器

\[\[toc]]

log4j 日誌格式化元件解析器提供了對遊戲資產檔案的解析和驗證功能, 這些檔案存放在
`.minecraft/logging` 目錄下

使用該資源解析器可以使 MineCraft 輸出經過 log4j 格式化後的日誌內容, 類似於如下的內容：

```xml

<log4j:Event logger="ekb" timestamp="1676012129" level="INFO" thread="Render thread">
    <log4j:Message>
        <![CDATA[Created: 512x512x4 minecraft:textures/atlas/shulker_boxes.png-atlas]]>
    </log4j:Message>
</log4j:Event>

```

## 初始化解析器

你可以透過下面的程式碼來初始化 log4j 日誌格式化元件解析器：

```c#

var resolver = new GameLoggingInfoResolver
{
    BasePath = "[GAME_ROOT_PATH]",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES]
};

```

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|           專案            |               說明                |
|:-----------------------:|:-------------------------------:|
|    \[GAME\_ROOT\_PATH]     |   遊戲根目錄, 通常為 .minecraft 資料夾的路徑   |
| \[SEARCHED\_VERSION\_INFO] | 要檢查的版本的 VersionInfo （透過遊戲定位器獲得） |
|   \[CHECK\_LOCAL\_FILES]   |    檢查本地檔案（如果為 false, 則跳過所有檢查）    |

---

---
url: /enUS/projbobcat/authenticators/microsoft.md
---
# Microsoft Authentication Model

\[\[toc]]

This authentication model implements the new Azure-based verification process and is applicable to all MineCraft versions currently under maintenance.

## Preparation

Because the new version of the authentication process uses Azure-based authentication.
Therefore, before you begin, make sure you have completed [Configuration of Azure Apps](/enUS/projbobcat/createNewAzureApp)

After completing the Azure application registration, please make sure to complete [Microsoft Authenticator Initialization](/enUS/projbobcat/installationAndConfig.html#ConfiguringMicrosoftLoginAuthenticator) at the program entry point.

### Configure cached credential providing method

Due to the particularity of this verification model, developers need to save the **refresh token** and **expiration time** returned by the first verification to help the validator complete the verification.
The validator will call this method for the first time during verification to query the validity of the local token cache. If the local token is still valid, the verification result will be returned directly.
If the locally cached token has expired, the developer needs to manually request a new token and return the refreshed token.

Here is a sample implementation code of this method:

```c#

public async Task<(bool, GraphAuthResultModel?)> CacheTokenProviderAsync()
{
    if (string.IsNullOrEmpty(XBLToken)) return (false, default);
    if (string.IsNullOrEmpty(XBLRefreshToken)) return (false, default);

    // Calculate expire date // [!code focus]
    var expireDate = LastRefreshedTime.AddSeconds(ExpiresIn); // [!code focus]

    // If the local cache token is still valid, the current token is returned directly. // [!code focus]
    // Otherwise, request a new token using the refresh token // [!code focus]
    if (expireDate > DateTime.Now)
    {
        var result = new GraphAuthResultModel // [!code focus]
        { // [!code focus]
            ExpiresIn = (int)(expireDate - DateTime.Now).TotalSeconds, // [!code focus]
            AccessToken = XBLToken, // [!code focus]
            RefreshToken = XBLRefreshToken // [!code focus]
        }; // [!code focus]

        return (true, result); // [!code focus]
    }
    
    // Request a new login token // [!code focus]
    var refreshReqDic = new List<KeyValuePair<string, string>> // [!code focus]
    { // [!code focus]
        new("client_id", MicrosoftAuthenticator.ApiSettings.ClientId), // [!code focus]
        new("refresh_token", XBLRefreshToken), // [!code focus]
        new("grant_type", "refresh_token") // [!code focus]
    }; // [!code focus]

    using var refreshReq = new HttpRequestMessage(HttpMethod.Post, MicrosoftAuthenticator.MSRefreshTokenRequestUrl) // [!code focus]
    { // [!code focus]
        Content = new FormUrlEncodedContent(refreshReqDic) // [!code focus]
    }; // [!code focus]

    using var refreshRes = await DefaultClient.SendAsync(refreshReq);
    var refreshContent = await refreshRes.Content.ReadAsStringAsync();
    var refreshModel = MicrosoftAuthenticator.ResolveMSGraphResult(refreshContent,
    GraphAuthResultModelContext.Default.GraphAuthResultModel);

    if (refreshModel is not GraphAuthResultModel model)
    {
        if (refreshModel is GraphResponseErrorModel error) // [!code focus]
        { // [!code focus]
            // Handle failed refresh operations here // [!code focus]
        } // [!code focus]

        return (false, default);
    }

    return (true, model);
}

```

### Configure first login device flow verification code display method

Because we use device flow verification to verify the player's Microsoft account.
Therefore, we need an additional method to present the one-time key and verification address required for device flow verification to the user.

Here is an example of this method:

```c#

private void DeviceTokenNotifier(DeviceIdResponseModel deviceIdResponseModel)
{
    // Display the obtained callback data to the front end
    DeviceCodeResponse = deviceIdResponseModel;
}

```

**DeviceIdResponseModel** contains all the information the user needs to complete verification:

|       Name        |           Function            |
|:---------------:|:-----------------------:|
|    UserCode     |       The secret key required for user authentication        |
| VerificationUri | Verification address, users need to visit this URL to complete subsequent verification steps |
|    ExpiresIn    |      Validation code expiration time (seconds)       |

Here you can see an example of the interface:

![device\_token\_demo](/img/projbobcat/authenticators/device_token_auth_display_demo.png)

In this interface, you need to include at least the following content:

* The secret key required to log in
* Specific verification address
* A short operation prompt to help users complete the verification operation

## Initialize validator

### Initial verification

:::warning

Please make sure you are ready before performing the following process **Configuring the first login device flow verification code display method** to ensure that users can obtain the correct initial login information!
:::

Initialize the validator:

```c#

var microsoftAuthenticator = new MicrosoftAuthenticator
{
    LauncherAccountParser = launcherAccountParser
};

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:------------------------:|:------------------------------------------:|
| launcherAccountParser | For initialization of the launcher account parser, see here |

### Not initial verification

Non-initial verification means using the Token cache obtained in the first verification for secondary verification.
It mainly uses CacheTokenProviderAsync to verify whether the local credentials are still valid. If the locally cached Token has expired, it will be refreshed in this method.

Initialize the validator:

```c#

var microsoftAuthenticator = new MicrosoftAuthenticator
{
    CacheTokenProvider = CacheTokenProviderAsync,
    Email = "[EMAIL]",
    LauncherAccountParser = launcherAccountParser
};

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:------------------------:|:---------------------------:|
| launcherAccountParser | For initialization of the launcher account parser, see here |
| \[EMAIL] | Email address to verify account                   |

:::tip

For the initialization of **launcherAccountParser** (game profile parser), please refer to the [Game Profile Parser](/enUS/projbobcat/additionalParsers/gameProfileParser) page

:::

## Get authentication results (first authentication)

After you complete the initialization of the authentication model, you only need to call the Microsoft Authenticator's authentication method for initial account authentication.

Here is a sample authentication code:

```c#

// Get authentication results // [!code focus]
// DeviceTokenNotifier: This is the information display method mentioned above. // [!code focus]
var authResult = await msAuth.GetMSAuthResult(DeviceTokenNotifier); // [!code focus]

if (authResult == null)
{
    // Handling failed authentication // [!code focus]
}

// Parse user fields from Jwt Token // [!code focus]
var claims = JwtTokenHelper.GetTokenInfo(authResult.IdToken); // [!code focus]
var email = claims.TryGetValue("email", out var outEmail) ? outEmail : null; // [!code focus]

if (string.IsNullOrEmpty(email))
{
    // Unable to resolve user's email address from Jwt credentials, treated as authentication failure // [!code focus]
    // This is most likely caused by Azure application or Scope configuration failure. // [!code focus]
}

// Save necessary user information to local disk in preparation for next authentication // [!code focus]
var msInfoModel = new MSAccountInfoModel
{
    XBLToken = authResult.AccessToken, // [!code focus]
    XBLRefreshToken = authResult.RefreshToken, // [!code focus]
    ExpiresIn = authResult.ExpiresIn, // [!code focus]
    Email = email // [!code focus]
};

```

## Get Authentication results (not initial authentication)

After you complete the initialization of the authentication model, you only need to call the authentication method of Microsoft Authenticator to complete the account authentication.

In an asynchronous context, use **AuthTaskAsync** to accomplish authentication:

```c#

var authResult = await microsoftAuthenticator.AuthTaskAsync(false);

```

In a sync context, use **Auth** to finish authentication:

```c#

var authResult = microsoftAuthenticator.Auth();

```

## Interpret authentication results

After the authentication method is completed, the authentication model will return the authentication result, which is of the parent type [AuthResultBase](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/Auth/AuthResultBase.cs) object.
All authentication results contain an enumeration value **AuthStatus**, which directly indicates the success or failure of the authentication result.
Below you can see an interpretation of the authentication results:

### Failed Authentication Result

By judging whether **Error** is empty, you can easily judge whether the authentication results returned by the authentication model are valid.
The **Error** object will contain the following fields to tell you some details:

|              Field               |        Description        |
|:-----------------------------:|:----------------:|
|    authResult.Error.Cause     |    The specific cause of the problem     |
|    authResult.Error.Error     |       error name       |
| authResult.Error.ErrorMessage | Details of the error, possibly including a solution |

### Successful authentication result

If the **Error** field in the authentication result is empty, it means that the authentication is valid. A successful authentication result will contain the following information:

|               Field            |            Description                      |
|:------------------------------:|:-------------------------------------------:|
|         authResult.Id          |   A unique identifier for the username. ProjBobcat uses a specific generation method to generate this identifier.   |
|     authResult.AccessToken     |                  Authorization credentials for the user account                  |
|      authResult.Profiles       |            List of roles available to the user, which may contain multiple available roles             |
|   authResult.SelectedProfile   |    The role currently selected by the user. This field may be empty. If it is empty, the user needs to be prompted for manual selection.     |
|        authResult.User         |            Summary of user account information, including some basic account information             |
|       authResult.LocalId       |             Local ID, usually a randomly generated UUID             |
|      authResult.RemoteId       |        The remote ID returned by the authentication server, usually a unique identifier for the user          |
|       authResult.XBoxUid       |                XBox Live UID                |
|        authResult.Email        |                 Verify email address used                  |
|   authResult.CurrentAuthTime   |   The current verification time, **Developers need to save this field to help confirm the validity of the local cache token**    |
|      authResult.ExpiresIn      | Token expiration time (unit: seconds), **Developers need to save this field to help confirm the validity of the local cache token**|
|    authResult.RefreshToken     |       Refresh token, **Developers need to save this field to help refresh expired tokens**        |
|        authResult.Skin         |                 Skin URL for user account                 |

:::warning

Please use corresponding restrictions or encryption operations to safely store confidential data related to user tokens. The leakage of this data may cause losses.

:::

---

---
url: /zhCN/projbobcat/authenticators/microsoft.md
---
# Microsoft 验证模型

\[\[toc]]

该验证模型实现了新版基于 Azure 的全新验证流程，适用于目前仍在维护的全部 MineCraft 版本。

## 准备工作

由于新版验证流程使用了基于 Azure 的验证方式。
因此，在开始之前请确保您已经完成了 [Azure 应用的配置](/zhCN/projbobcat/createNewAzureApp)

在完成了 Azure 的应用注册后，请确保在程序入口点完成了[微软验证器的初始化](/zhCN/projbobcat/installationAndConfig.html#配置微软登录验证器)。

### 配置缓存凭据提供方法

由于该验证模型的特殊性，开发者需要保存首次验证返回的 **刷新令牌** 和 **失效时间** 来帮助验证器完成验证。
验证器在验证时会首次调用该方法来查询本地令牌缓存的有效性，如果本地令牌仍然有效，则直接返回验证结果。
如本地缓存的令牌已失效，则需要开发者手动请求新令牌后并返回刷新后的令牌。

下面我们提供了一个该方法的样例实现：

```c#
public async Task<(bool，GraphAuthResultModel?)> CacheTokenProviderAsync()
{
    if (string.IsNullOrEmpty(XBLToken)) return (false,  default);
    if (string.IsNullOrEmpty(XBLRefreshToken)) return (false,  default);

    // 计算失效时间 // [!code focus]
    var expireDate = LastRefreshedTime.AddSeconds(ExpiresIn); // [!code focus]

    // 如果本地缓存令牌依旧是有效的，则直接返回当前令牌 // [!code focus]
    // 否则，使用刷新令牌请求新的令牌 // [!code focus]
    if (expireDate > DateTime.Now)
    {
        var result = new GraphAuthResultModel // [!code focus]
        { // [!code focus]
            ExpiresIn = (int)(expireDate - DateTime.Now).TotalSeconds,  // [!code focus]
            AccessToken = XBLToken,  // [!code focus]
            RefreshToken = XBLRefreshToken // [!code focus]
        }; // [!code focus]

        return (true,  result); // [!code focus]
    }
    
    // 请求新的登录令牌 // [!code focus]
    var refreshReqDic = new List<KeyValuePair<string,  string>> // [!code focus]
    { // [!code focus]
        new("client_id",  MicrosoftAuthenticator.ApiSettings.ClientId),  // [!code focus]
        new("refresh_token",  XBLRefreshToken),  // [!code focus]
        new("grant_type",  "refresh_token") // [!code focus]
    }; // [!code focus]

    using var refreshReq = new HttpRequestMessage(HttpMethod.Post,  MicrosoftAuthenticator.MSRefreshTokenRequestUrl) // [!code focus]
    { // [!code focus]
        Content = new FormUrlEncodedContent(refreshReqDic) // [!code focus]
    }; // [!code focus]

    using var refreshRes = await DefaultClient.SendAsync(refreshReq);
    var refreshContent = await refreshRes.Content.ReadAsStringAsync();
    var refreshModel = MicrosoftAuthenticator.ResolveMSGraphResult(refreshContent,
    GraphAuthResultModelContext.Default.GraphAuthResultModel);

    if (refreshModel is not GraphAuthResultModel model)
    {
        if (refreshModel is GraphResponseErrorModel error) // [!code focus]
        { // [!code focus]
            // 在这里处理失败的刷新操作 // [!code focus]
        } // [!code focus]

        return (false,  default);
    }

    return (true,  model);
}
```

### 配置首次登录设备流验证代码展示方法

由于我们采用了设备流验证的方式来验证玩家的微软账户。
因此，我们需要一个额外的方法将设备流验证所需要的一次性秘钥和验证地址展现给用户。

以下是这个方法的一个实例：

```c#
private void DeviceTokenNotifier(DeviceIdResponseModel deviceIdResponseModel)
{
    // 将获取到的回调数据展示到前端
    DeviceCodeResponse = deviceIdResponseModel;
}
```

**DeviceIdResponseModel** 中包含了用户完成验证所需要的所有信息：

|       名称        |           作用            |
|:---------------:|:-----------------------:|
|    UserCode     |       用户验证所需要的秘钥        |
| VerificationUri | 验证地址，用户需访问该网址来完成后续的验证步骤 |
|    ExpiresIn    |      验证代码的失效时间（秒）       |

在下面您可以看到一个示例的展示界面：

![device\_token\_demo](/img/projbobcat/authenticators/device_token_auth_display_demo.png)

在这个界面中，您至少需要包含以下的内容：

* 登录所需要的秘钥
* 具体的验证地址
* 一个简短的操作提示来帮助用户完成验证操作

## 初始化验证器

### 初次验证

:::warning

请确保在执行下面的流程前您已经准备好了 **配置首次登录设备流验证代码展示方法** 来确保用户能够获取到正确的初次登录信息！

:::

初始化验证器：

```c#
var microsoftAuthenticator = new MicrosoftAuthenticator
{
    LauncherAccountParser = launcherAccountParser
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|          项目           |                             说明                              |
|:---------------------:|:-----------------------------------------------------------:|
| launcherAccountParser |                     对于启动器账户解析器的初始化，详见此处                     |

### 非初次验证

非初次验证即使用在首次验证中获取到的 Token 缓存来进行二次验证。
其主要通过 CacheTokenProviderAsync 来验证本地凭据是否依旧有效，如果本地缓存的 Token 已经失效，则会在该方法中完成刷新。

初始化验证器：

```c#
var microsoftAuthenticator = new MicrosoftAuthenticator
{
    CacheTokenProvider = CacheTokenProviderAsync,
    Email = "[EMAIL]",
    LauncherAccountParser = launcherAccountParser
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|          项目           |                             说明                              |
|:---------------------:|:-----------------------------------------------------------:|
| launcherAccountParser |                     对于启动器账户解析器的初始化，详见此处                     |
|        \[EMAIL]        |                          验证账户的邮箱地址                          |

:::tip

对于 **launcherAccountParser**（游戏档案解析器）的初始化，请参考[游戏档案解析器](/zhCN/projbobcat/additionalParsers/gameProfileParser)页面

:::

## 获取验证结果（初次验证）

在您完成验证模型的初始化后，您只需要调用 Microsoft 验证器的验证方法来初次账户验证。

下面是一段样例验证代码：

```c#
// 获取验证结果 // [!code focus]
// DeviceTokenNotifier 即为前文提到的信息展示方法 // [!code focus]
var authResult = await msAuth.GetMSAuthResult(DeviceTokenNotifier); // [!code focus]

if (authResult == null)
{
    // 处理失败的验证 // [!code focus]
}

// 从 Jwt Token 中解析用户字段 // [!code focus]
var claims = JwtTokenHelper.GetTokenInfo(authResult.IdToken); // [!code focus]
var email = claims.TryGetValue("email"，out var outEmail) ? outEmail : null; // [!code focus]

if (string.IsNullOrEmpty(email))
{
    // 无法从 Jwt 凭据中无法解析用户的电子邮件地址，视作验证失败 // [!code focus]
    // 这很有可能是 Azure 应用或是 Scope 配置失败导致的 // [!code focus]
}

// 将必要的用户信息保存至本地磁盘以便为下一次验证做准备 // [!code focus]
var msInfoModel = new MSAccountInfoModel
{
    XBLToken = authResult.AccessToken，// [!code focus]
    XBLRefreshToken = authResult.RefreshToken，// [!code focus]
    ExpiresIn = authResult.ExpiresIn，// [!code focus]
    Email = email // [!code focus]
};
```

## 获取验证结果（非初次验证）

在您完成验证模型的初始化后，您只需要调用 Microsoft 验证器的验证方法来完成账户验证。

在异步上下文中，使用 **AuthTaskAsync** 来完成验证：

```c#
var authResult = await microsoftAuthenticator.AuthTaskAsync(false);
```

在同步上下文中，使用 **Auth** 来完成验证：

```c#
var authResult = microsoftAuthenticator.Auth();
```

## 解读验证结果

在验证方法完成之后，验证模型会返回验证结果，这是父类型为 [AuthResultBase](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/Auth/AuthResultBase.cs) 的对象。
所有的验证结果都包含一个枚举值 **AuthStatus**，该枚举值直接指示了验证结果的成功或是失败。
在下面您可以看到对验证结果的解读：

### 失败的验证结果

通过判断 **Error** 是否为空，您可以很轻松的判断验证模型返回的验证结果是否是有效的，
**Error** 对象会包含以下字段来告诉您一些细节：

|              字段               |        说明        |
|:-----------------------------:|:----------------:|
|    authResult.Error.Cause     |    导致问题的具体原因     |
|    authResult.Error.Error     |       错误名称       |
| authResult.Error.ErrorMessage | 错误的详细信息，可能包含解决方案 |

### 成功的验证结果

如果验证结果中的 **Error** 字段为空，则表示本次验证是有效的，成功的验证结果会包含下面的信息：

|               字段               |                     说明                      |
|:------------------------------:|:-------------------------------------------:|
|         authResult.Id          |   该用户名的唯一标识符，ProjBobcat 使用特定的生成方式来生成这个标识符   |
|     authResult.AccessToken     |                  用户账户的授权凭据                  |
|      authResult.Profiles       |            用户可用的角色列表，可能包含多个可用角色             |
|   authResult.SelectedProfile   |    用户当前选择的角色，该字段可能为空。如果为空则需要提示用户进行手动选择。     |
|        authResult.User         |            用户账户信息摘要，包含一些基础的账户信息             |
|       authResult.LocalId       |             本地 ID，通常为随机生成的 UUID             |
|      authResult.RemoteId       |         验证服务器返回的远程 ID，通常为该用户的唯一标识符          |
|       authResult.XBoxUid       |                XBox Live UID                |
|        authResult.Email        |                 验证所使用的邮箱地址                  |
|   authResult.CurrentAuthTime   |   当前的验证时间，**开发者需要保存这个字段来帮助确认本地缓存令牌的有效性**    |
|      authResult.ExpiresIn      | 令牌失效时间（单位：秒），**开发者需要保存这个字段来帮助确认本地缓存令牌的有效性** |
|    authResult.RefreshToken     |       刷新令牌，**开发者需要保存这个字段来帮助刷新失效的令牌**        |
|        authResult.Skin         |                 用户账户的皮肤 URL                 |

:::warning

请使用相应的限制或是加密等操作来安全的储存用户相关令牌的机密数据，这部分数据的泄露可能会造成损失。

:::

---

---
url: /enUS/skin.md
---
# Minecraft Skin Specifications (1.18+)

Here are the new skin specs starting with Minecraft 1.18

## Sample 1

![image info](/img/skin/template.png)

## Sample 2 (including grid)

![image info](/img/skin/template-grid.jpg)

---

---
url: /ruRU/skin.md
---
# Minecraft 皮肤规范（1.18+）

以下是从 Minecraft 1.18 开始的新皮肤规范

## 样例 1

![image info](/img/skin/template.png)

## 样例2（包含网格）

![image info](/img/skin/template-grid.jpg)

---

---
url: /zhCN/skin.md
---
# Minecraft 皮肤规范（1.18+）

以下是从 Minecraft 1.18 开始的新皮肤规范

## 样例 1

![image info](/img/skin/template.png)

## 样例2（包含网格）

![image info](/img/skin/template-grid.jpg)

---

---
url: /zhTW/skin.md
---
# Minecraft 面板規範（1.18+）

以下是從 Minecraft 1.18 開始的新面板規範

## 樣例 1

![image info](/img/skin/template.png)

## 樣例2（包含網格）

![image info](/img/skin/template-grid.jpg)

---

---
url: /zhCN/mc-starter.md
---
# Minecraft新手上路!

::: tip 欢迎!

真好! 你选择步入Minecraft的世界.

:::

—— 或许你以往并不了解Minecraft，只是偶然在某个博主的视频中看到了这尽是方块但充斥着无限可能的世界; 或者你曾经通过其他渠道接触过，但是如今想要真正开始深入，那么或许这一系列的文章将非常适合你。如果你真心想要了解这个游戏并在这个游戏里取得乐趣，那么请怀揣着一颗主动学习、举一反三的求知之心继续阅读吧!

### 资源和信息获取

在指引完你选择合适的Minecraft之后，本系列文章将仅介绍Minecraft Java Edition (Java版) 游戏上手的必要信息。此外，以下是「作为一个Minecraft玩家」可能用得上的获取资源和/或信息的网站.

| 名称                           | 网址                                                         | 做什么的?                                                    |
| ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| MineBBS                        | https://minebbs.com                                          | 这是一个前期以基岩版资源分享和讨论为主的论坛。如今这里有一些独特的游戏资源，并提供了一个交流讨论的环境。|
| MC百科                         | https://mcmod.cn                                             | 收录了许多高人气的游戏模组和其他资源，主要提供模组下载、筛选服务，以及诸如「命令方块指令生成」之类的实用工具。|
| ZhMCWiki | 中文Minecraft Wiki | https://zh.minecraft.wiki (源站) | https://wiki.biligame.com/mc/Minecraft\_Wiki (Bilibili维护的镜像) | 想必是最完整的Minecraft游戏维基 (可以理解为百科全书)涵盖了最主要的两个版本(Java版&基岩版) 的从快照版到正式版的绝大多数更新内容和详细信息。|
| 必应                           | https://bing.com                                             | 我们推荐使用必应搜索引擎检索信息。因为必应收录网站非常及时，且有很完备的高级搜索功能。举个例子，使用带有搜索参数的搜索词「site:minebbs.com launcherx」可以更快地找到LauncherX在MineBBS的发布页面。|

### 自食其力、自给自足

此外，还有一些值得一看的内容，或许在你所有的求知场景中都十分有用。推荐阅读.

* [少数派 - 如何在互联网高效搜索信息？关于搜索引擎的分享与总结](https://sspai.com/post/73134#)
* [提问的智慧(进阶，请从链接所指的地方开始看)](https://lug.ustc.edu.cn/wiki/doc/smart-questions/#%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%8F%E4%B9%89%E4%B8%94%E6%8F%8F%E8%BF%B0%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A0%87%E9%A2%98)

---

---
url: /enUS/projbobcat/authenticators/offline.md
---
# Offline Authentication model

\[\[toc]]

This authentication model implements the most basic authentication function. Typically used for local debugging and authentication.

:::warning

Using this authentication model in the production process may **violate copyright laws or end user agreements** in some countries and regions. For details, see [Mojang End User Agreement](https://www.minecraft.net/en-us/eula)

:::

## Initialize validator

You can initialize the offline validator with the following code:

```c#

var offlineAuthenticator = new OfflineAuthenticator
{
    LauncherAccountParser = launcherAccountParser,
    Username = "[DISPLAY_NAME]"
};

```

In the above code block, please replace these parameters according to your actual situation:

|          Project           |             Description              |
|:---------------------:|:---------------------------:|
| launcherAccountParser |   For initialization of the launcher account resolver, see [here]()   |
|    \[DISPLAY\_NAME]     | The display name in the game usually consists of English characters, symbols and numbers.  |

:::tip

For the initialization of **launcherAccountParser** (game profile parser), please refer to the [Game Profile Parser](/enUS/projbobcat/additionalParsers/gameProfileParser) page

:::

## Get authentication results

After you complete the authentication of the authentication model, you only need to call the authentication method of the offline verifier to complete the account authentication.

In an asynchronous context, use **AuthTaskAsync** to finish authentication:

```c#

var authResult = await offlineAuthenticator.AuthTaskAsync(false);

```

In a sync context, use **Auth** to finish authentication:

```c#

var authResult = offlineAuthenticator.Auth();

```

## Interpret authentication results

After the authentication method is completed, the authentication model will return the authentication result, which is of type [AuthResultBase](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/Auth/AuthResultBase.cs) object.
All authentication results contain an enumeration value **AuthStatus**, which directly indicates the success or failure of the authentication result.
Below you can see an interpretation of the authentication results:

### Failed authentication result

By judging whether **Error** is empty, you can easily judge whether the authentication results returned by the authentication model are valid.
The **Error** object will contain the following fields to tell you some details:

| Field | Description |
|:-----------------:|:----------------:|
| authResult.Error.Cause | The specific cause of the problem |
| authResult.Error.Error | error name |
| authResult.Error.ErrorMessage | Details of the error, possibly including a solution |

### Successful authentication result

If the **Error** field in the authentication result is empty, it means that the authentication is valid. A successful authentication result will contain the following information:

| Field | Description |
|:---------------------------------:|:--------------------------------------------:|
| authResult.Id | The unique identifier of the username, ProjBobcat uses a specific generation method to generate this identifier |
| authResult.AccessToken | The authorization credentials of the user account, which has no meaning for the offline authentication model |
| authResult.User.UUID | The UUID of this user, similar to **authResult.Id** |
| authResult.User.Properties | The user's property array. For the offline authentication model, this array contains only one valid value |

---

---
url: /enUS/projbobcat/installers/optifine.md
---
# Optifine Installer

\[\[toc]]

::: tip

Please note that ProjBobcat only implements the Optifine automated installation process. You still need to implement the search, download, and save process of the Optifine installation package yourself.

:::

## Resources

* [BMCLAPI Development Documentation](https://bmclapidoc.bangbang93.com/)

## Get Optifine Download Version Model

Because ProjBobcat's Optifine installer requires you to provide download information from Optifine when initializing the installer.
Therefore, we will briefly describe here how to obtain this information based on a given Minecraft version.

::: info

In this example, we'll be using Minecraft version 1.19.2 to show you how to get it.

:::

::: warning

Since Optifine officially does not provide public API documentation. Therefore, in this process, we need to use a third-party mirror source to complete data acquisition.
Here, we use [BMCLAPI](https://bmclapidoc.bangbang93.com/) to obtain relevant version information.

:::

First, you need to send an **HTTP GET** request to [https://bmclapi2.bangbang93.com/optifine/\[MC\_VERSION\]](https://bmclapi2.bangbang93.com/optifine/1.19.2).
Replace `[MC_VERSION]` with the MineCraft version you want to install. Here we will use version 1.19.2.

You will see something similar to the following returned:

```json

[
  {
    "_id": "6307b8a38a3998ab475d139d",
    "mcversion": "1.19.2",
    "patch": "H9",
    "type": "HD_U",
    "__v": 0,
    "filename": "OptiFine_1.19.2_HD_U_H9.jar",
    "forge": "Forge 43.1.1"
  },
  {...},
  {...}
]

```

BMCLAPI will return a JSON array, and each element in the array is the Download Version Model we need.

#### Convert JSON return to ProjBobcat type

If you are using [JSON.NET](https://www.newtonsoft.com/json)(Newtonsoft.JSON) in your project.
You can use code similar to the following to convert the server response you get into the corresponding ProjBobcat type:

```c#

// Requesting data from BMCLAPI (example, not actual code)
...
var responseJson = await res.Content.ReadAsStringAsync();

// Convert JSON response to ProjBobcat type // [!code focus]
var versions = JsonConvert.DeserializeObject<List<OptifineDownloadVersionModel>>(responseJson); // [!code focus]

// Get the version the user wants to install (example, not actual code)
var userSelect = vm.SelectedIndex;

// Get a single Download Version Model // [!code focus]
var selectedVersion = versions[userSelect]; // [!code focus]

```

Here, **selectedVersion** is the `OptifineDownloadVersionModel` required by the Optifine installer.

## Initialize the installer

The way to initialize the Optifine installer is very simple.
You first need to prepare the Optifine installation package .jar file. and a Java runtime available.
You need to initialize the installer using the `selectedVersion` obtained in the previous step:

```c#

var optifineInstaller = new OptifineInstaller
{
    JavaExecutablePath = "[PATH_TO_YOUR_JAVA_RUNTIME]",
    OptifineDownloadVersion = selectedVersion,
    OptifineJarPath = "[PATH_TO_YOUR_OPTIFINE_JAR]",
    RootPath = "[GAME_ROOT_PATH]",
    CustomId = "[CUSTOM_INSTALL_GAME_ID]",
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
};

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:----------------------------------------:|:------------------------------------------------:|
| \[GAME\_ROOT\_PATH] | The game root directory, usually the path to the .minecraft folder |
| \[CUSTOM\_INSTALL\_GAME\_ID] | Optional, customize the name of the game to be installed |
| \[MC\_VERSION\_OR\_GAME\_ID] | The MineCraft original game version inherited by Forge, usually the game version. For example: 1.19.2 |
| \[VERSION\_LOCATOR\_INST] | Game version locator instance, that is, the **VersionLocator** attribute when initializing the game core |
| \[PATH\_TO\_YOUR\_OPTIFINE\_JAR] | The path where the Optifine installation package is located |
| \[PATH\_TO\_YOUR\_JAVA\_RUNTIME] | The path where Java (javaw.exe) runtime is located |

## start installation

After you complete the initialization of the installer, you only need to call the installation method of the Optifine installer to complete the installation.

In an asynchronous context, use **InstallTaskAsync** to complete the installation:

```c#

await optifineInstaller.InstallTaskAsync();

```

In a sync context, use **Install** to complete the installation:

```c#

optifineInstaller.Install();

```

## Report installation progress

In some cases, the Optifine installer may take several minutes to complete the installation.
Therefore, you may need to report the current progress of the installer to the user in real time.
For this purpose, the Optifine installer provides the **StageChangedEventDelegate** event to help you implement task reporting.
You simply need to register for the following event **before starting the installation**:

```c#

optifineInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

Among them, **args.Progress** indicates the current percentage progress of the installer. **args.CurrentStage** is a text description of the current progress of the installer.

---

---
url: /ruRU/projbobcat/installers/optifine.md
---
# Optifine 安装器

\[\[toc]]

::: tip

请注意, ProjBobcat 仅实现了 Optifine 自动化安装流程, 您仍然需要自己实现 Optifine 安装包的搜索、下载、保存流程.

:::

## 实用资源

* [BMCLAPI 开发文档](https://bmclapidoc.bangbang93.com/)

## 获取 Optifine Download Version Model

由于 ProjBobcat 的 LiteLoader 安装器要求您在初始化安装器时提供来自 LiteLoader 的下载信息.
因此, 我们将在这里简要描述如何根据指定的 MineCraft 版本来获取该信息.

::: info

在该示例中, 我们将使用 MineCraft 1.19.2 来向您展示如何获取.

:::

::: warning

由于 Optifine 官方没有提供公开的 API 文档. 因此, 在本流程中, 我们需要使用第三方的镜像源来完成数据的获取.
在这里, 我们使用 [BMCLAPI](https://bmclapidoc.bangbang93.com/) 来获取相关的版本信息.

:::

首先, 您需要向 [https://bmclapi2.bangbang93.com/optifine/\[MC\_VERSION\]](https://bmclapi2.bangbang93.com/optifine/1.19.2) 发送一个 **HTTP GET** 请求.
将 `[MC_VERSION]` 替换为您想要安装的 MineCraft 版本. 在这里, 我们将使用 1.19.2.

您将看到类似下面的返回内容：

```json

[
  {
    "_id": "6307b8a38a3998ab475d139d",
    "mcversion": "1.19.2",
    "patch": "H9",
    "type": "HD_U",
    "__v": 0,
    "filename": "OptiFine_1.19.2_HD_U_H9.jar",
    "forge": "Forge 43.1.1"
  },
  {...},
  {...}
]

```

BMCLAPI 将返回一个 JSON 数组, 数组中的每一个元素即是我们需要的 Download Version Model.

#### 将 JSON 返回转换为 ProjBobcat 类型

如果您在您的项目中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）.
您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型：

```c#

// 从 BMCLAPI 请求数据（示例, 非实际代码）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus]
var versions = JsonConvert.DeserializeObject<List<OptifineDownloadVersionModel>>(responseJson); // [!code focus]

// 获取用户想要安装的版本（示例, 非实际代码）
var userSelect = vm.SelectedIndex;

// 获取单个 Download Version Model // [!code focus]
var selectedVersion = versions[userSelect]; // [!code focus]

```

此处, **selectedVersion** 即是 Optifine 安装器所需要的 `OptifineDownloadVersionModel`.

## 初始化安装器

初始化 Optifine 安装器的方式非常简单.
您首先需要准备好的 Optifine 安装包 .jar 文件. 以及一个可用的 Java 运行时.
您需要使用到在先前步骤中取得的 `selectedVersion` 来初始化安装器：

```c#

var optifineInstaller = new OptifineInstaller
{
    JavaExecutablePath = "[PATH_TO_YOUR_JAVA_RUNTIME]",
    OptifineDownloadVersion = selectedVersion,
    OptifineJarPath = "[PATH_TO_YOUR_OPTIFINE_JAR]",
    RootPath = "[GAME_ROOT_PATH]",
    CustomId = "[CUSTOM_INSTALL_GAME_ID]",
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
};

```

在上述代码块中, 请将这些参数按照您的实际情况替换：

|                  项目                   |                      说明                       |
|:-------------------------------------:|:---------------------------------------------:|
|           \[GAME\_ROOT\_PATH]            |          游戏根目录, 通常为 .minecraft 文件夹的路径          |
|       \[CUSTOM\_INSTALL\_GAME\_ID]        |              可选项, 自定义即将要安装的游戏的名称               |
|        \[MC\_VERSION\_OR\_GAME\_ID]        | Forge 继承的 MineCraft 原版游戏版本, 通常为游戏版本. 例如：1.19.2  |
|        \[VERSION\_LOCATOR\_INST]         |  游戏版本定位器实例, 即初始化游戏核心时的 **VersionLocator** 属性   |
|      \[PATH\_TO\_YOUR\_OPTIFINE\_JAR]      |               Optifine 安装包所在的路径               |
|      \[PATH\_TO\_YOUR\_JAVA\_RUNTIME]      |           Java （javaw.exe） 运行时所在的路径           |

## 开始安装

在您完成安装器的初始化后, 您只需要调用 Optifine 安装器的安装方法来完成安装.

在异步上下文中, 使用 **InstallTaskAsync** 来完成安装：

```c#

await optifineInstaller.InstallTaskAsync();

```

在同步上下文中, 使用 **Install** 来完成安装：

```c#

optifineInstaller.Install();

```

## 报告安装进度

在某些情况下, Optifine 安装器可能会需要数分钟的时间来完成安装.
因此, 您可能需要实时向用户汇报安装器目前的进度.
为此, Optifine 安装器提供了 **StageChangedEventDelegate** 事件来帮助您实现任务汇报.
您只需要简单地在 **开始安装之前** 注册下面的事件：

```c#

optifineInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

其中,  **args.Progress** 指示了安装器当前的百分比进度. **args.CurrentStage** 则是安装器当前进度的文字描述.

---

---
url: /zhCN/projbobcat/installers/optifine.md
---
# Optifine 安装器

\[\[toc]]

::: tip

请注意，ProjBobcat 仅实现了 Optifine 自动化安装流程，您仍然需要自己实现 Optifine 安装包的搜索、下载、保存流程。

:::

## 实用资源

* [BMCLAPI 开发文档](https://bmclapidoc.bangbang93.com/)

## 获取 Optifine Download Version Model

由于 ProjBobcat 的 LiteLoader 安装器要求您在初始化安装器时提供来自 LiteLoader 的下载信息。
因此，我们将在这里简要描述如何根据指定的 MineCraft 版本来获取该信息。

::: info

在该示例中，我们将使用 MineCraft 1.19.2 来向您展示如何获取。

:::

::: warning

由于 Optifine 官方没有提供公开的 API 文档。因此，在本流程中，我们需要使用第三方的镜像源来完成数据的获取。
在这里，我们使用 [BMCLAPI](https://bmclapidoc.bangbang93.com/) 来获取相关的版本信息。

:::

首先，您需要向 [https://bmclapi2.bangbang93.com/optifine/\[MC\_VERSION\]](https://bmclapi2.bangbang93.com/optifine/1.19.2) 发送一个 **HTTP GET** 请求。
将 `[MC_VERSION]` 替换为您想要安装的 MineCraft 版本。在这里，我们将使用 1.19.2。

您将看到类似下面的返回内容：

```json
[
  {
    "_id": "6307b8a38a3998ab475d139d",
    "mcversion": "1.19.2",
    "patch": "H9",
    "type": "HD_U",
    "__v": 0,
    "filename": "OptiFine_1.19.2_HD_U_H9.jar",
    "forge": "Forge 43.1.1"
  },
  {...},
  {...}
]
```

BMCLAPI 将返回一个 JSON 数组，数组中的每一个元素即是我们需要的 Download Version Model。

#### 将 JSON 返回转换为 ProjBobcat 类型

如果您在您的项目中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）。
您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型：

```c#
// 从 BMCLAPI 请求数据（示例，非实际代码）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus]
var versions = JsonConvert.DeserializeObject<List<OptifineDownloadVersionModel>>(responseJson); // [!code focus]

// 获取用户想要安装的版本（示例，非实际代码）
var userSelect = vm.SelectedIndex;

// 获取单个 Download Version Model // [!code focus]
var selectedVersion = versions[userSelect]; // [!code focus]
```

此处，**selectedVersion** 即是 Optifine 安装器所需要的 `OptifineDownloadVersionModel`。

## 初始化安装器

初始化 Optifine 安装器的方式非常简单。
您首先需要准备好的 Optifine 安装包 .jar 文件。以及一个可用的 Java 运行时。
您需要使用到在先前步骤中取得的 `selectedVersion` 来初始化安装器：

```c#
var optifineInstaller = new OptifineInstaller
{
    JavaExecutablePath = "[PATH_TO_YOUR_JAVA_RUNTIME]",
    OptifineDownloadVersion = selectedVersion,
    OptifineJarPath = "[PATH_TO_YOUR_OPTIFINE_JAR]",
    RootPath = "[GAME_ROOT_PATH]",
    CustomId = "[CUSTOM_INSTALL_GAME_ID]",
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|                  项目                   |                      说明                       |
|:-------------------------------------:|:---------------------------------------------:|
|           \[GAME\_ROOT\_PATH]            |          游戏根目录，通常为 .minecraft 文件夹的路径          |
|       \[CUSTOM\_INSTALL\_GAME\_ID]        |              可选项，自定义即将要安装的游戏的名称               |
|        \[MC\_VERSION\_OR\_GAME\_ID]        | Forge 继承的 MineCraft 原版游戏版本，通常为游戏版本。例如：1.19.2  |
|        \[VERSION\_LOCATOR\_INST]         |  游戏版本定位器实例，即初始化游戏核心时的 **VersionLocator** 属性   |
|      \[PATH\_TO\_YOUR\_OPTIFINE\_JAR]      |               Optifine 安装包所在的路径               |
|      \[PATH\_TO\_YOUR\_JAVA\_RUNTIME]      |           Java （javaw.exe） 运行时所在的路径           |

## 开始安装

在您完成安装器的初始化后，您只需要调用 Optifine 安装器的安装方法来完成安装。

在异步上下文中，使用 **InstallTaskAsync** 来完成安装：

```c#
await optifineInstaller.InstallTaskAsync();
```

在同步上下文中，使用 **Install** 来完成安装：

```c#
optifineInstaller.Install();
```

## 报告安装进度

在某些情况下，Optifine 安装器可能会需要数分钟的时间来完成安装。
因此，您可能需要实时向用户汇报安装器目前的进度。
为此，Optifine 安装器提供了 **StageChangedEventDelegate** 事件来帮助您实现任务汇报。
您只需要简单地在 **开始安装之前** 注册下面的事件：

```c#
optifineInstaller.StageChangedEventDelegate += (_,  args) => {
    ReportProgress(args.Progress,  args.CurrentStage);
};
```

其中， **args.Progress** 指示了安装器当前的百分比进度。**args.CurrentStage** 则是安装器当前进度的文字描述。

---

---
url: /zhTW/projbobcat/installers/optifine.md
---
# Optifine 安裝器

\[\[toc]]

::: tip

請注意, ProjBobcat 僅實現了 Optifine 自動化安裝流程, 您仍然需要自己實現 Optifine 安裝包的搜尋、下載、儲存流程.

:::

## 實用資源

* [BMCLAPI 開發文件](https://bmclapidoc.bangbang93.com/)

## 獲取 Optifine Download Version Model

由於 ProjBobcat 的 LiteLoader 安裝器要求您在初始化安裝器時提供來自 LiteLoader 的下載資訊.
因此, 我們將在這裡簡要描述如何根據指定的 MineCraft 版本來獲取該資訊.

::: info

在該示例中, 我們將使用 MineCraft 1.19.2 來向您展示如何獲取.

:::

::: warning

由於 Optifine 官方沒有提供公開的 API 文件. 因此, 在本流程中, 我們需要使用第三方的映象源來完成資料的獲取.
在這裡, 我們使用 [BMCLAPI](https://bmclapidoc.bangbang93.com/) 來獲取相關的版本資訊.

:::

首先, 您需要向 [https://bmclapi2.bangbang93.com/optifine/\[MC\_VERSION\]](https://bmclapi2.bangbang93.com/optifine/1.19.2) 傳送一個 **HTTP GET** 請求.
將 `[MC_VERSION]` 替換為您想要安裝的 MineCraft 版本. 在這裡, 我們將使用 1.19.2.

您將看到類似下面的返回內容：

```json

[
  {
    "_id": "6307b8a38a3998ab475d139d",
    "mcversion": "1.19.2",
    "patch": "H9",
    "type": "HD_U",
    "__v": 0,
    "filename": "OptiFine_1.19.2_HD_U_H9.jar",
    "forge": "Forge 43.1.1"
  },
  {...},
  {...}
]

```

BMCLAPI 將返回一個 JSON 陣列, 陣列中的每一個元素即是我們需要的 Download Version Model.

#### 將 JSON 返回轉換為 ProjBobcat 型別

如果您在您的專案中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）.
您可以使用類似下面的程式碼來將您獲取到的伺服器響應轉換為對應的 ProjBobcat 型別：

```c#

// 從 BMCLAPI 請求資料（示例, 非實際程式碼）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 將 JSON 響應轉換為 ProjBobcat 型別 // [!code focus]
var versions = JsonConvert.DeserializeObject<List<OptifineDownloadVersionModel>>(responseJson); // [!code focus]

// 獲取使用者想要安裝的版本（示例, 非實際程式碼）
var userSelect = vm.SelectedIndex;

// 獲取單個 Download Version Model // [!code focus]
var selectedVersion = versions[userSelect]; // [!code focus]

```

此處, **selectedVersion** 即是 Optifine 安裝器所需要的 `OptifineDownloadVersionModel`.

## 初始化安裝器

初始化 Optifine 安裝器的方式非常簡單.
您首先需要準備好的 Optifine 安裝包 .jar 檔案. 以及一個可用的 Java 執行時.
您需要使用到在先前步驟中取得的 `selectedVersion` 來初始化安裝器：

```c#

var optifineInstaller = new OptifineInstaller
{
    JavaExecutablePath = "[PATH_TO_YOUR_JAVA_RUNTIME]",
    OptifineDownloadVersion = selectedVersion,
    OptifineJarPath = "[PATH_TO_YOUR_OPTIFINE_JAR]",
    RootPath = "[GAME_ROOT_PATH]",
    CustomId = "[CUSTOM_INSTALL_GAME_ID]",
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]"
};

```

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|                  專案                   |                      說明                       |
|:-------------------------------------:|:---------------------------------------------:|
|           \[GAME\_ROOT\_PATH]            |          遊戲根目錄, 通常為 .minecraft 資料夾的路徑          |
|       \[CUSTOM\_INSTALL\_GAME\_ID]        |              可選項, 自定義即將要安裝的遊戲的名稱               |
|        \[MC\_VERSION\_OR\_GAME\_ID]        | Forge 繼承的 MineCraft 原版遊戲版本, 通常為遊戲版本. 例如：1.19.2  |
|        \[VERSION\_LOCATOR\_INST]         |  遊戲版本定位器例項, 即初始化遊戲核心時的 **VersionLocator** 屬性   |
|      \[PATH\_TO\_YOUR\_OPTIFINE\_JAR]      |               Optifine 安裝包所在的路徑               |
|      \[PATH\_TO\_YOUR\_JAVA\_RUNTIME]      |           Java （javaw.exe） 執行時所在的路徑           |

## 開始安裝

在您完成安裝器的初始化後, 您只需要呼叫 Optifine 安裝器的安裝方法來完成安裝.

在非同步上下文中, 使用 **InstallTaskAsync** 來完成安裝：

```c#

await optifineInstaller.InstallTaskAsync();

```

在同步上下文中, 使用 **Install** 來完成安裝：

```c#

optifineInstaller.Install();

```

## 報告安裝進度

在某些情況下, Optifine 安裝器可能會需要數分鐘的時間來完成安裝.
因此, 您可能需要實時向用戶彙報安裝器目前的進度.
為此, Optifine 安裝器提供了 **StageChangedEventDelegate** 事件來幫助您實現任務彙報.
您只需要簡單地在 **開始安裝之前** 註冊下面的事件：

```c#

optifineInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

其中,  **args.Progress** 指示了安裝器當前的百分比進度. **args.CurrentStage** 則是安裝器當前進度的文字描述.

---

---
url: /zhCN/lxguide/features/p2p.md
---
# P2P联机

经过三次重构，LauncherX的P2P联机现已就绪\*

::: warning 版本差异

请确保LauncherX版本是在**2025年4月1日**后更新的。此前稳定版的P2P联机组件已被弃用，无法与最新版LauncherX联通。

实质上，联机组件ConnectX在LauncherX稳定版（Stable）实装后仍然处于公开测试状态。如果遇到问题请先参考：[报告异常&建言新策 | 日冕知识库](/zhCN/lxguide/report-issue.html)

:::

\[\[toc]]

## 操作指南

先决条件：必须先登录**日冕账户**。

### 加入或创建房间

1. 打开【设置-多人游戏】

2. 在【操作】部分，点击【连接到服务】

3. 等待连接成功。连接过程可能需要数分钟。
   ::: danger 如果电脑上启用了代理，请将其关闭。

4. 如果您要作为房主，请点击【创建房间】；
   如果您要加入其他人的游戏，点击【加入房间】

5. 房间ID是识别唯一房间的凭据。截至2025年3月15日，分享房间的文本是这样的：

   ```text
   我使用 LauncherX 创建了一个联机房间 [喵喵喵] 快加入我的房间吧！#🐤🥐🐿🦔🧸🥙🍬🐶🐼🥥🐶🐪#如果您无法复制 Emoji 串，可以试试这段 ID [FbQjuf6RMcRG]。您也可以复制整段文本来直接导入！
   ```

   复制此段文本后可以直接在加入房间时【从剪贴板导入】

6. 连接质量和处理速度视您的网络环境而定。*并且，联机并非只有这一种方法。参考：[一起玩吗? 联机游戏指南 | 日冕知识库](/zhCN/mc-starter/play-together.html)*

7. 更多关于此的设置界面信息，参见：[多人游戏 | 日冕知识库](/zhCN/lxguide/settings/item/multi-game.html)

### 游玩

::: tip LauncherX简化了许多操作

相比于其他工具，LauncherX自动完成了诸如端口定位、数据转发等操作，为您提供更省心的使用体验。

:::

#### 房主：

房主创建房间的步骤与[使用内网穿透](/zhCN/mc-starter/play-together.html#_1、将局域网世界暴露到公网) 较为一致。**但是使用LauncherX P2P将节约创建隧道、更改端口号等操作。**

1. 启动游戏。记得和邀请一起游玩的大家声明游戏版本以及使用什么加载器。
2. 进入要游玩的单人世界。点击暂停，然后像[一起玩吗? 联机游戏指南 # 将局域网世界暴露到公网 | 日冕知识库](/zhCN/mc-starter/play-together.html#_1、将局域网世界暴露到公网)所介绍的那样将世界**对局域网开放**
3. LauncherX将自动发现开放的端口和世界。接下来将你的房间分享出去等待其他人加入游戏吧！

#### 加入者：

先决条件：加入了一个联机房间。LauncherX将会把联机世界自动映射到内网，所以Minecraft将会在【多人游戏】中自动发现房主的世界。

1. 启动房主使用的游戏，确保使用一样的游戏版本和Mod加载器与模组。
2. 点击【多人游戏】，等待Minecraft自动发现房主的世界。
3. 当出现文字内容类似如图所示的选项，双击它加入。
   ![](/img/lxguide/features/ui-p2p-game-found.png)
   *也就是说，这个项目中\[ConnectX]开头的即是所加入房间中房主的世界。*

---

---
url: /enUS/projbobcat.md
---
# ProjBobcat Development Documentation

![Hx18lYLKR43WAb2](https://user-images.githubusercontent.com/25716486/172503112-95515b07-52ee-4d1e-868e-b87137c6034e.png)

ProjBobcat is a highly customizable, high-performance, full-featured Minecraft launcher core developed by the Corona development team. Here you can check out the usage tutorials for each major component.

![Alt](https://repobeats.axiom.co/api/embed/d8d56d4c2023d90ea067d5b3ca83ed5da4979289.svg "Repobeats analytics image")

## project address

[GitHub - ProjBobcat](https://github.com/Corona-Studio/ProjBobcat)

---

---
url: /ruRU/projbobcat.md
---
# ProjBobcat 开发文档

![Hx18lYLKR43WAb2](https://user-images.githubusercontent.com/25716486/172503112-95515b07-52ee-4d1e-868e-b87137c6034e.png)

ProjBobcat 是一个由日冕开发组开发的高度自定义、高性能、功能完善的 Minecraft 启动器核心. 在这里您可以查阅到各大组件的使用教程.

![Alt](https://repobeats.axiom.co/api/embed/d8d56d4c2023d90ea067d5b3ca83ed5da4979289.svg "Repobeats analytics image")

## 项目地址

[GitHub - ProjBobcat](https://github.com/Corona-Studio/ProjBobcat)

---

---
url: /zhCN/projbobcat.md
---
# ProjBobcat 开发文档

![Hx18lYLKR43WAb2](https://user-images.githubusercontent.com/25716486/172503112-95515b07-52ee-4d1e-868e-b87137c6034e.png)

ProjBobcat 是一个由日冕开发组开发的高度自定义、高性能、功能完善的 Minecraft 启动器核心。在这里您可以查阅到各大组件的使用教程。

![Alt](https://repobeats.axiom.co/api/embed/d8d56d4c2023d90ea067d5b3ca83ed5da4979289.svg "Repobeats analytics image")

## 项目地址

[GitHub - ProjBobcat](https://github.com/Corona-Studio/ProjBobcat)

---

---
url: /zhTW/projbobcat.md
---
# ProjBobcat 開發文件

![Hx18lYLKR43WAb2](https://user-images.githubusercontent.com/25716486/172503112-95515b07-52ee-4d1e-868e-b87137c6034e.png)

ProjBobcat 是一個由日冕開發組開發的高度自定義、高效能、功能完善的 Minecraft 啟動器核心. 在這裡您可以查閱到各大元件的使用教程.

![Alt](https://repobeats.axiom.co/api/embed/d8d56d4c2023d90ea067d5b3ca83ed5da4979289.svg "Repobeats analytics image")

## 專案地址

[GitHub - ProjBobcat](https://github.com/Corona-Studio/ProjBobcat)

---

---
url: /zhCN/CMFS/servers/project-lappland.md
---
# Project Lappland

Project LappLand（其他地方用“ProjLapp”代称），是一个借助mod和无数脚本和魔改维持的奇特的地外冒险。我们引入一系列轻RPG元素和剧情，引导玩家在地球的遥远殖民地上自由征服。

我们期待有优秀的编剧和RPG技术人员与我们一起共同实现这个世界的构筑。

---

---
url: /zhCN/CMFS/servers/pure.md
---
# Project Pure

这是一个包含一切我们能想象到的原版玩法的群组服务器，接入了包含：生存、小游戏、(非公开)创造 等服务器，以后视情况也将开放：空岛生存、原版创造、原版RPG 等新的子服玩法！此外，我们等待有志向的伙伴来参与共建新的小游戏玩法！（见：）

通过CSKB的目录来展开查看接入Pure群组的子服务器。

---

---
url: /enUS/projbobcat/installers/quilt.md
---
# Quilt 安装器

\[\[toc]]

::: tip

Please note that ProjBobcat only implements the Quilt automated installation process. You still need to implement the search, download, and save process of the Quilt installation package yourself.

:::

::: warning

The Quilt installer is currently in an experimental stage, and the related API and installation process may undergo significant changes.

:::

## Resources

* [Quilt Website](https://quiltmc.org/en/)
* [Quilt Documentation](https://quiltmc.org/en/install/)
* [Quilt Meta API](https://meta.quiltmc.org/)

## Compatibility check

Before you start installing Quilt, you need to query whether the version of MineCraft you are modifying is supported via the Quilt Meta API.

First, you need to send an **HTTP GET** request to <https://meta.quiltmc.org/v3/versions/game>.

You will see something similar to the following returned:

```json

[
  {
    "version": "1.19.3",
    "stable": true
  },
  {
    "version": "1.19.3-rc3",
    "stable": false
  },
  {...},
  {...}
]

```

Here, you need to check whether the game version you are about to install appears in Quilt's official support list.
You need to compare the game version with the `version` field in the JSON object.
\*\*If your game does not appear on the support list, the installation will not continue. \*\*

## Get Quilt Loader Model

Because ProjBobcat's Quilt installer requires you to provide download information from Quilt when initializing the installer.
Therefore, we will briefly describe here how to obtain this information based on a given MineCraft version.

::: info

In this example, we'll be using Minecraft version 1.19.2 to show you how to get it.

:::

First, you need to send an **HTTP GET** request to <https://meta.quiltmc.org/v3/versions/loader>.

You will see something similar to the following returned:

```json

[
  {
    "separator": ".",
    "build": 25,
    "maven": "org.quiltmc:quilt-loader:0.18.1-beta.25",
    "version": "0.18.1-beta.25"
  },
  {...},
  {...}
]

```

Quilt Meta API will return a JSON array, and each element in the array is the Loader Artifact we need.

#### Convert JSON return to ProjBobcat type

If you are using [JSON.NET](https://www.newtonsoft.com/json)(Newtonsoft.JSON) in your project.
You can use code similar to the following to convert the server response you get into the corresponding ProjBobcat type:

```c#

// Requesting data from the Quilt Meta API (example, not actual code)
...
var responseJson = await res.Content.ReadAsStringAsync();

// Convert JSON response to ProjBobcat type // [!code focus]
var artifacts = JsonConvert.DeserializeObject<List<QuiltLoaderModel>>(responseJson); // [!code focus]

// Get the version the user wants to install (example, not actual code)
var userSelect = vm.SelectedArtifactIndex;

// Get a single Loader Artifact // [!code focus]
var selectedArtifact = artifacts[userSelect]; // [!code focus]

```

This **selectedArtifact** is the `QuiltLoaderModel` required by the Fabric installer.

## Initialize the installer

Initializing the Quilt installer is very simple. You need to use the `selectedArtifact` obtained in the previous step to initialize the installer:

```c#

var quiltInstaller = new QuiltInstaller
{
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]",
    RootPath = "[GAME_ROOT_PATH]",
    CustomId = "[CUSTOM_INSTALL_GAME_ID]",
    LoaderArtifact = selectedArtifact
};

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:----------------------------------:|:-----------------------------------------:|
| \[GAME\_ROOT\_PATH] | The game root directory, usually the path to the .minecraft folder |
| \[CUSTOM\_INSTALL\_GAME\_ID] | Optional, customize the name of the game to be installed |
| \[MC\_VERSION\_OR\_GAME\_ID] | The Minecraft original game version inherited by Forge, usually the game version. For example: 1.19.2 |

## start installation

After you complete the initialization of the installer, you only need to call the installation method of the Fabric installer to complete the installation.

In an asynchronous context, use **InstallTaskAsync** to complete the installation:

```c#

await quiltInstaller.InstallTaskAsync();

```

In a sync context, use **Install** to complete the installation:

```c#

quiltInstaller.Install();

```

## Report installation progress

In some cases, the Quilt installer may take several minutes to complete the installation.
Therefore, you may need to report the current progress of the installer to the user in real time.
For this purpose, the Quilt installer provides the **StageChangedEventDelegate** event to help you implement task reporting.
You simply need to register for the following event **before starting the installation**:

```c#

quiltInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

Among them, **args.Progress** indicates the current percentage progress of the installer. **args.CurrentStage** is a text description of the current progress of the installer.

---

---
url: /ruRU/projbobcat/installers/quilt.md
---
# Quilt 安装器

\[\[toc]]

::: tip

请注意, ProjBobcat 仅实现了 Quilt 自动化安装流程, 您仍然需要自己实现 Quilt 安装包的搜索、下载、保存流程.

:::

::: warning

Quilt 安装器目前处于试验阶段, 相关的 API 以及安装流程可能会出现较大幅度的变更.

:::

## 实用资源

* [Quilt 官方网站](https://quiltmc.org/en/)
* [Quilt 安装指南](https://quiltmc.org/en/install/)
* [Quilt Meta API](https://meta.quiltmc.org/)

## 兼容性检查

在开始安装 Quilt 之前, 您需要通过 Quilt Meta API 来查询您将要修改的 MineCraft 版本是否受支持.

首先, 您需要向 <https://meta.quiltmc.org/v3/versions/game> 发送一个 **HTTP GET** 请求.

您将看到类似下面的返回内容：

```json

[
  {
    "version": "1.19.3",
    "stable": true
  },
  {
    "version": "1.19.3-rc3",
    "stable": false
  },
  {...},
  {...}
]

```

在这里, 您需要检查您即将要安装的游戏版本是否出现在 Quilt 官方的支持列表当中.
您需要将游戏版本与 JSON 对象中的 `version` 字段作比较.
\*\*如果您的游戏没有出现在支持列表当中, 安装将无法继续. \*\*

## 获取 Quilt Loader Model

由于 ProjBobcat 的 Quilt 安装器要求您在初始化安装器时提供来自 Quilt 的下载信息.
因此, 我们将在这里简要描述如何根据指定的 MineCraft 版本来获取该信息.

::: info

在该示例中, 我们将使用 MineCraft 1.19.2 来向您展示如何获取.

:::

首先, 您需要向 <https://meta.quiltmc.org/v3/versions/loader> 发送一个 **HTTP GET** 请求.

您将看到类似下面的返回内容：

```json

[
  {
    "separator": ".",
    "build": 25,
    "maven": "org.quiltmc:quilt-loader:0.18.1-beta.25",
    "version": "0.18.1-beta.25"
  },
  {...},
  {...}
]

```

Quilt Meta API 将返回一个 JSON 数组, 数组中的每一个元素即是我们需要的 Loader Artifact.

#### 将 JSON 返回转换为 ProjBobcat 类型

如果您在您的项目中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）.
您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型：

```c#

// 从 Quilt Meta API 请求数据（示例, 非实际代码）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus]
var artifacts = JsonConvert.DeserializeObject<List<QuiltLoaderModel>>(responseJson); // [!code focus]

// 获取用户想要安装的版本（示例, 非实际代码）
var userSelect = vm.SelectedArtifactIndex;

// 获取单个 Loader Artifact // [!code focus]
var selectedArtifact = artifacts[userSelect]; // [!code focus]

```

此处, **selectedArtifact** 即是 Fabric 安装器所需要的 `QuiltLoaderModel`.

## 初始化安装器

初始化 Quilt 安装器的方式非常简单. 您需要使用到在先前步骤中取得的 `selectedArtifact` 来初始化安装器：

```c#

var quiltInstaller = new QuiltInstaller
{
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]",
    RootPath = "[GAME_ROOT_PATH]",
    CustomId = "[CUSTOM_INSTALL_GAME_ID]",
    LoaderArtifact = selectedArtifact
};

```

在上述代码块中, 请将这些参数按照您的实际情况替换：

|                 项目                  |                      说明                       |
|:-----------------------------------:|:---------------------------------------------:|
|          \[GAME\_ROOT\_PATH]           |          游戏根目录, 通常为 .minecraft 文件夹的路径          |
|      \[CUSTOM\_INSTALL\_GAME\_ID]       |              可选项, 自定义即将要安装的游戏的名称               |
|       \[MC\_VERSION\_OR\_GAME\_ID]       | Forge 继承的 MineCraft 原版游戏版本, 通常为游戏版本. 例如：1.19.2  |

## 开始安装

在您完成安装器的初始化后, 您只需要调用 Fabric 安装器的安装方法来完成安装.

在异步上下文中, 使用 **InstallTaskAsync** 来完成安装：

```c#

await quiltInstaller.InstallTaskAsync();

```

在同步上下文中, 使用 **Install** 来完成安装：

```c#

quiltInstaller.Install();

```

## 报告安装进度

在某些情况下, Quilt 安装器可能会需要数分钟的时间来完成安装.
因此, 您可能需要实时向用户汇报安装器目前的进度.
为此, Quilt 安装器提供了 **StageChangedEventDelegate** 事件来帮助您实现任务汇报.
您只需要简单地在 **开始安装之前** 注册下面的事件：

```c#

quiltInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

其中,  **args.Progress** 指示了安装器当前的百分比进度. **args.CurrentStage** 则是安装器当前进度的文字描述.

---

---
url: /zhCN/projbobcat/installers/quilt.md
---
# Quilt 安装器

\[\[toc]]

::: tip

请注意，ProjBobcat 仅实现了 Quilt 自动化安装流程，您仍然需要自己实现 Quilt 安装包的搜索、下载、保存流程。

:::

::: warning

Quilt 安装器目前处于试验阶段，相关的 API 以及安装流程可能会出现较大幅度的变更。

:::

## 实用资源

* [Quilt 官方网站](https://quiltmc.org/en/)
* [Quilt 安装指南](https://quiltmc.org/en/install/)
* [Quilt Meta API](https://meta.quiltmc.org/)

## 兼容性检查

在开始安装 Quilt 之前，您需要通过 Quilt Meta API 来查询您将要修改的 MineCraft 版本是否受支持。

首先，您需要向 <https://meta.quiltmc.org/v3/versions/game> 发送一个 **HTTP GET** 请求。

您将看到类似下面的返回内容：

```json
[
  {
    "version": "1.19.3",
    "stable": true
  },
  {
    "version": "1.19.3-rc3",
    "stable": false
  },
  {...},
  {...}
]
```

在这里，您需要检查您即将要安装的游戏版本是否出现在 Quilt 官方的支持列表当中。
您需要将游戏版本与 JSON 对象中的 `version` 字段作比较。
**如果您的游戏没有出现在支持列表当中，安装将无法继续。**

## 获取 Quilt Loader Model

由于 ProjBobcat 的 Quilt 安装器要求您在初始化安装器时提供来自 Quilt 的下载信息。
因此，我们将在这里简要描述如何根据指定的 MineCraft 版本来获取该信息。

::: info

在该示例中，我们将使用 MineCraft 1.19.2 来向您展示如何获取。

:::

首先，您需要向 <https://meta.quiltmc.org/v3/versions/loader> 发送一个 **HTTP GET** 请求。

您将看到类似下面的返回内容：

```json
[
  {
    "separator": ".",
    "build": 25,
    "maven": "org.quiltmc:quilt-loader:0.18.1-beta.25",
    "version": "0.18.1-beta.25"
  },
  {...},
  {...}
]
```

Quilt Meta API 将返回一个 JSON 数组，数组中的每一个元素即是我们需要的 Loader Artifact。

#### 将 JSON 返回转换为 ProjBobcat 类型

如果您在您的项目中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）。
您可以使用类似下面的代码来将您获取到的服务器响应转换为对应的 ProjBobcat 类型：

```c#
// 从 Quilt Meta API 请求数据（示例，非实际代码）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 将 JSON 响应转换为 ProjBobcat 类型 // [!code focus]
var artifacts = JsonConvert.DeserializeObject<List<QuiltLoaderModel>>(responseJson); // [!code focus]

// 获取用户想要安装的版本（示例，非实际代码）
var userSelect = vm.SelectedArtifactIndex;

// 获取单个 Loader Artifact // [!code focus]
var selectedArtifact = artifacts[userSelect]; // [!code focus]
```

此处，**selectedArtifact** 即是 Fabric 安装器所需要的 `QuiltLoaderModel`。

## 初始化安装器

初始化 Quilt 安装器的方式非常简单。您需要使用到在先前步骤中取得的 `selectedArtifact` 来初始化安装器：

```c#
var quiltInstaller = new QuiltInstaller
{
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]",
    RootPath = "[GAME_ROOT_PATH]",
    CustomId = "[CUSTOM_INSTALL_GAME_ID]",
    LoaderArtifact = selectedArtifact
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|                 项目                  |                      说明                       |
|:-----------------------------------:|:---------------------------------------------:|
|          \[GAME\_ROOT\_PATH]           |          游戏根目录，通常为 .minecraft 文件夹的路径          |
|      \[CUSTOM\_INSTALL\_GAME\_ID]       |              可选项，自定义即将要安装的游戏的名称               |
|       \[MC\_VERSION\_OR\_GAME\_ID]       | Forge 继承的 MineCraft 原版游戏版本，通常为游戏版本。例如：1.19.2  |

## 开始安装

在您完成安装器的初始化后，您只需要调用 Fabric 安装器的安装方法来完成安装。

在异步上下文中，使用 **InstallTaskAsync** 来完成安装：

```c#
await quiltInstaller.InstallTaskAsync();
```

在同步上下文中，使用 **Install** 来完成安装：

```c#
quiltInstaller.Install();
```

## 报告安装进度

在某些情况下，Quilt 安装器可能会需要数分钟的时间来完成安装。
因此，您可能需要实时向用户汇报安装器目前的进度。
为此，Quilt 安装器提供了 **StageChangedEventDelegate** 事件来帮助您实现任务汇报。
您只需要简单地在 **开始安装之前** 注册下面的事件：

```c#
quiltInstaller.StageChangedEventDelegate += (_,  args) => {
    ReportProgress(args.Progress,  args.CurrentStage);
};
```

其中， **args.Progress** 指示了安装器当前的百分比进度。**args.CurrentStage** 则是安装器当前进度的文字描述。

---

---
url: /zhTW/projbobcat/installers/quilt.md
---
# Quilt 安裝器

\[\[toc]]

::: tip

請注意, ProjBobcat 僅實現了 Quilt 自動化安裝流程, 您仍然需要自己實現 Quilt 安裝包的搜尋、下載、儲存流程.

:::

::: warning

Quilt 安裝器目前處於試驗階段, 相關的 API 以及安裝流程可能會出現較大幅度的變更.

:::

## 實用資源

* [Quilt 官方網站](https://quiltmc.org/en/)
* [Quilt 安裝指南](https://quiltmc.org/en/install/)
* [Quilt Meta API](https://meta.quiltmc.org/)

## 相容性檢查

在開始安裝 Quilt 之前, 您需要透過 Quilt Meta API 來查詢您將要修改的 MineCraft 版本是否受支援.

首先, 您需要向 <https://meta.quiltmc.org/v3/versions/game> 傳送一個 **HTTP GET** 請求.

您將看到類似下面的返回內容：

```json

[
  {
    "version": "1.19.3",
    "stable": true
  },
  {
    "version": "1.19.3-rc3",
    "stable": false
  },
  {...},
  {...}
]

```

在這裡, 您需要檢查您即將要安裝的遊戲版本是否出現在 Quilt 官方的支援列表當中.
您需要將遊戲版本與 JSON 物件中的 `version` 欄位作比較.
\*\*如果您的遊戲沒有出現在支援列表當中, 安裝將無法繼續. \*\*

## 獲取 Quilt Loader Model

由於 ProjBobcat 的 Quilt 安裝器要求您在初始化安裝器時提供來自 Quilt 的下載資訊.
因此, 我們將在這裡簡要描述如何根據指定的 MineCraft 版本來獲取該資訊.

::: info

在該示例中, 我們將使用 MineCraft 1.19.2 來向您展示如何獲取.

:::

首先, 您需要向 <https://meta.quiltmc.org/v3/versions/loader> 傳送一個 **HTTP GET** 請求.

您將看到類似下面的返回內容：

```json

[
  {
    "separator": ".",
    "build": 25,
    "maven": "org.quiltmc:quilt-loader:0.18.1-beta.25",
    "version": "0.18.1-beta.25"
  },
  {...},
  {...}
]

```

Quilt Meta API 將返回一個 JSON 陣列, 陣列中的每一個元素即是我們需要的 Loader Artifact.

#### 將 JSON 返回轉換為 ProjBobcat 型別

如果您在您的專案中使用 [JSON.NET](https://www.newtonsoft.com/json)（Newtonsoft.JSON）.
您可以使用類似下面的程式碼來將您獲取到的伺服器響應轉換為對應的 ProjBobcat 型別：

```c#

// 從 Quilt Meta API 請求資料（示例, 非實際程式碼）
...
var responseJson = await res.Content.ReadAsStringAsync();

// 將 JSON 響應轉換為 ProjBobcat 型別 // [!code focus]
var artifacts = JsonConvert.DeserializeObject<List<QuiltLoaderModel>>(responseJson); // [!code focus]

// 獲取使用者想要安裝的版本（示例, 非實際程式碼）
var userSelect = vm.SelectedArtifactIndex;

// 獲取單個 Loader Artifact // [!code focus]
var selectedArtifact = artifacts[userSelect]; // [!code focus]

```

此處, **selectedArtifact** 即是 Fabric 安裝器所需要的 `QuiltLoaderModel`.

## 初始化安裝器

初始化 Quilt 安裝器的方式非常簡單. 您需要使用到在先前步驟中取得的 `selectedArtifact` 來初始化安裝器：

```c#

var quiltInstaller = new QuiltInstaller
{
    InheritsFrom = "[MC_VERSION_OR_GAME_ID]",
    RootPath = "[GAME_ROOT_PATH]",
    CustomId = "[CUSTOM_INSTALL_GAME_ID]",
    LoaderArtifact = selectedArtifact
};

```

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|                 專案                  |                      說明                       |
|:-----------------------------------:|:---------------------------------------------:|
|          \[GAME\_ROOT\_PATH]           |          遊戲根目錄, 通常為 .minecraft 資料夾的路徑          |
|      \[CUSTOM\_INSTALL\_GAME\_ID]       |              可選項, 自定義即將要安裝的遊戲的名稱               |
|       \[MC\_VERSION\_OR\_GAME\_ID]       | Forge 繼承的 MineCraft 原版遊戲版本, 通常為遊戲版本. 例如：1.19.2  |

## 開始安裝

在您完成安裝器的初始化後, 您只需要呼叫 Fabric 安裝器的安裝方法來完成安裝.

在非同步上下文中, 使用 **InstallTaskAsync** 來完成安裝：

```c#

await quiltInstaller.InstallTaskAsync();

```

在同步上下文中, 使用 **Install** 來完成安裝：

```c#

quiltInstaller.Install();

```

## 報告安裝進度

在某些情況下, Quilt 安裝器可能會需要數分鐘的時間來完成安裝.
因此, 您可能需要實時向用戶彙報安裝器目前的進度.
為此, Quilt 安裝器提供了 **StageChangedEventDelegate** 事件來幫助您實現任務彙報.
您只需要簡單地在 **開始安裝之前** 註冊下面的事件：

```c#

quiltInstaller.StageChangedEventDelegate += (_, args) => {
    ReportProgress(args.Progress, args.CurrentStage);
};

```

其中,  **args.Progress** 指示了安裝器當前的百分比進度. **args.CurrentStage** 則是安裝器當前進度的文字描述.

---

---
url: /enUS/projbobcat/resourceCompleter.md
---
# Resource completer

In ProjBobcat, we provide developers with a completer for completing Minecraft core resource files.
These resources include: game audio, materials, textures, language files, library files necessary for startup, etc.

---

---
url: /enUS/projbobcat/resourceCompleter/resourceInfoResolver.md
---
# Resource information resolver

In ProjBobcat, we use **ResourceInfoResolver** (ResourceInfoResolver)
to help the resource completer identify missing files in MineCraft.

The following table shows the resource resolvers currently supported by ProjBobcat:

| Class name | Introduction |
|:--------------------------:|:----------------------------------:|
| AssetInfoResolver | Used to parse the assets required by the game (audio, language, fonts, textures, etc.) |
| GameLoggingInfoResolver | Used to parse the log4j log formatting component officially provided by MineCraft |
| LibraryInfoResolver | Used to parse library files necessary for game startup |
| VersionInfoResolver | Used to parse JAR files provided in game JSON |

---

---
url: /zhCN/skript.md
---
# Skript脚本语言入门指南: 准备工作

:::tip 本文将指引您构建一个编写和调试Skript的环境.

:::

\[\[toc]]

## 介绍

### 关于Skript

Skript(简称sk)：作为一种十分接近英语这一自然语言的脚本语言，一定程度上降低了服主们发挥创意的门槛。而总还是有的：首先你要对你的英语水平很有自信——能看懂文档的范例即可；其次就是在逻辑上能够理解之——作为脚本语言，并不是能用交际英语就可以解决一切问题；也不是Siri，和它描述需求它就能为你实现（Siri也不能）。所以，要想在Sk的世界随心徜徉，首先要记住，你如何与sk交流，Skript(的解释器)才能 “听懂” (实际上所有编程语言都是这样)。

与此同时，Minecraft的各个概念（实体、区块、规则之类）还有一些计算机基础知识与名词（string字符串、integer整数之类，不过skript应该说是弱类型语言吧? 有最基本的区分: string对应text，player是玩家类型，number默认是long但是可以直接无感地变成double，很多类型都可以通过parse as语法进行转换。）也是必不可少的，但是由于其容易通过搜索引擎了解，故不在此赘述。

### 安装

首先需要一个基于Bukkit的Minecraft服务端，并且已经初始化。然后前往[SkriptLang Github Release](https://github.com/SkriptLang/Skript/releases)下载最新版Skript插件构建，将下载好的.jar文件放置在`~<server_root>/plugins/`下，然后重新启动服务端。在将插件放置在此位置并启动服务端后，Skript将在plugins目录下创建自己的工作目录`skript`。

使用服务端命令`/sk info` 来确认Skript是否已安装，以及版本信息和附属插件版本信息.

### Skript文件

Skript脚本的文件存放在它的**工作目录** 的子文件夹`scripts` 下，内容是纯文本。所有Skript脚本文件它的文件扩展名是`.sk`，手动在文件名的最前方添加符号`-`将会使其内容不被加载(与命令`/sk disable <script_name>.Skript`是同样的效果)

在这个文件夹下新建文本文档并修改扩展名为`.sk`以创建你的第一个Skript脚本文件.

## 搭建调试环境

:::tip 为了更好地编写和调试脚本，建议自行搭建一个独立于运营服务端的环境.

:::

在最开始，请先自行寻找一个地方创建文件夹，命名最好让自己看得懂。以后我们称呼这个文件夹为「Skript 目录」

### 编辑器

我们推荐使用 **Visual Studio Code** 来编写Skript。但是实际上，可以用任意一个文本文件编辑器来编辑Skript脚本。只是根据笔者经验，VSCode是最方便的.

前往[VSCode 下载页面](https://code.visualstudio.com/download) 选择适合自己电脑的版本下载并安装。安装完成后打开VSCode，在左侧找到一个「四个方块」组成的图标 (有点类似 )，鼠标悬浮后若提示「扩展(Extension)」，则点击它。

在它的搜索框内搜索「Skript + SkriptInsight」，选择作者为「NickAc」的项目，点击「安装(Install)」

按需重启VSCode.

找到先前创建的Skript目录，右键点击它，点击“在VSCode打开” (Windows11目前貌似要先点击「显示更多选项」)，现在你的VSCode就已经将 Skript 目录作为一个项目打开了.

点击VSC窗口右上角的「上白下黑」的按钮 (切换面板，图标类似于)，以打开下方命令行面板。这个面板中命令行的起始点即为Skript目录.

### 用于调试脚本的服务端

在Skript 目录中放置一个Bukkit/Spigot/Paper/… 服务端，然后在上文中打开的命令行面板中操作控制台，像正常开服一样将其初始化.

初始化后，为其安装 **兼容的** Skript。

在VSC左侧的竖列图标中，确保选中了从上往下数的第一个图标 (资源管理器)，然后选择到scripts文件夹。使用「新建文件…」按钮(图标类似  但是右下角有个+符号) 在当前选中的目录下创建新文件.

运行服务端命令 `/sk help` 来查看skript帮助。

## 其他

可以创建一个新的脚本然后粘贴以下内容来简化执行`/sk reload scripts` 命令。

```skript
command /skr:
		trigger:
				if sender has permission "admin":
						broadcast "脚本将在3秒内开始重载，可能带来卡顿" # 可选，用于提示其他玩家；如果在专用测试环境中调试，则可删除此行.
						wait 3 second # 配合上一条.
						make sender execute command "/sk reload scripts"
						broadcast "完成重载"
						stop
```

这样就可以使用新注册的命令`/skr`来重载所有脚本了。

---

---
url: /zhCN/skript/startup.md
---
# Skript脚本语言入门指南: 正式开始

:::tip 学习Skript语言需要您有较好的英语基础和敢于尝试的勇气，试一试一般不会有什么坏结果。

:::

\[\[toc]]

## 前提条件

您应该先阅读了「准备工作」章节，然后再阅读下文的进阶内容.

## 按要素入门

按照不同的语义元素进行循序渐进的分类介绍。

### Events 事件

Event(事件) 在符合条件地发生后（譬如，on shoot就是在某一实体发射了一个“projectile（发射物，比如雪球、箭之类的）”的那一瞬间触发。），才会触发脚本中对应的内容。一段脚本必须存在于一个event与表示“这是个event”的冒号之后，大概长这样：

```skript
on shoot:
```

event之前可以有空行，但是不能有空格。Event和以后会讲到的其他注册(方法注册、指令注册等)一样，都是定义了一段脚本开始执行的条件。在event之后，需要换行并打四个空格（或者在编辑器内按下tab键），之后开始写下在这个事件发生后，sk需要执行什么命令。对于Event的后续处理，sk保留了一系列可以直接调用的常/变量，详见SkriptHub文档.

值得注意的是，sk是缩进较为敏感的，类似yaml。缩进敏感这个词比较好从字面理解，就是说，对“一行字符相对输入起始的位置”有着严格要求。稍有不对的地方，都将会引发意外的问题。

(注：和yaml一样，你可以使用#开头的一段话作为注释，提醒你别忘了这段文字是要发挥什么作用的。)

### Condition 条件

这是sk用来判断情况的“条件”，结尾需要输入冒号，并换行，相对于这个condition再进行4个空格的缩进，然后继续输入条件或想要执行的效果（下节会讲）。当然，如果你想一次性写完所有同等级的条件，换行就不必向后缩进了。向后缩进代表着之后的内容是换行前的条件的下级。区别在于：

```skript
on chat:#在玩家发消息时候触发
    if player's tool is a golden sword: # 假如发消息的玩家手持金剑
        broadcast "%sender%在讲话时握紧了手中的金剑"

    if player's tool is a golden shovel: # 假如手持金铲铲
        message "%sender%在讲话时握紧了手中的金拍子"
```

这样子，两条if同级，会在分别满足条件的情况下执行不一样的效果。

而不同级则是 “下一条condition作为上一条的补充，细化对最终执行效果的限制条件”：

如果李华想要 史蒂夫 在 手持 铁剑 砍地 时候 说 “大宝剑！”，可能会说“If you holding an Iron sword，say ‘大宝剑！’.”。倘若需要Sk跨次元地转告史蒂夫呢？

```skript
on click: # 在玩家的点击事件发生时候：
    if player's name is "Steve": # 只有史蒂夫能触发
        if player's tool is a iron sword: # 只有手持铁剑时候触发。
            make player execute command "/say 大宝剑！" # 好吧，终于说出口了！
            
            # 相信你也看到了，我这里使用了“a”而不是语法中对元音前冠词的要求“an”。
            # 实际上二者均可，sk不会像你的英语老师一样负责任地计较这种事情。
            # 对了，使用「#」来标注注释，在这个标记之后同一行的全部文本都是注释的内容，会被解释器忽略.
```

如此相扣，是不是有点麻烦？通过你未来的深入了解，你会发现有些条件是可以同时制约的。那么前面两条介绍的末尾都需要加冒号并换行、第二行都必须要加一层缩进，本示例中最后一行代码表示的是什么？为什么末尾又不加冒号了？

### Effect 效果/执行效果

即，在满足前面限制的条件的情况下，对目标执行什么操作、会造成什么影响。这像是指令一般，让一切锦上添花，真正对游戏中的玩家或世界做出操作。而先前介绍的event、condition，则是“根”和“枝叶”。

在同一段effect或condition中需要执行的effect，必须在缩进上保持一致。换行时不会再需要向后缩进（就是说，不用在已有缩进的基础上继续往后缩进） 且分隔不同的effect只需要换行即可。（对于高级一点的编辑器，比如virtual studio code（简称vsc），在你完成一行effect的编写后换行，是直接与上一句“齐头并进”的。）

:::info 关于缩进规则

类似于Python，Skript实际上接受很多缩进种类，但是要求全篇的缩进都是一致的。比如说，你可以使用Tab，或者使用2个空格，或者4个空格; 但是你不能又用Tab又用空格.

:::

effect可以直接存在于event的下级：

```skript
on command "/hello": # 当执行指令/hello时触发（即使这个指令不存在于你的服务器中）

  cancel event#取消操作/取消事件（取消触发本段脚本的那个事件）

# 也就是说，如果没有这句话且你的服务器没有hello这条命令，服务器会告诉玩家指令不存在。
# 此举旨在制造一种“有这个指令”的假象。
  broadcast "%sender%向诸位问好！"#在前面取消事件之后执行的指令，

# 在全服务器广播“%触发事件的玩家的ID%向诸位问好！”这句话。
# 本例子中使用的缩进是2空格
```

也可以叠在无数层condition之后。就像李华如何跨次元让史蒂夫喊出“大宝剑！”那里的示范一样。

好了，那么那对百分号是什么？

### Placeholder\&Expression 占位符和表达式

一些服主在接触插件时候或许有遇到一个和某网红一点关系都没有的插件：PlaceholderAPI（简称papi）。不过这里的Placeholder在安装附属「skript-placeholders」之前和papi并不互通，但是道理是一样的：占位符。

在一段文本中插入占位符，而一旦读取到占位符所指示的变量后，占位符将被那个变量的内容替代。

比如，我们的李华同学的游戏ID叫Li\_Hua，在papi中要灵活表示玩家的名字时，就应该把占位符写作%player\_name%。而在sk，需要表达为%player%(玩家)或%player's name%(玩家名，稍后的文档我们将探索各种相似的Expression的不同之处)。

你应该看出来了，前面限制“只有史蒂夫能触发”时候也出现了“player's name”，那么这个限制条件除了基于“if”表示“如果”的限制条件，还和这个占位符有什么关系？

很有关系。它们都属于expression（表达），抽象但又不完全抽象。任何表达都可以写到两个百分号之间，组成一个占位符，灵活地表示一段文字。

由此，我们可以写一个比较不好用但至少能用的玩家头衔脚本了！

```skript
on join:#每次玩家加入到服务器世界时候触发
    player's name is "Steve":#这是Steve专用之雅号
        set player's displayname to "<gold><bold>世界之王 <aqua>史蒂夫！"#这是最简单的实现方式。

 # 一段脚本结束，另一端脚本开始。这发生在同一个sk文件中。

on chat:#在聊天时候

    cancel event#把嘴捂住（不让原生的消息显示出来）
    broadcast "%sender's displayname%<r>说 %message% <gray>并仰天长笑。"

 # 把所有玩家发送的消息广播出来，达成目标效果。
```

那么，`<gold>`，`<r>`这些都是什么？

### Text（文本）的美化

Minecraft里会出现各种各样颜色的字。无论是手持颜料右键点击有文本的告示牌，或是在Essentials/EssentialsX（插件，简称ess）和/或papi的帮助下，使用&1\&c\&l之类的代码表示，都会有“被染色”的文字出现。乱码效果、斜体、粗体、鼠标悬浮提示、可以点击执行命令的“文本按钮”等等等等，都可以通过这种<>包围的一段标签代码来达到效果。在这段代码之后、直到新的代码出现之前，效果都会持续。

表示颜色、表示字体效果、表示功能的代码，见官方文档 https://docs.skriptlang.org/text.html

以下是对官方文档的表格摘抄和翻译 (颜色代码查询请访问官方文档):

| 代码(原版) | 名称          | 别名         |
| ---------- | ------------- | ------------ |
| §k         | magic test    | obfuscated   |
| §l         | bold          | b            |
| §m         | strikethrough | strike，s    |
| §n         | underlined    | underline，u |
| §o         | italic        | italics，i   |
| §r         | reset         | r            |

（reset代表重置，即将其之后的显示效果还原为默认状态。）

| 名称            | 别名           | 描述                                                         |
| --------------- | -------------- | ------------------------------------------------------------ |
| link            | open url，url  | Opens a link when player clicks on text                      |
| run command     | command，cmd   | Makes player execute a chat command when they click on text  |
| suggest command | sgt            | Adds a command to chat prompt of player when clicked         |
| tooltip         | show text，ttp | Shows a tooltip when player hovers over text with their mouse |
| font            | f              | Change the font of the text (1.16+)                          |
| insertion       | insert，ins    | Will append a text at player's current cursor in chat input only while holding SHIFT。|

(对于这些交互功能，需要你这样设置标签代码：`<名称:执行的效果（可以是在cmd:后的一段命令）>` 详见示例)

由此，你可以制作一些简单的操作交互了！

```skript
command /spawnpoint: # 回城！（前提是有这样一个主城可以返回）
    trigger:
        if {onev.%player%} is true: # 条件、效果都可以按你希望的顺序出现。把握好执行顺序即可。
            message "你有操作未完成。"

        else: # 只有带if的condition可以有else在同级出现。
            set {onev.%player%} to true # 变量设置为布尔值true，下节会讲到。
            message "<aqua>是<magneta>否<yellow>确<dark red>认<lime>？" # 花花绿绿，实际上影响观感。
            message "<cmd:res tp main><lime>【是】<cmd:canceltip><pink>【否】"
# 点击“【是】”触发里面的命令只在你有residence领地插件且设置了名为main的领地时有效。可以替换为任意命令。
# 在玩家打开聊天并点击“【是】”之后，指令会执行。而“【否】”对应什么命令？

command /canceltip: # 任何取消提示都可以使用这一条。哪怕不在同一个sk文件内。

    if {onev.%player%} is true:
        message "已取消操作。" to the sender # 这个to the sender指向message的发送对象。在触发event的是玩家时可以不写。
        set {onev.%player%} to false#尘埃落定，既然交互结束了，那就设置为完全相反的false吧！

on command "/res tp main":
    set {onev.%player%} to false#有始有终。
    broadcast "%sender's displayname%<r>回城了！"# 告知父老乡亲。而<r>旨在不让有displayname还染了色的玩家不会让后面的文字变色。
    
    # 在本例中，使用了注册指令的方法来实现指令接收。以后我们会探讨各种事件和其他调用脚本的方法.
```

值得一提的是，不要把服务器所有不相干的功能都写在同一个sk文件里。那样不方便管理，也会影响性能。

接下来，把一些东西存下来吧！

### Variables 变量

变量，存储和交换信息的必要「介质」。

**局部变量** ，暂时的变量，即类似{\_actions}的由大括号包括的一段字符，开头必须由`_`符号标记。在当前这一段脚本执行结束后，将会消失。并且在不同段落的脚本之间不可互通，因此也不会形成冲突.

**临时变量** (暂定名称)，需要只在服务器开启期间于内存中存在的变量，使用`-`符号开头.

**全局变量** ，长期的变量，即类似`{actions}`的由大括号包括的一段字符，且开头没有上述符号。永远会在Skript插件于服务端取消注册的时候长期存在于服务器的本地文件里。( 默认在关闭服务器时会保存到Skript的插件文件夹的`variables.csv`中，或者根据数据库设置存储在数据库里。) 并且，全局变量可以跨文件使用。

变量可以包含几个占位符，用于保存不同玩家的不同状态。在Skript v2.6.1之后，Skript会建议你不要以占位符作为变量的开头，而是像`{adv.%player%}`这样，便于区分变量来源或作用、避免同名的变量的冲突。变量可以存储很多东西：纯数字、字符串、玩家（保存玩家名），在sk不能判断你要存的是什么类型的数据时候，只需要在用"set ..。to ..."之后加“parsed as ”和你要存的类型即可完成转换。

变量存在列表存储方式，其格式为: `{[-_]VariableName::Key}`， \[-\_] 代表着列表也可标识为局部变量或临时变量。 列表变量可以扩展为两个Key储存的形式，比如: `{VariableName::Key1::Key2}`，并且Key可以为数字。使用`{VariableName::*}`来代指整个列表。整个列表可以被loop语法遍历.

:::warning 官方建议

在Skript 2.7之后的版本中，官方建议为一个`.sk`文件中的所有全局变量添加固定的前缀以避免跨脚本文件的全局变量出现变量污染，即倘若脚本A包含一个`{variable}`被赋值为1，另外一个脚本B包含一个`{variable}`被赋值为"XPX"，将可能导致难以预测的意外。因此将脚本A中的那个全局变量命名为`{A.variable}`，脚本B中的那个全局变量命名为`{B.variable}`，将能避免这个问题.

但是我们建议，无论使用哪个版本的Skript，都要遵守这个规则。并且，若非是不得不使用全局变量的场合，不要使用全局变量。

:::

需要注意的是，expression和字符串(text，string) 可以视为特殊的变量。前者可能包含可读写的值，会对游戏产生影响; 后者可以通过模版表达式(成对的百分号`%`) 进行插入值 (插入expression或变量).

同时还有一种特殊的expression，它是与玩家紧紧相伴，像一个隐形标签的存储方式：元数据（metadata）—— 与某些路灯挂件喜欢炒作的某宇宙基本没关系。利用元数据，你可以存储各种玩家信息，使用方法与变量很相似。除非服务器重启，否则不会被清空。

而元数据可以帮助我们制作一些需要指向目标的功能 (比如说暂时存储一个状态的信息)。这个方法比较简单，也比较笨拙：

（假设你有安装ess）

```skript
on command "/tpatoplayer":#这种复杂的命令最适合放在服务器菜单里。

    if sender is a player:#sender可能是command block（命令方块）或console（控制台，服务器后台）。你不能指望把命令方块传送走，或者把服务端丢到世界里去。

        cancel event

        set metadata value "going" of sender to true

        message "在聊天框发送你要传送到的玩家的ID，发送~/取消操作。"



on chat:

    if metadata value "going" of sender is true:

        set metadata value "going" of sender to false # 有始有终

        if message is "~/":

            cancel event

            make sender execute command "/canceltip" # 前面提到的万物皆可调用的取消提示信息

        else:#与取消操作的可能的条件同级

            make sender execute command "/tpa %message%" # 拼接为ess的传送指令并执行。对于较高版本的Minecraft，玩家可以在聊天框空着的时候按tab补全来选择目标玩家。然后作为消息发送即可。
```

### Types 类型

skript针对“伤害来源（damage cause）”、“生物群系（biome）”等需要分类的不同事物有着规范化语言的要求。详见官方文档：https://docs.skriptlang.org/classes.html

### 试一试吧！

在保存好你写的脚本后，在后台执行命令 sk reload all（重载所有脚本和配置）sk reload scripts（仅重载所有脚本，别把script拼成skript了）或sk reload <某个脚本文件>（重载某一个脚本）！

不出错的情况下，就可以去看看服务器里面展示的效果了！祝你成功！

## 跋 & 一些好习惯

```txt
这是我（法棍 of 日冕工作室）第一次尝试写教程。写得仓促，但绝对是我一个寒假以来所学的基础的浓缩。因此，会有不少纰漏，希望高人指出。以及我认为，相对简短的文字永远不能表达最准确的事实，所以读完这篇文章，或许需要你带着去实践、去翻阅文档，打好基础，然后迈出下一步：接触各种附属，包括且不限于SkBee、McQQBot、Skript-reflect等。另外，对于新手，我推荐尝试使用官方文档 https://docs.skriptlang.org ， 而 https://skripthub.net/ 包含除了本体之外的诸多附属的使用文档，以及更多示例。（嘛 使用文档！使用说明书啦！）按照文档示例来写，也不要忘记作合理的发散的尝试，这将有助于进步！（2022年2月17日 skript.cn的中文文档尚未就绪，将在不久的将来完成译制！ ）
```

⬆️ 这是本文最开始于2022年写就时候的跋。下文是2024年的跋.

时过境迁，如今我访问skript.cn指向的论坛却发现NXDOMAIN了，貌似很多skript资源都转移到了MineBBS? 但是无论如何，老腊肉想要CSKB成为汇聚Corona Studio相关所有知识的知识库，所以我把我所累不多的大脑中的知识翻了个遍，把这篇文章从我暂时消失的博客的数据库中找出来了，并且准备在CSKB这个平台上继续更新内容.

而一些好习惯呢，就是：

首先，学会听sk的诉求。你的代码、或是来自你一些新奇的尝试，可能并不能被skript理解。这时候你需要先过skript这一关。让skript载入这个脚本，看它如何报错？报错的原因是什么？理解报错原因，回去改正你很确信的错误，然后再试一次。

然后你再试了一次，可能还是不行。或许你这会应该去文档查询用法了：如果有这样的用法，那就找你的拼写错误：可能少了什么符号？可能什么地方打错了？如果没有这种用法，那么请先思考别的解决方案，然后在文档试着搜索别的解决方案的关键词。应该有所收获。甚至最终你可能发现，只是你的skript该更新了而已。skript每次更新迭代，都会带来新的功能，可能一切报错只是因为你使用的这个版本“还听不懂你要说什么”。

最终你或许成功让skript可以理解了。但是理解的对不对，有待你进入服务器的世界一探究竟。甚至可能需要你同时登录几个不同权限组的账户来测试！而且实现的效果也可能不是一蹴而就的——需要你不断地耐心调试。代码执行到哪里出现了问题？在你认为可能的地方插几句broadcast “<一个数字，能区分出问题的地方即可>”，重载，再尝试，逐渐找到问题的根源，解决它！

倘若实在遇到瓶颈，勿忘鼻子下面有大路，不羞于求问！但是也请谨记，在保证礼貌提问虚心请教同时，“没有日志（错误报告、log之类）的问题解决无异于闭眼开车（来自apache官方文档）”，明确表述需求与问题带上错误报告，也很有必要。

还有，对于一些需要重复使用多次且不会出现关于玩家的占位符的代码，可以由指令或者方法触发，在面向客户端操作时，用一段命令要求服务端执行触发指令即可。譬如我写的日历： https://github.com/fr1g/CalendarRealCount 。

最后，愿你能早日自由地实现你所想的新奇玩法! 或者在如此面向过程的友好脚本语言的帮助下，早日参悟属于你的编程方法!

2022年2月17日 06点08分 最早发布于https://bbs.smgoro.top/threads/skript.32/ |

2024年3月22日 转移到CSKB

---

---
url: /enUS/lxguide/startup/perOsSetup/linux.md
---
# Special settings for Linux

\[\[toc]]

## For Linux distributions based on ARM64 architecture

::: warning

Because Mojang has not officially supported ARM64 versions of Linux games.
Therefore, you need to manually download and install the JRE runtime before using LauncherX.

:::

### Download and install the JRE runtime

Here we're gonna use [Azul JDK](https://www.azul.com/downloads/#zulu) to demonstrate JRE installation process.

At [Azul JDK Website](https://www.azul.com/downloads/#zulu) , scroll down a little to see the JDK version filter box:

![azul-website](/assets/azul-website.Bz9-pqV-.png)

At **Operating System**, select **Linux**, and at **Architecture**, select **ARM 64-bit**
to get get all available JDK versions.

Clike the **Download** button on the right-side bar, and select **.tar.gz** formate JDK runtime, and after downloading, extract it to any local folder.
Then select **Add Manually** in LauncherX and select the **java** executable file in the **bin/** directory of the JDK folder.

## If it can't run

You might need to do the following:

* Open a new terminal, or use the one that just appeared
* Enter `export LC_CTYPE=en_US.UTF-8`, and hit enter
* (If necessary, the above steps can be performed with administrator privileges \[sudo])
* Try running again. If that fails, try re-login the system.
* If it fails again, be sure to give us feedback at [LXIT (GitHub)](https://github.com/Corona-Studio/LXIT).

---

---
url: /enUS/lxguide/startup/perOsSetup/macOS.md
---
# Special settings for macOS

For macOS users, if you see a "Corrupted" error pop-up when opening LauncherX, please do the following:

* Open "Terminal.app"
* Open your Finder and find your LauncherX executable (LauncherX.app or LauncherX.Avalonia.app)
* Enter `sudo xattr -d com.apple.quarantine` in the terminal BUT DON'T HIT ENTER YET!
* As long as there is a space at the end of the above command, drag your **LauncherX APP** into the terminal window
* Now hit enter, the terminal will ask you to enter the password of the administrator account. Please enter it according to your feelings since the terminal will not display any input records in the display area.
* After typing the password, press `Enter` on the keyboard to confirm. There will be no prompt if the execution is successful.
* Then try launching LauncherX again, and if it fails again, be sure to give us feedback at [LXIT (GitHub)](https://github.com/Corona-Studio/LXIT).

---

---
url: /enUS/lxguide/startup/perOsSetup/windows.md
---
# Special settings for Windows

Currently, you don't need to do any additional configuration to use the full functionality of the LauncherX launcher.

::: warning

Please note that LauncherX **DOES NOT SUPPORT** operating systems below Windows 7, as well as any version of Windows S and 32-bit Windows systems.

:::

---

---
url: /enUS/lxguide/startup.md
---
# Start

Welcome to LauncherX! We are constantly committed to creating a beautiful and convenient user experience for you.

\[\[toc]]

*Creation date of this article: July 14, 2023, modification date: July 14, 2023, author: Feiron Iguista, Translated by Japerz.*

***

::: info

Due to different devices, you may encounter some minor difficulties when starting up for the first time, and we are very sorry for this.
We are working hard to resolve these issues that severely impact the experience, so this article may change from time to time without prior notice.

:::

## Run LauncherX to launching Minecraft

Basically, the prerequisites are basically the same for all desktop environments.

Downloading the **Configuration Assistant** is the most suitable solution for ordinary users (the tool has not yet developed, so stay tuned XD.); and for the distribution environment, it is recommended to use the **stable version including runtime** (will be released in "Stable Released" when the first stable version comes out); in addition, you can manually place the LauncherX executable file you want to use directly into your directory after completing the local runtime installation. This is exactly what the Configuration Assistant automates.

But for now, whether it is Windows, macOS or a Linux distribution with a desktop environment, or whether the architecture is x86-64, x86-S, amd64 or ARM64, you have downloaded the corresponding LauncherX according to the current operating system to your desired location. The folder in which it is run, and has prepared the runtime environment accordingly (the configuration assistant will be completed automatically, and this step is not required when including the run), then you can double-click its icon to run it like other apps.

Next, I will list all known possible issues.

## Common issues

Since our Java RE detection mechanism works in "search-execution" mode to confirm whether the runtime is available, you may encounter an error pop-up window from Java when you start LauncherX. You can turn it off directly, as this will not affect LauncherX runs. You can **remove** the damaged runtime.

---

---
url: /enUS.md
---


---

---
url: /enUS/projbobcat/installers.md
---
\#Installer

In ProjBobcat, we've implemented most of the modding infrastructure you're likely to encounter during MineCraft development for developers.

## Support list

| Project Name | Support Status ||
|:---------------:|:-----------:|:---:|
| Forge (old version) | Supported | ✅ |
| Forge (new version) | Supported | ✅ |
| NeoForge | Supported (Experimental) | ⚠ |
| LiteLoader | Supported | ✅ |
| Fabric | Supported | ✅ |
| Optifine | Supported | ✅ |
| Quilt | Supported (Experimental) | ⚠ |
| CurseForge Integration Pack | Supported | ✅ |

---

---
url: /enUS/team.md
---


---

---
url: /ruRU.md
---


---

---
url: /ruRU/team.md
---


---

---
url: /zhCN/guide/standard/cmfs-stable-test-general-standard.md
---
暂未编写

---

---
url: /zhCN/guide/team.md
---


---

---
url: /zhCN.md
---


---

---
url: /zhCN/lxguide/features/game-assets.md
---


---

---
url: /zhCN/lxguide/features/tricks/pack-folder-rules.md
---


---

---
url: /zhCN/lxguide/settings/item/advanced.md
---


---

---
url: /zhCN/lxguide/settings/item/customize.md
---
##

---

---
url: /zhCN/lxguide/settings/item.md
---
## 分类

这个板块会随着LauncherX的具体更新而更新，恕不另行通知。

详细而言，这里会指出LauncherX每一项具体的设置代表着什么。有些涉及启动原理的项目可能同样适用于其他启动器，但是我们当然**更希望您能一直使用LauncherX。**

我们将会在这里告诉您最具体的设置方法，比如：如何设置JVM高级启动参数？离线模式的本地皮肤是什么原理？如何合理选择GC（垃圾回收器）？诸如此类。

相信您在理解所有设置之后能够自行找出适合自己的最佳游戏体验。

::: danger 需要帮助！

由于各方面需要，【全局游戏设置】与【外观】两个设置大分类中被拆成了数个小分类，但是实际上部分设置并没有被放在最合适的分类之中，或是部分分类根本不合理。我们希望有社区的力量帮助我们进行重新分类！

这属于反馈的范畴，高效率的反馈方式参见：[报告异常&建言新策 | 日冕知识库](/zhCN/lxguide/report-issue)

:::

::: info

翻译者请注意：本分类中的所有项目的标题（包括侧边栏标题）**必须**完全符合LauncherX对应的本地化翻译。否则将会造成误解。

:::

---

---
url: /zhCN/lxguide/settings/special.md
---
## 专题

详细而言，专题会指引您完成比较曲折的操作。比如，调整启动器的整体外观到您中意的风格，或者结合“固定启动账户”和“游戏账户管理”来使您可以快速使用常用的账户启动游戏。

不过，想必您在阅读理解了**分类**板块之后，能够充分地发挥您的主观能动性并且玩出我们或许也未曾设想的花样。我们期待您能够深入地体验我们的产品！

---

---
url: /zhCN/lxguide/ui-guide/0_interface.md
---
*

---

---
url: /zhCN/lxguide/ui-guide/1_gamelist.md
---


---

---
url: /zhCN/lxguide/ui-guide/2_download.md
---


---

---
url: /zhCN/lxguide/ui-guide/3_settings_localAccounts.md
---


---

---
url: /zhCN/lxguide/ui-guide.md
---
/

---

---
url: /zhCN/mc-starter/advanced.md
---


---

---
url: /zhCN/mc-starter/assets-and-mods.md
---


---

---
url: /zhCN/mc-starter/start-the-game-java.md
---


---

---
url: /zhTW.md
---


---

---
url: /zhTW/team.md
---


---

---
url: /enUS/projbobcat/resourceCompleter/resourceInfoResolver/versionInfoResolver.md
---
# Version information resolver

\[\[toc]]

The version information resolver provides parsing and verification functions for game asset files. These files are stored in
`.minecraft/versions/{GAME_VERSION}/{GAME_VERSION}.jar` directory. These files are the core files necessary to start MineCraft.

## Initialize the parser

You can initialize the initialization parser with the following code:

```c#

var resolver = new VersionInfoResolver
{
    BasePath = "[GAME_ROOT_PATH]",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES]
};

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:-----------------------:|:--------------------------------:|
| \[GAME\_ROOT\_PATH] | The game root directory, usually the path to the .minecraft folder |
| \[SEARCHED\_VERSION\_INFO] | VersionInfo of the version to check (obtained via game locator) |
| \[CHECK\_LOCAL\_FILES] | Check local files (if false, skip all checks) |

---

---
url: /enUS/CMFS.md
---
# Welcome to the CMFS Guide

First of all, thank you for choosing to join Minecraft CraftMineFun Server (CMFS). This series of guides will help you understand everything about CMFS, give full play to your subjective initiative, and use the special gameplay we provide to build and tour.
Join with your friends or meet new a one here to play cooperatively or compete.
Don't worry, our team cares most about your experience.
If you encounter problems with your gaming experience, please **contact us immediately**!

\[\[toc]]

:::warning All servers are suspended for now

Please wait for further notice (November 27, 2022)

Or join our QQ group **419902868** for fast notification.

:::

## component

* CMFS-Pure: Pure survival server! You can join the game through a specific version of Minecraft and experience the unique gameplay carefully conceived by us. *AH... This server is under maintenance*

* CMFS-SquareCraft: SquareCraft Server is a Mod server that we cooperate with SquareCraft. Enjoy the "living soul" of Minecraft in our high-performance, stable servers: highly free and highly scalable. *This server is in a hypothetical state*

* CMFS-Eksamen You are free to join this server to request an audit by the Construction Group of Corona Studios (Corona Industries). This is essentially a vanilla creative mode building server that showcases your Minecraft building skills in our rigorous environment. When we have a need to recruit new people, we will issue an invitation for further review based on the quality of the building works that have been submitted for review: after passing, you will join our architectural team. Perhaps you can not only develop your own abilities here, but also discover colleagues here? *This server is WIP!*

* CMFS-Juego There are various mainstream mini-games and arenas we have prepared, as well as unique mini-games conceived by us. It distinguishes multiple different game versions, providing experiences from different eras. *There is currently no person in charge of this server*

* CMFS-Login "Extended in all directions." This server is the entrance to the entire CMFS and is the transit server responsible for distributing players to the server they want to reach. You need to log in to the group server here through a CMFS account or a corona service account bound to a CMFS account. *This server needs to be rebuilt together with CMFS-Pure*

## CMFS-Pure Guide

---

---
url: /enUS/guide.md
---
# Welcome to the Corona Studio Knowledge Base (CSKB)

Here you can check out some technical documents, troubleshooting solutions for projects owned by Corona Studio, as well as various technical specifications and samples related to Minecraft.

---

---
url: /zhCN/lxguide/startup/others/win7.md
---
# Windows 7 用户指南

LauncherX宣称支持Windows7, 但是截至目前(2025年) Windows7已经是快要有20年历史的操作系统了. 随着LauncherX框架的不断迭代, 对Windows7的支持随时可能终止 (确认不再支持后, 这里将会有明显提示) ———— 接下来的操作指导是基于一个**全新安装的Windows7 Ultimate**探索而来. 部分需要手动下载和依赖的下载链接也可能随时失效.

\[\[toc]]

::: warning 前置条件
LauncherX **仅支持64位操作系统**, 因此你的Windows7 必须是**64**位 **非简化版**.
:::

## 做好准备

首先, 你的Windows7设备需要确保**有网络连接**, 然后准备下载一系列的资源. 以下是需要下载的内容清单和对应的链接.

* LauncherX [官网下载](https://corona.studio/lx/download) 下载Windows x64版本
* VxKex [Github Release](https://github.com/i486/VxKex/releases/tag/Version1.1.2.1428) 下载Assets部分展示的KexSetup\_Release\_<版本号>.exe
* Windows更新补丁 **KB2670838** [Microsoft Update Catalog](https://www.catalog.update.microsoft.com/Search.aspx?q=KB2670838) 下载标明**Windows7**、**x64**的、文件大小为**11.3MB**的那一项, 点击那一行最右方的Download按钮.
* Windows更新补丁 **KB2533623** [Legacy Update](https://legacyupdate.net/download-center/download/26764/update-for-windows-7-x64-kb2533623) 点击页面中的*蓝色文字*「Windows6.1-KB2533623-x64.msu」下载
* Visual C++ 2015运行库 版本`14.0.23026` [MS VC REDIST 2015 14.0.23026](https://www.microsoft.com/zh-CN/download/details.aspx?id=48145) 用于补全`MSVCP140.dll`.
* Visual C++ 2015运行库 版本`14.42.34438` [MS VC REDIST 2015 14.42.34438(下载)](https://download.visualstudio.microsoft.com/download/pr/285b28c7-3cf9-47fb-9be8-01cf5323a8df/8F9FB1B3CFE6E5092CF1225ECD6659DAB7CE50B8BF935CB79BFEDE1F3C895240/VC_redist.x64.exe) 用于补全`MSVCP140.dll`.
* (可选) .NET Desktop Runtime 9 (视LauncherX当时使用的.NET版本为准) [.NET9 桌面运行时(下载)](https://dotnet.microsoft.com/zh-cn/download/dotnet/thank-you/runtime-desktop-9.0.4-windows-x64-installer)

## 开始安装

在进行此部分操作时, 建议关闭电脑上的**一切杀毒软件**. 为了避免在此期间电脑受到外来攻击, 可以考虑断网.

### 1) 准备环境容器

1. 双击文件来安装刚才下载好的两个更新补丁. 安装过程不要求重启, 可以安装完全部的两个包后再重启.
2. 重启后, 找到刚才下载好的**VxKex**安装包, 运行并安装. 执行默认的安装即可. 安装后会要求重启.
3. 再次重启后, 环境容器准备完成. 可以随便找个`.exe`文件, 右键点击它查看其属性, 若属性选项卡中出现VxKex选项卡即为安装成功.

### 2) 补全依赖库

::: info 可能存在重复的步骤
:::

1. 找到刚才下载的版本号为`14.0.23026`的VCRedist库, 双击安装;
2. 完成上一步后, 找到另外一个VCRedist库, 双击安装;
3. 刚才如果下载了.NET桌面运行时, 将其安装.
4. 重启电脑.

### 3) 应用变更

接下来, 将LauncherX放在一个 **非C盘根目录的**, 且**不是桌面**的**空**文件夹中, 然后右键点击它, 点击属性, 然后点击VxKex选项卡, 勾选“Enable VxKex for this Program”, 然后点击应用并关闭属性窗口.

理论上, 此时已经可以正常使用95%的LauncherX功能了. 双击LauncherX, 尝试运行. 如果仍然有问题, 参阅: [如何反馈问题](/zhCN/lxguide/report-issue).

## 可能的问题

已知在Windows7中运行LauncherX会遇到以下问题:

* 卡在「正在自动登陆」: 这是未正确启用VxKex导致的, 实际错误是无法使用Windows7还不支持的Win32 API来初始化联网操作.
* 下载Java闪退: 暂时不明确哪部分不工作, 建议自行下载Azul Zulu以避开此问题. 参阅: [如何下载JRE](/zhCN/lxguide/others/download-jre.md)
* 无法获取游戏列表: 请尝试切换到其他下载源并关闭混合源补全.

---

---
url: /enUS/projbobcat/authenticators/yggdrasil.md
---
# Yggdrasil Authentication Model

\[\[toc]]

This authentication model implements an older version of Mojang's authentication scheme, which is now deprecated.

::: warning

Continuing to use this model for verification of official accounts will be considered an invalid request.
But the model can still be used to log in to servers that use third-party authentication services (such as [AuthLib-Injector](https://github.com/yushijinhun/authlib-injector)).

:::

## Initialize validator

You can initialize the offline validator with the following code:

```c#

var yggdrasilAuthenticator = new YggdrasilAuthenticator
{
    AuthServer = "[CUSTOM_AUTH_SERVER]",
    Email = "[EMAIL],
    LauncherAccountParser = launcherAccountParser,
    Password = "[PASSWORD]"
};

```

In the above code block, please replace these parameters according to your actual situation:

| Project | Description |
|:------------------------:|:-------------------------------------------:|
| launcherAccountParser | For initialization of the launcher account parser, see here |
| \[CUSTOM\_AUTH\_SERVER] | Optional field, custom authentication server address. This field is usually provided by a third-party authentication service provider. If not filled in, Mojang's official authentication server address will be used |
| \[EMAIL] | Email address to verify account |
| \[PASSWORD] | Password to verify account |

:::tip

For the initialization of **launcherAccountParser** (game profile parser), please refer to the [Game Profile Parser](/enUS/projbobcat/additionalParsers/gameProfileParser) page

:::

:::warning

When using a third-party authentication server, use the **https://** rather than the **http://** protocol to connect to the authentication server.
Using an insecure authentication server may lead to sensitive data leakage and other issues.

:::

## Get authentication results

After you complete the initialization of the authentication model, you only need to call the authentication method of the offline verifier to complete the account authentication.

In an asynchronous context, use **AuthTaskAsync** to accomplish authentication:

```c#

var authResult = await offlineAuthenticator.AuthTaskAsync(false);

```

In a sync context, use **Auth** to finish authentication:

```c#

var authResult = offlineAuthenticator.Auth();

```

## Interpret authentication results

After the authentication method is completed, the authentication model will return the authentication result, which is of the parent type [AuthResultBase](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/Auth/AuthResultBase.cs) object.
All authentication results contain an enumeration value **AuthStatus**, which directly indicates the success or failure of the authentication result.
Below you can see an interpretation of the authentication results:

### Failed authentication result

By judging whether **Error** is empty, you can easily judge whether the authentication results returned by the authentication model are valid.
The **Error** object will contain the following fields to tell you some details:

| Field | Description |
|:--------------------------------:|:----------------:|
| authResult.Error.Cause | The specific cause of the problem |
| authResult.Error.Error | error name |
| authResult.Error.ErrorMessage | Details of the error, possibly including a solution |

### Successful authentication result

If the **Error** field in the authentication result is empty, it means that the authentication is valid. A successful authentication result will contain the following information:

| Field | Description |
|:--------------------------:|:---------------------------------:|
| authResult.Id | The unique identifier of the username, ProjBobcat uses a specific generation method to generate this identifier |
| authResult.AccessToken | Authorization credentials for the user account |
| authResult.Profiles | List of roles available to the user, which may contain multiple available roles |
| authResult.SelectedProfile | The role currently selected by the user. This field may be empty. If it is empty, the user needs to be prompted for manual selection. |
| authResult.User | Summary of user account information, including some basic account information |
| authResult.LocalId | Local ID, usually a randomly generated UUID |
| authResult.RemoteId | The remote ID returned by the authentication server, usually a unique identifier for the user |

---

---
url: /zhCN/projbobcat/authenticators/yggdrasil.md
---
# Yggdrasil 验证模型

\[\[toc]]

该验证模型实现了旧版 Mojang 的验证方案，目前该方案已经被弃用。

::: warning

继续使用该模型进行官方账户的验证将被视为无效的请求。
但该模型仍然可以用于登录使用第三方验证服务的服务器（例如 [AuthLib-Injector](https://github.com/yushijinhun/authlib-injector)）。

:::

## 初始化验证器

您可以通过下面的代码初始化离线验证器：

```c#
var yggdrasilAuthenticator = new YggdrasilAuthenticator
{
    AuthServer = "[CUSTOM_AUTH_SERVER]",
    Email = "[EMAIL]",
    LauncherAccountParser = launcherAccountParser,
    Password = "[PASSWORD]"
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|          项目           |                             说明                              |
|:---------------------:|:-----------------------------------------------------------:|
| launcherAccountParser |                     对于启动器账户解析器的初始化，详见此处                     |
| \[CUSTOM\_AUTH\_SERVER]  | 可选字段，自定义验证服务器地址，这个字段通常由第三方验证服务提供商提供，不填则使用 Mojang 官方的验证服务器地址 |
|        \[EMAIL]        |                          验证账户的邮箱地址                          |
|      \[PASSWORD]       |                           验证账户的密码                           |

:::tip

对于 **launcherAccountParser**（游戏档案解析器）的初始化，请参考[游戏档案解析器](/zhCN/projbobcat/additionalParsers/gameProfileParser)页面

:::

:::warning

在使用第三方验证服务器时，请使用 **https://** 而非 **http://** 协议连接到验证服务器。
使用不安全的验证服务器可能会导致敏感数据泄露等问题。

:::

## 获取验证结果

在您完成验证模型的初始化后，您只需要调用离线验证器的验证方法来完成账户验证。

在异步上下文中，使用 **AuthTaskAsync** 来完成验证：

```c#
var authResult = await offlineAuthenticator.AuthTaskAsync(false);
```

在同步上下文中，使用 **Auth** 来完成验证：

```c#
var authResult = offlineAuthenticator.Auth();
```

## 解读验证结果

在验证方法完成之后，验证模型会返回验证结果，这是父类型为 [AuthResultBase](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/Auth/AuthResultBase.cs) 的对象。
所有的验证结果都包含一个枚举值 **AuthStatus**，该枚举值直接指示了验证结果的成功或是失败。
在下面您可以看到对验证结果的解读：

### 失败的验证结果

通过判断 **Error** 是否为空，您可以很轻松的判断验证模型返回的验证结果是否是有效的，
**Error** 对象会包含以下字段来告诉您一些细节：

|              字段               |        说明        |
|:-----------------------------:|:----------------:|
|    authResult.Error.Cause     |    导致问题的具体原因     |
|    authResult.Error.Error     |       错误名称       |
| authResult.Error.ErrorMessage | 错误的详细信息，可能包含解决方案 |

### 成功的验证结果

如果验证结果中的 **Error** 字段为空，则表示本次验证是有效的，成功的验证结果会包含下面的信息：

|             字段             |                   说明                    |
|:--------------------------:|:---------------------------------------:|
|       authResult.Id        | 该用户名的唯一标识符，ProjBobcat 使用特定的生成方式来生成这个标识符 |
|   authResult.AccessToken   |                用户账户的授权凭据                |
|    authResult.Profiles     |          用户可用的角色列表，可能包含多个可用角色           |
| authResult.SelectedProfile |  用户当前选择的角色，该字段可能为空。如果为空则需要提示用户进行手动选择。   |
|      authResult.User       |          用户账户信息摘要，包含一些基础的账户信息           |
|     authResult.LocalId     |           本地 ID，通常为随机生成的 UUID           |
|    authResult.RemoteId     |       验证服务器返回的远程 ID，通常为该用户的唯一标识符        |

---

---
url: /zhCN/mc-starter/play-together.md
---
`@useFixer`

# 一起玩吗? 联机游戏指南

:::tip

本文将介绍几种常见的流行的联机方式。需要注意的是，由于实现原理不同，不同的方法有不同的特点，应用于游戏中可能造成不同的优劣势.

:::

或许你一个人在原野上漫步的时候听着Minecraft的背景音乐，感受到了一丝孤独? 此时或许会想，要是我能和我的好友——三年二班的李子明同学一起玩、一起建设装点这个世界就好了! 对于基岩版玩家，或许可以考虑使用XBox提供的好友联机，但是Java版目前 (2024-06-20) 并没有这种联机方式。如果你希望使用Java版进行多人游戏，或许需要费一番功夫了。 `i`

\[\[toc]]

## 联机游戏一般能达成什么效果?

联机游戏，顾名思义就是“一起玩”，最终能够使得多个使用不同设备的玩家能够连接进入同一个 “世界” 。`i`

## 不同的联机方式以及对应的特点

### 局域网联机

::: warning 保持世界开启

要保持大家都能玩，请保证：

* 不要退出世界，更不要退出游戏
* 不要断开网络连接
* 只有这个世界还在运转，大家才能在一起游玩。

:::

通俗而言，多台电脑处于一个wifi或通过网线连接到同一台路由器，可以认为它们**接入了同一个局域网**。在同一局域网中，一台电脑进入一个单人世界后，可以在暂停菜单中选择「在LAN」，然后其他电脑就可以在「多人游戏」中找到这个世界了.`i`

这种方式需要一台电脑保持游戏运行、世界开放，当那台电脑断开网络连接/退出世界/关机，其他玩家就不能加入到此世界了.`i`

### P2P联机

::: warning 保持世界开启

要保持大家都能玩，请保证：

* 不要退出世界，更不要退出游戏
* 不要断开网络连接
* 只有这个世界还在运转，大家才能在一起游玩。

:::

#### 1、总览

P2P联机的常用方式是将不同地区的电脑通过P2P网络连结在同一个虚拟的「局域网」，因此实际操作方法与局域网联机类似，但是多了一些启用P2P的步骤。接下来将介绍LauncherX P2P方法和Zerotier P2P组网方法。`i`

::: details 关于P2P和Radmin VPN的区别

LauncherX内置的联机方式基于P2P技术，通过软件管理一个虚拟的房间，然后将其他人连入房主的虚拟内网中映射。而Radmin相当于在房主电脑上部署了一个VPN服务器，其他人连入Radmin房间相当于直接接入了房主的本地内网。

:::

需要注意的是，由于P2P技术的特殊性，仍然具备一定的情况会使得用户无法建立有效的连接，或是出现体验偏差的情况。这是由诸多网络环境因素导致的，比如网络运营商设置的**NAT类型**，可以阅读[P2P学习: NAT的四种类型以及类型探测](https://www.cnblogs.com/ssyfj/p/14791064.html)*by  - 山上有风景 - 博客园*  来进一步了解。**总而言之，NAT一般分别有以下类型**:`i`

1. 全锥型(Full Cone)
2. 受限锥型(Restricted Cone)，或者说是IP受限锥型
3. 端口受限锥型(Port Restricted Cone)，或者说是IP + PORT受限锥型
4. 对称型(Symmetric)

其中，1、2、3都是锥形NAT，编号越大限制越多; 4是对称型NAT，具有这四种中最大的限制。网络环境中NAT限制越大，成功实现P2P网络的可能越小.

#### 2、LauncherX P2P

若要使用LauncherX进行P2P联机游戏，参考：[P2P联机 | 日冕知识库](/zhCN/lxguide/features/p2p.html)

### 构建虚拟专属网络

#### 1、使用Radmin LAN

::: info

内容施工中

:::

#### 0、知道其他工具吗?

::: tip 欢迎直接向我们的文档仓库提交issue或pull request来完善本文内容!

如果你选择提交pull request来完善本文，欢迎!

不过如果你选择通过issue来告诉我们更多类似Radmin LAN的工具，亦不甚感激!

:::

### 内网穿透

内网穿透将内网的电脑上特定端口通过转发来在公网的某个端口暴露出来，以供连接。市面上成熟的内网穿透（FRP）服务提供商有很多，比如OpenFRP。如果你有一个性能不足以运行服务端的VPS但是它足够用来搭建FRP服务器，也可以自行搭建。你需要自行确认当前所在地区和VPS服务商对FRP的管理政策。接下来介绍两种借助内网穿透的联机方法。`i`

#### 1、将局域网世界暴露到公网

::: warning 保持世界开启

要保持大家都能玩，请保证：

* 不要退出世界，更不要退出游戏
* 不要断开网络连接
* 只有这个世界还在运转，大家才能在一起游玩。

:::

这个方案相当于将自己电脑上的Minecraft的内部服务器暴露给其他人，只需要将内网的服务转到外网即可。具体操作步骤如下：`i`

* 启动游戏，进入要一起游玩的世界

* 暂停游戏，点击【对局域网开放】

* 在不同版本游戏中，这一步的操作不一样。

  * 对于较老版本的游戏，Minecraft会寻找一个未被占用的端口，然后在那个端口上暴露游戏。具体使用的端口将会在聊天区显示出来类似如下文字：
    ```pascal
    本地游戏已在端口[11451]上开启
    ```

  * 对于较新版本的游戏，在点击【对局域网开放】后会有另外一个界面，在这里可以自定义端口号，留空以允许Minecraft选择找到的一个随机的未被占用的端口，点击【创建局域网世界】以确认配置。端口号显示同上。

* 现在你已经准备好世界了，记下这个端口号，然后在你选择的 **FRP服务商控制台** 中挑选合适的节点以创建FRP隧道或修改现有隧道（具体操作方法参考服务商提供的文档和教程）

* 将端口号输入到本地端口那一栏，保存，回到自己的电脑上启动FRP启动器

* 确保你的隧道已创建，然后开启它

* 开启成功后，将该隧道的链接连同对应的端口（可能并非游戏给你的端口，而是你在FRP控制台选择或被分配的端口）发送给一起玩的玩家。一起玩的玩家只需要使用同样的游戏客户端，在【多人游戏-添加服务器/直接连接】的【服务器地址】一栏填入你提供的地址即可连接。

* 每次启动世界所使用的端口号可能不相同，为此你需要每次都更改隧道中记录的本地端口号。

* 如果需要修改这种世界的联机服务器设置，你可能需要借助Mod来修改，比如：[自定义局域网联机 (Lan Server Properties) - MC百科](https://www.mcmod.cn/class/2754.html)

相关阅读：[基本教程 | OpenFrp Docs](https://doc.openfrp.net/use/) | [Windows 桌面启动器 | OpenFrp Docs](https://doc.openfrp.net/use/desktop-launcher.html) | [我的世界（Minecraft）服务端配置 | OpenFrp Docs](https://doc.openfrp.net/use/configuration/minecraft.html) | [搭建内网穿透(Frp) | 笨蛋 MC 开服教程](https://nitwikit.8aka.org/advance/Linux/frp/) | [基础知识 | 笨蛋 MC 开服教程](https://nitwikit.8aka.org/Java/basic)

#### 2、使用家庭电脑作为服务器

你可以下载服务端到自己的电脑上来运行，这样，在你的电脑上就相当于有一个Minecraft游戏服务器了。我们称这个行为为 **开服**。`i`

> 开服，就是相当于，你在这个游戏里面，创建了一个24h永久不断开的联机房间。不管是作为创建服务器的你，还是说加入到你这个服务器的玩家，你们的进入与退出都不会影响到服务器的开放使用。（引用自：[服务器大体框架知识（搭建必看）](https://www.yuque.com/dongyue-ygyej/ny8uqi/de0g6uvzy31eebmg?singleDoc#)）

已经有相当数量的教程介绍了如何开服。在这里，笔者仅将大体步骤抽象出来：

* 准备环境（可以认为是：新建文件夹存放服务端，准备Java环境，下载服务端到新建文件夹）
* 准备运行脚本
* 首次运行脚本，然后阅读创建的EULA并决定是否同意。只有同意了EULA才能继续开服。（EULA：最终用户许可协议，是一种具备法律效力的文本。在这里主要是对Minecraft知识产权的保护。至少，首先，开服不要想着赚钱。Minecraft官方的EULA原文也可以在[这里看到](https://www.minecraft.net/zh-hans/eula)，或者查看[Usage Guidelines | Minecraft](https://www.minecraft.net/zh-hans/usage-guidelines) 来确认哪些可以做，哪些不可以做。）
* 等待服务器就绪，然后加入服务器的世界吧！

推荐阅读：

* Minecraft Wiki：[Tutorial: Setting up a server – Minecraft Wiki](https://minecraft.wiki/w/Tutorial:Setting_up_a_server)
* 笨蛋开服教程：[开始 | 笨蛋 MC 开服教程](https://nitwikit.8aka.org/intro)
* 冬月的大体框架知识：[服务器大体框架知识（搭建必看）](https://www.yuque.com/dongyue-ygyej/ny8uqi/de0g6uvzy31eebmg?singleDoc#)
* 官方下载服务端的链接：[Download server for Minecraft | Minecraft](https://www.minecraft.net/zh-hans/download/server)
* Java版服务端核心文件解释：[服务端核心文件 | Minecraft Wiki](https://zh.minecraft.wiki/w/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A0%B8%E5%BF%83%E6%96%87%E4%BB%B6)

*这些内容对于接下来的内容同样有用。*

### 使用云服务器

::: warning 谨慎辨别在线购买的服务

使用购物平台可以搜索到很多看起来很适合 “小白” 的云服务器，尤其是面板服。但是，商家可能利用信息差赚取更高额的服务费用。建议在付款前请求试用，或者在各大交流群、论坛中尝试询问有经验的 “大佬”、“菊苣”，抑或是仔细参考商品信息和商品评价，尽可能避免上当。`i`

此外，可以尝试通过多种渠道了解和分析商家的信用水平，以避免出现纠纷或是遇到商家跑路的问题。`i`

我们建议先了解的一些基础知识：[基础知识 | 笨蛋 MC 开服教程](https://nitwikit.8aka.org/Java/basic)`i`

:::

#### 0、真的需要云服务器吗？

据笔者所知，只有在这些情况下才真正 **有必要** 租用云服务器来维持多人游戏：

1. 玩家数量较多，且需要运行世界的主机长期开启以保持玩家随时可连接
2. 在本文中其他方法无法维持游戏体验（包括但不限于：自己电脑无法维持多人游戏）

使用云服务器来组织多人游戏是有一定技术门槛和经济能力要求的。对于新手而言，只要愿意付出精力和时间，总是能够积累起技术来运营和维护属于自己的Minecraft多人游戏服务器。在真正租用服务器之前，首先要试着做：`i`

1. 在自己的电脑上练习开服，同时学习一些计算机和网络的基础概念；
2. 学习一些JVM优化方面的概念（参考阅读：[合理分配游戏内存、选择GC、配置JavaAgent | 日冕知识库](/zhCN/lxguide/others/adjust-ram-gc-ja.html)，[下载合适的Java运行时 | 日冕知识库](/zhCN/lxguide/others/download-jre.html)，[Java 相关 | 笨蛋 MC 开服教程](https://nitwikit.8aka.org/lava/overview)）至少要知道如何调整服务器分配的内存、如何指定垃圾回收器（甚至 **垃圾回收器** 是干什么的也需要了解一下）
3. 了解并遵守有关的 **涉及版权的具备法律效力的协议** （比如 著名的 Minecraft EULA），确保你开服并不会侵犯他人权益来赚钱
4. 了解你将要开的服务器的类型（使用 什么样的服务端？性能需求有多大？又如何使用类似Spark这样的工具来分析服务器性能和占用？参考阅读：[什么是服务端？ | 笨蛋 MC 开服教程](https://nitwikit.8aka.org/start/basic/what-is-server)，[Spark Wiki：前言 | Continue Project](https://snowcutieowo.github.io/spark/)）
5. 其间，如果遇到问题可以到相关社区请教有经验的人。不要忘了 **你并不比别人差** ，并且无论如何 **勤能补拙** ，如果能做到 **虚心请教** 并且 **独立人格、不讨人厌** ，那么你将能获得不少人的帮助。（参考阅读：[如何向大佬求助 | 笨蛋 MC 开服教程](https://nitwikit.8aka.org/start/ask-for-help)，[Minecraft新手上路! #自食其力、自给自足| 日冕知识库](https://kb.corona.studio/zhCN/mc-starter/#自食其力、自给自足)）

然后，你才真正准备好开服了。

#### 1、云服务器分类

*可以租用的云服务器有许多种。此处不讨论《我的世界》租赁服务器。*

##### a) Minecraft Realms

这是由Mojang提供的官方租赁服务器，存在Java版和基岩版两种版本。 `i`

###### 优点：

* 十分稳定，随着游戏主版本更新而更新

###### 缺点：

* 大多部署在中国大陆境外，连接可能存在一些延迟
* 相比而言不那么便宜

###### 特性：

* 玩家必须拥有正版Minecraft，无法通过离线模式游玩
* 一般有严格的游玩人数限制，适合朋友一起玩
* 扩展性局限于原版游戏
* 基岩版和Java版Realms都有，但是分离

###### 如何购买：

前往Minecraft官网即可购买：[Wallet & Realms | Minecraft](https://www.minecraft.net/en-us/msaprofile/myrealms)

参考阅读（官方）：[Minecraft Realms 教程和指南 | Minecraft](https://www.minecraft.net/zh-hans/realms/realms-tutorial)

***

##### b) VPS

VPS可能包含NAT类和独立IP类，对于Minecraft游戏而言，两者的区别在技术上并不会引起很大影响。如果是独立IP，那么开放默认的25565端口后，服务器地址可以不用在末尾追加端口（比如：`thatsmine.kami.su:25565`中，末尾的`:25565`是没必要的，可以省略）；`i`

而如果是NAT类VPS，那么端口在暴露到公网时会被转发，也就是说原本的25565端口在暴露到公网时候会变成别的端口（具体变成什么端口请询问服务商）这时候如果想要抹掉地址末尾的端口号，需要用你的域名创建一个SRV解析指向你的服务器。相关阅读：[域名申请与解析 | 笨蛋 MC 开服教程](https://nitwikit.8aka.org/advance/domain-application-and-dns-resolution/#srv-记录)。 `i`

相对而言，使用VPS开服将会有最高的自由度。 `i`

###### 优点：

* 自由度超高，完全自选服务端核心
* 扩展性超高，可以选用Forge、Fabric、Arclight、Mohist等服务端
* 可以在VPS中运行群组服，满足更多需求

###### 缺点：

* 运维技术门槛更高
* 要求对硬件需求有明确认知
* 开服的经济成本相对较高

###### 特性：

* 允许非正版玩家加入游戏
* 由于有最高的自由度，不仅可以在VPS上运行Java版服务器，还可以运行基岩版服务器；在VPS上开启的Java版服务器甚至可以做到让Java版和基岩版玩家一起游玩（参考：[Geyser概览 | 笨蛋 MC 开服教程](https://nitwikit.8aka.org/Java/process/mobile-player/Geyser/introduction/overview)）也可以做到让正版玩家、外置登录玩家和离线玩家一起游玩（参考：[MultiLogin Wiki](https://github.com/CaaMoe/MultiLogin/wiki)）

##### 如何购买：

除了阿里、腾讯云等云计算大厂，还有许多二线三线云服务商提供VPS租赁服务。一般而言，针对Minecraft特化的VPS由专注于提供游戏服务器的服务商提供，性能更贴合实际需求，价格相比大厂更便宜。但是要小心，有一些不那么正规的商家可能会兜售 “超开服务器” ，即单台宿主服务器（可以理解为一台电脑）上本来性能只够4个人平分，但是商家在上面部署了8个或更多VPS来售卖——这样会导致峰值网络性能和算力变差，使得游玩体验大打折扣。 `i`

在购买租赁VPS之前，请尽可能地打听商家的名誉，再三确认算力需求，然后再下单。 `i`

***

##### c) 面板服

面板服，顾名思义，就是提供一个网页面板以供管理，系统环境配置等基本上都不需要你自己考虑。这可能是最简单的方案。有的服务商会专门出租这种服务，甚至有的服务商会在面板中提供一些整合包以供一键开服，一般情况下他们提供的预设在稳定性上有足够保障，只是快捷开服想要玩玩的话，这个方案是最合适的，但是如果需要自己排除错误，仍然需要学习一些基础知识（参考上文关于VPS的部分）。 `i`

与此同时，如果你租用了VPS，也可以请求技术人员为你部署类似MCSManager的面板便于管理。 `i`

::: warning 小心贩子

面板服市场上除了可能出现超开问题，还可能有贩子。贩子从上游渠道进货得到实例开启权限，然后将其售卖给客户，实际的技术细节很少涉及；并且由于要保证利润，实际上的价格缺乏竞争力，但是他们会为自己的宣传投资以保证成交量。有能力的情况下，请选择能没有中间商的面板服租赁。`i`

:::

###### 优点：

* 便于随时访问和管理
* 可能可以很方便地进行服务端部署

###### 缺点：

* 自由度受限
* 如果恰好买到配备功能缺失的面板的面板服，功能会进一步受到限制
* 被坑的可能性提升

###### 特性：

* 整体会比VPS便宜一些，适合轻量化需求的服主

###### 如何购买：

预制面板服多见于电商平台和专攻Minecraft等游戏服务器供应的服务商。 `i`

***

---

---
url: /zhCN/lxguide/others/download-jre.md
---
# 下载合适的Java运行时

下载Java运行时的方式有很多种。这里介绍两个使用LauncherX时最主要的方法。

\[\[toc]]

::: tip 前置知识

你需要确保你知道你的电脑当前运行的操作系统和CPU架构以确保获得最佳游戏体验。

相关阅读：[辨识计算机环境 | 日冕知识库](/zhCN/guide/general/check-system.html)

:::

## 使用其他构建

一般而言，我们建议使用来自 **Azul Zulu** 的JDK构建（根据部分反馈，不再推荐Alibaba Dragonwell，除非环境一定需要它）用于游戏。在LauncherX的“设置-全局游戏设置-启动设置-资源下载” 中提供了几个版本基于x64平台的JRE下载。这些下载是由Mojang选择的用于游戏的JRE，一般都是来自OpenJDK的构建。但是，目前(2024-03-17)为止，Mojang尚未为ARM平台选择JDK。因此，对于ARM平台用户或想要通过更换JRE来优化游戏的用户，我们建议使用Azul Zulu JDK，因为它是面向服务端优化的版本，应对高频内存I/O、高负载计算时能有更好的性能，且都有面向ARM平台(aarch)的构建可供下载。以下是这几种JDK的官方下载链接，您需要打开后选择需要的版本:

* [Azul Zulu官方下载(英文)](https://www.azul.com/downloads/#zulu): 提供各种版本的JDK构建，可选包含JavaFX运行时
* [Azul Zing官方下载(英文)](https://www.azul.com/downloads/#prime): 各种新版JDK构建，免费版可能略有不稳定的情况，但是性能更好（一般来说，大概）
* [Oracle Java SE Runtime 下载(英文)](https://www.oracle.com/cn/java/technologies/downloads/archive/): Oracle的Java下载归档站
* [OpenJDK](https://openjdk.org/): 就是OpenJDK而已

接下来，我们以Azul Zulu为例展示如何下载，以及下载后应该如何让LauncherX找到.

::: warning 请注意

由于仅Windows版本的LauncherX支持深度搜索，且深度搜索获取结果较慢，故此接下来的教程中只使用一般搜索和手动添加.并且这里只介绍下载打包为.zip的二进制文件的用法。如果Linux用户在下载后出现问题，请尝试下载.tar.gz，这个格式的归档保留了权限设置.

:::

### 访问官网的下载页面

访问 https://www.azul.com/downloads/#zulu ，找到**下载区域**。如图所示的是版本筛选框.

![azul-website](/assets/azul-website.Bz9-pqV-.png)

1. 在 **Operating System** 处选择 Windows/macOS/Linux(请自行选择子版本/发行版)，
2. 在 **Architecture** 处选择 **x86 64-bit或ARM 64-bit** (前者是一般的amd64/x86-64架构，后者是ARM架构。)
3. 在**Java Package**选择「JRE」或「JDK」(如果有需要的话，可以选择带有FX字样的体积更大的选项。它附带JavaFX支持)
4. 在**Java Version**选择您需要的版本(Java17/Java8)。如果右侧的**Include Older Versions**开关没有开启，这里则不会显示用于1.17的Java16，或其他非LTS版本.

:::tip

请前往系统设置确认您的处理器架构，或借助LauncherX的判断: x64架构无法运行ARM架构版本LauncherX，而ARM架构LauncherX可能可以运行x64架构版本LauncherX，但是会有明显的警告.

:::

在您每一步的筛选器操作结束时，该页面的可用下载列表都会依据您的条件更新.

一般而言，建议您选择列表最开头的项目 (只要您严格地完成了系统和架构选择)。在您打算下载的项目右侧的 **Download** 按钮中选择 `.zip` 格式的运行时并点击，等待下载完成后将其解压到任意一处本地文件夹 (最好新创建一个).
随后在 LauncherX 中选择 **搜索Java**。如果搜索不到您新解压的JRE，请点击**手动添加**，并选择刚才解压的文件夹 **bin/** 目录下的 **java** 可执行文件即可  (对于Windows，如果开启了**显示已知文件扩展名** ，则您要选择的项目名为java.exe)。

## 使用LauncherX内置的下载 (Windows x64)

::: warning 正如前文所说...

「在LauncherX的“设置-全局游戏设置-启动设置-资源下载” 中提供了几个版本基于x64平台的JRE下载。这些下载是由Mojang选择的用于游戏的JRE，一般都是来自OpenJDK的构建。但是，目前(2024-03-17)为止，Mojang尚未为ARM平台选择JDK。因此，对于ARM平台用户或想要通过更换JRE来优化游戏的用户，我们建议使用Azul Zulu JDK，因为它是面向服务端优化的版本，应对高频内存I/O、高负载计算时能有更好的性能，且都有面向ARM平台(aarch)的构建可供下载。」

如果你的设备当前运行的操作系统并非Windows x64，请回到本文最开始的地方。这部分的内容不适合你的设备。

:::

1. 在LauncherX的【设置-全局游戏设置-Java虚拟机设定】中找到【资源下载-下载Java】按钮，点击它。
2. 在弹出窗口中选择你要下载的Java，选中后，弹窗会提示你这个Java适合哪些版本的游戏。
3. 点击【添加】，稍等片刻直到下载完成。

* 正常情况下，下载完成后的Java会被自动发现并添加到LauncherX的Java列表中并可供选择。如果不知道需要哪个版本的Java，可以试着启动游戏，如果确实缺失对应版本的Java，LauncherX会发出警告，在警告弹窗中可以看见需要的Java版本。

***

###### 参考更多相关文章

* 来自NitWikit：[选择、下载和安装 Java | 笨蛋 MC 开服教程 (yizhan.wiki)](https://yizhan.wiki/NitWikit/preparation/choose-and-download-and-install-java)

---

---
url: /zhCN/mc-starter/advanced/analyze-exception.md
---
# 专题：游戏崩溃/异常分析

游戏是计算机程序的一种。如果游戏出现了崩溃，那么你可能需要自行分析问题。你可能很会请求其他人的帮助，但是倘若只能靠自己，那么唯一的希望就是自己的能力了。所幸计算机的一切异常都是有迹可循的。手上拿着足够的线索，便能分析出异常的原因，从而解决问题。

本专题包含数篇转载和原创的文章，以及一系列的相关扩展阅读。只要你有激情，有着学习理解的能力，那么你便具备着克服一切困难的能力。

参见：[什么是日志？ | 笨蛋 MC 开服教程](https://nitwikit.8aka.org/start/basic/what-is-log) | [如何向大佬求助 | 笨蛋 MC 开服教程](https://nitwikit.8aka.org/start/ask-for-help)

---

---
url: /zhCN/lxguide/features/dashboard.md
---
# 仪表板

:::info TIP

这个功能只在登陆后显示。为此您需要登陆日冕账户。详情参见: [启动器账户](/zhCN/lxguide/settings/item/lx-account)

:::

仪表板是一个信息聚合的场所。在这里整合了一个全局搜索组件(WIP) 和当前Minecraft版本追踪组件，关于您系统资源和游戏时长的图表，以及来自官方的新闻瀑布流。

## 全局搜索和版本追踪

#### 全局搜索

:::warning

笔者相信，这个功能仍然有很大的发展空间。您倘若有相关建议，请先参考[反馈帮助](/zhCN/lxguide/report-issue)。感谢热心市民的帮助!

:::

这个搜索组件目前可以调用您的默认浏览器的默认搜索引擎搜索您输入的内容.

#### 版本追踪

这个组件追踪了Minecraft自发售至今已经度过的昼夜，以及已经发布的版本数量。另一侧展示目前最新的正式版和快照版本号。

## 系统信息

左侧图表展示您电脑目前已经使用的运行内存量追踪;

右侧图表展示您电脑目前的CPU用量追踪.

## 游戏信息

两侧的图表均展示了游玩的游戏已经追踪的时长.

## 新闻

来自Minecraft官方和其他信息源的新闻，以瀑布流的形式展示.

---

---
url: /zhCN/lxguide/features/tricks/set-task-queue.md
---
# 任务中心队列机制 -- 为什么我不能同时跑三个以上的游戏？

LauncherX使用一套独特的并行任务管理机制，使得启动器在有完整的对游戏状态监控的同时，处理其他事务。

鉴于使用LauncherX的设备性能可能参差不齐，而同时运行大量任务可能带来卡顿，所以我们**暂未**在设置中留下任务并行数量的明确设置。这个设置的默认值为3。

如果您觉得自己的设备具备强大的并行能力，只需要遵循以下步骤，来按需调整并行量：

1. 关闭LauncherX（可选），前往LauncherX目录  （这个目录是与默认游戏目录和`LauncherX.json`处于同一级目录的）
2. 在其中新建文件，命名为`SET_TASK_QUEUE_SIZE`，不要给它留下后缀名
3. 用喜欢的文本编辑器打开它，并且输入一个你需要的并行数量的阿拉伯数字，不得填入除了数字以外的任何其他字符
4. 重新打开LauncherX，即可应用新指定的并行任务数量设置。

---

---
url: /zhCN/CMFS/servers/project-lappland/story.md
---
# 作为RPG - 故事背景

---

---
url: /zhCN/lxguide/settings/item/global.md
---
# 全局游戏设置

:::tip

这里是标签为「全局游戏设置」的分类下的设置项目。在这里您可以满足最基本的游戏启动设置需求，每一项设置在**具体的游戏**中若有特别的设置，将不会生效。详见: [版本隔离与独立设置](/zhCN/lxguide/settings/special/independent-config)

:::

\[\[toc]]

## Java虚拟机设定

*选择全局使用的Java，下载、搜索、管理Java运行环境*

###### **在账户页面固定账户**: `开关` | 默认:关闭.

开启此选项后，您在[账户管理](/zhCN/lxguide/settings/special/manage-accounts)页面**选中**的账户将被视为固定的账户，并在您点击任意一个地方的启动按钮时作为默认的账户来启动，并不会询问选择哪个账户来完成启动。开启后,主界面固定游戏的启动按钮后会有一个标签显示当前固定的用户名; 而游戏列表中的启动按钮将会在您的鼠标悬浮在其上的时候显示为您固定的用户名.

###### **Java路径**: `组合设置`

包含: 展示路径的选择框、`重新检查Java可用性`按钮；`重新搜索`、`深度搜索 (仅Windows)`、`手动添加`按钮:  使用选择框来选择一个全局使用的JRE以供启动。每一条项目均为被搜索到的Java，并且依次显示了「LauncherX对该Java可用性的判断」、「Java版本」、「该Java的完整路径」。选中的Java将使用主题色高亮显示，其版本信息将在选择框收起的情况下于下方并排着的2或3个按钮的下方可见.

**对于代表可用性的图标，有*四种可能*:**

* **** : 代表这个Java是完整可用的，并且适合您的操作系统;

* **** : 代表这个Java存在问题，不建议使用它。通常可能是因为架构和当前系统不符(arm架构使用x64版本JRE、x64使用x32JRE都会使游戏体验大打折扣);

* **** : 代表这个Java已损坏，或者LauncherX无法识别这个Java(如果您为了启动1.7.0以前版本的游戏而使用Java7，则可以忽略LauncherX的判断)。您可以使用下方的**下载Java**按钮来下载一个Mojang官方选择的适用于amd64架构的JRE，或者自行下载安装一个新的JRE。  详见: \[[下载合适的JRE](/zhCN/lxguide/others/download-jre)];

* **** : 代表正在或此时无法或暂时没有运行对该Java的检查。无论如何您都可以通过选择框右侧的按钮来发起检查;

无论何时您都可以无视LauncherX的判断，但是使用LauncherX不认可的JRE有可能严重破坏您的游戏体验。由于我们的Java运行时检测机制是通过 “搜索-执行” 模式工作以确认该运行时是否可用，所以在您启动LauncherX时候，可能会遇到来自Java的错误弹窗。——您完全可以直接将它关闭，因为这并不影响LauncherX运行；且如果您没有选择任何一个被LauncherX判断为有问题的JRE作为游戏启动所使用的Java，那么您的游戏启动几乎不可能受到受损JRE的影响。由于每次LauncherX启动都会检查搜索到的JRE是否可用，因此您应该将该受损的运行时**移除**，或者用自动化窗口关闭工具（比如 火绒弹窗拦截）对错误弹窗进行精准打击。

如果您需要LauncherX不再显示某个特定的JRE，请点开选择框，右键点击包含那个JRE路径的项目，点击「排除」。

:::info 对于非Windows用户，在手动添加Java时，您可能需要注意赋予LauncherX足够的权限。

不建议直接用管理员命令启动LauncherX。macOS用户若不得不使用SUDO启动LauncherX，则请使用命令:

```bash
sudo open  <LauncherX.app的路径，可以拖入app包文件到终端窗口中来填充路径>
```

***

“下载Java” 按钮、“查看CSKB文章” 按钮(仅在ARM架构系统中可见):

前者可以选择下载一个Mojang官方选择的适用于amd64架构的JRE，或者自行下载安装一个新的JRE。  详见: \[[下载合适的JRE](/zhCN/lxguide/others/download-jre)]

在这个设置项下方有一串文字用于显示LauncherX对选中的运行时的判断。比如: **该Java运行时(17.0.1)匹配您的系统**

:::warning 意外

如果那里显示了类似`picked JAVA_OPTS="xxx"`的文字，请在环境变量中寻找名为`JAVA_OPTS`的环境变量并删除，然后注销或重启系统。这可能是其他启动器创建的临时项目.

:::

## 游戏通用设定

*游戏内存大小、垃圾回收、窗口分辨率、JavaAgent参数、高级启动参数*

###### **内存大小**: `正整数` | 默认: 1024 | 单位: MB

在这个设置项的下方有较为明了的内存占比图示。基于您选择的LauncherX主题色，较深色的代表您电脑未被使用的内存量，较浅色的代表您电脑已被包括LauncherX在内的其他程序占用的内存量。

剩余一部分则是您全局分配给游戏的内存量在装机内存的总量中的占比。请注意，如果您分配的内存超出了空闲内存量，那么横条下方**空闲内存的实际数量将会显示为负数** (较新版本LauncherX将在内存超额的情况下使输入框的背景色呈淡红色)。

此外，针对不同版本的游戏，有不同的建议的内存大小。若内存分配量小于512(1.15.2更早版本游戏) 或小于1024 (1.15.2 ~ 1.17.x) 或小于1500 (1.18.x+)，都会带来游戏体验变差，甚至导致游戏无法启动。

::: info 关注电脑内存用量

错误的内存分配也会带来未知错误。同时，针对Mod和材质、光影包，应适量针对性地增加内存分配。  相关阅读: [配置内存和GC、JavaAgent](/zhCN/lxguide/others/adjust-ram-gc-ja)

:::

***

###### **游戏窗口设置**: `组合设置`

* 游戏窗口标题：`文本输入框` | 默认：空

  用于修改游戏窗口的标题。
  :::tip 可用占位符

  通过使用这些占位符，可以在窗口标题中动态显示一些信息：

  * `%account%`：当前游戏启动用户名
  * `%launch_time%`：启动时的时间
  * `%game_name%`：所启动的游戏名

  :::

  ***

* 窗口大小: `正整数` × `正整数` | 默认: 0 × 0 | 单位: ppi?

  当此值为默认值 (即 0 × 0) 时，窗口大小将由游戏决定。

  ***

* 全屏: `开关` | 默认: 关

  这决定了游戏是否在启动时就以占满全屏幕的形式展现。
  请注意: 在游戏的全屏状态下 (而不是系统的全屏方案)，有些系统功能可能不可用 (比如Windows的系统截屏) 或出现异常表现 (如macOS可能出现退格键清除中文输入法候选时导致已输入内容被意外删除，或鼠标指针无法在游戏中隐藏)。

  ***

###### **GC设置和高级参数设置**: `组合设置`

* **启用GC**: `开关` | 默认: 开 | 控制垃圾回收器 (GarbageCollector) 启用与否

  建议保持开启状态。

  游戏在运行时候产生的不需要的内存借助GC进行清理和空间回收，籍由此来让内存利用更高效。除非您有开发者级别的必要的特殊需求，否则不建议关闭它.

  ***

* **GC类型**: `选择框` | 默认: G1GC

  LauncherX提供了几个常见的垃圾回收器可供选择。对于如何选择，参见: [配置内存和GC、JavaAgent](/zhCN/lxguide/others/adjust-ram-gc-ja)

  ***

* **Java虚拟机高级启动参数**: `文本输入框` | 默认: \[空]

  额外的启动参数。您可以参考 \[[优化配置: 启动参数](/zhCN/lxguide/others/args)] 作为指引.

  ***

* **JavaAgent设置**: `文本输入框`:路径 `文本输入框`:额外参数 | 默认: \[空] \[空]

  一般用户基本用不上它。这是JVM提供的一系列调试接口。参见:  [配置内存和GC、JavaAgent](/zhCN/lxguide/others/adjust-ram-gc-ja)

***

###### **启动后加入服务器**: `设置` | 入口

点击“管理服务器”按钮 进入对应的管理界面。详见: [功能: 服务器管理](/zhCN/lxguide/features/manage-server)

## 启动器行为

*游戏资源检查、原生库替换策略(ARM)、启动后行为、日志记录*

###### **检查游戏文件**: `开关` | 默认:  开

将在游戏启动的时候检查游戏的资源文件。如果您需要修改原版游戏的资源文件，相比于关闭此选项并直接修改assets，我们更建议您以资源包的形式覆盖。

***

###### 资源补全最大重试次数: `正整数` | 默认：3 | 取值范围：`1~10`

拖动以修改值。

当资源补全遇到个别任务失败，允许重试的最多次数。在网络条件较差的环境下，越高的重试次数将会提升补全完成后资源绝对完整的可能性。重试补全将花费额外的时间。

***

###### **使用快速资源检查**: `开关` | 默认: 开

通过更激进的优化算法来节省启动前检查时间。

***

###### **补全游戏文件时检查文件完整性**: `开关` | 默认:  开

在补全游戏资源文件的时候检查文件完整性。如果网络可能存在波动，则这个功能可以很好地确保下载文件的完整性，并降低游戏时出现故障的概率.

***

###### **原生库替换策略**: `选择框` | 默认: LegacyOnly

这个设置仅在ARM设备上可见，用于控制LauncherX在ARM设备上优化游戏体验的行为。有以下可选值:

* LegacyOnly: 仅对较老的不携带ARM版游戏支持库的游戏进行库文件替换。
* All: 对所有游戏使用原生库替换，即使游戏携带了ARM版支持库.
* Disabled: 对所有游戏都「**不**」使用原生库替换，即使是不携带ARM版支持库的游戏。(建议仅在替换后游戏出现问题的情况下使用此项目。)

较老版本的游戏不携带ARM版本运行库。为了尽可能发挥ARM设备的性能，可以使用支持ARM的游戏支持库 (LWJGL等)

***

###### **游戏启动后启动器行为**: `选择框` | 默认: 最小化

选择让LauncherX主窗口和其他窗口 (除了日志窗口) 在一个游戏启动后的行为: 是“保持原状”、“最小化” 还是 “直接退出LauncherX”

***

###### **资源检查最大并行程度**: `选择框` | 默认: 4

在执行资源检查时同时进行的检查数量。可选值: 1、2、4、8。更多的数量将会占用更多的CPU资源，请根据您的CPU参数配置进行调整.

***

###### **启动游戏时显示输出日志**: `开关` | 默认: 开

在启动游戏时是否显示游戏的日志窗口。详见: \[[日志窗口功能介绍](/zhCN/lxguide/features/log-window)]

***

###### **启动器日志记录等级**: `选择框` | 默认: Error

可选(整体详细程度从高到低): All(全部输出)，Unknown(未知来源)，Debug(调试信息)，Info(一般信息-包括游戏内聊天信息)，Warning(警告)，Error(错误)，Fatal(致命错误);  Stacktrace(仅: 输出异常的完整溯源信息)，ExceptionMessage(仅: 输出异常的名称/和简单描述)(?)

:::info 关于日志窗口

日志窗口展示的最低等级。越低的等级会显示得越详细.

[了解更多关于日志窗口的信息](/zhCN/lxguide/features/log-window)

:::

---

---
url: /zhCN/lxguide/settings/special/customize-launcher.md
---
# 关于个性化LauncherX外观的一些提示

::: tip 遇到个性化问题了吗？

背景图片换上之后，按钮难以看到？还是一通操作之后发现自己的个性化方案性能开销过大？这里将 就**当前（2024年7月24日）** LauncherX存在的一些个性化上可能有点难以理解的问题进行解答。

:::

\[\[toc]]

## 背景图片导致的问题

背景图片可能导致窗口内部分组件辨识度变差。您可以依照以下思路寻求最优解：

* 【设置-外观-基础设定】禁用 “在主界面隐藏底部导航条”：以确保导航条的内容的可见度
* 【设置-外观-基础设定】尝试更多 “主界面前景文字颜色” 的选择：不同颜色的文字可能在启用背景时有更好的效果，自动选择可能不总是最优选择。
* 【设置-外观-背景】启用 “通过渐进式模糊优化上层文字显示效果”：将会在图片上应用一种模糊效果，借助模糊来衬托文字和其他元素。
* 【设置-外观-背景】尝试更多 “渐进式模糊效果强度” 的选择：调整这项设置以期寻求最佳的背景图片与主界面元素之间的平衡。
* 【设置-外观-背景】启用 “显示上层文字阴影”：尝试启用或禁用此项来调整文字自身的显示效果
* 【在其他图片调整软件中】调整图片的饱和度、亮度、对比度等参数：从根本上解决问题。毕竟并不是所有图片在一开始都是适合作为背景的。记得做好备份。

## 半透明类背景导致的问题

::: warning 关于Mica材质背景

这种背景也算是一种半透明背景，但是仅在Windows11上可用。

:::

半透明背景由于涉及实时计算，故可能存在以下问题：

* 可能需要有兼容的显卡驱动以供功能正常可用
* 如果频繁变更LauncherX窗口的位置或其背后的显示内容，将会额外增加不少的系统资源占用。

此外，在进行截图的时候，请留意半透明背景后方是否包含敏感信息。

## 渐进式模糊性能问题

### 1) 渐进式模糊不生效

前往【设置-外观-性能】，找到 “清理渐进式模糊缓存”，点击重置，然后尝试重启LauncherX

### 2) 渐进式模糊性能太差或模糊质量太低

前往【设置-外观-性能】，找到 “背景图片渐进式模糊质量”，选择更高或更低的选择，然后如有必要的话，重启LauncherX

## 透视效果和动画效果性能问题

若您的电脑在渲染动画时候较为吃力，可以依照现实情况尝试以下操作：

* 【在系统电源设置中】关闭省电模式：省电模式将会降低电脑的性能

* 【在电脑的固件设置中】尝试提升CPU和GPU的频率：通过 “超频” 行为，更高的频率会在一定程度上优化渲染效果和速度

  ::: danger 危险！这么做的话，您应该知道您自己在做什么

  超频行为可能会导致您的硬件保修失效，或是给电脑稳定性造成负面影响，甚至造成硬件损坏。这些都属于您的个人行为，您完全没必要这么做，因而您的个人行为造成的任何损失均不由我们负责。

  :::

* 【关闭动画】关闭动画：如果您不需要LauncherX动画可以将其关闭。参考：[禁用动画 | 日冕知识库](/zhCN/lxguide/features/tricks/disable-animation)

* 【其他】尝试更新显卡驱动：可能新的显卡驱动包含动画渲染方面的优化

* 【其他】升级硬件配置：如果可以的话。

---

---
url: /zhCN/lxguide/others/args.md
---
# 其他

这里存放着一些解释文字的文字，和一些特性说明等其他内容。

---

---
url: /zhCN/lxguide/others.md
---
# 其他

这里存放着一些解释文字的文字，和一些特性说明等其他内容。

---

---
url: /zhCN/lxguide/startup/others.md
---
# 其他

这部分存储了一些针对特殊问题的特殊声明...

---

---
url: /zhCN/lxguide/settings/item/others.md
---
# 其他设置标签页

:::tip

这里的内容相对而言没那么重要。更新日期: 2025年2月10日.

:::

\[\[toc]]

## 关于

这里展示了直接参与LauncherX制作的人员名单、工作室简介和开源项目使用列表，以及LauncherX及其相关组件的版本号.

## 赞助者

:::warning

此条目编辑于2024年2月10日，在可预见的将来，此处的内容很有可能迎来改变。相关阅读: [切换更新通道](/zhCN/lxguide/others/switch-channel.html)

:::

对于LauncherX项目的赞助，目前我们主要依赖**爱发电**平台。 此页将会展示最近24小时内最新提供赞助的赞助者 (约30位，排名不分先后)

您也可在官网登陆后于 [赞助 - 日冕工作室](https://corona.studio/donate) 通过微信或支付宝来向我们打赏。但是您的赞助将会只被我们记在心里(x).

感谢每一位赞助者对LauncherX项目的支持!

:::tip

网站中通过微信/支付宝赞助过后，您将自动被赋予使用LauncherX预览通道的资格。而爱发电用户需要在爱发电平台内联系老腊肉，然后提供您注册日冕账号的邮箱，等待他为您开启资格。如果他没回应，或是没有被自动赋予内测资格，您也可[加群](/zhCN/guide/contact.html)或向他[发邮件](mailto:luolinrui726@outlook.com)来催促.

:::

---

---
url: /zhCN/lxguide/others/switch-channel.md
---
# 切换更新通道

LauncherX具备多个更新通道和发行分支。

::: warning 现在还不是时候…

截至目前（2025年2月9日），LauncherX现在实际存在差异的通道只有2条：Stable和Higgs。

:::

\[\[toc]]

## 更新通道

LauncherX在设计时存在这些更新通道：

* Stable (Atom) - 最慢，最稳定，平均1到2个月更新一次。允许用户不登陆使用。
* Proton - \[*暂不可用*] 次慢，次稳定，平均每20天更新一次。必须登录使用，但是无需内测权限。
* Neutrino - \[*暂不可用*] 次快，不稳定，平均半个月更新一次。必须登录使用且需要内测权限。
* Higgs - 最快，最不稳定，但是部署修复最快，高峰时期一天可能更新七八次。必须登录使用且需要内测权限。

## 如何切换

从官网下载的即是当前最新版本的稳定版。在稳定版中登录日冕账户，即可在【设置-启动器账户-先导版本体验设置】选择 **更新通道** 和 **发行分支**。在选择后，点击保存即可获取对应渠道最新版本的LauncherX以供更新。如果提示失败，请确认自己有对应的权限。[前往官网主站 登录到服务](https://corona.studio/auth/login)即可查询，如果有【荣誉股东】标记则是有权限。

## 获取内测权限

LauncherX是一个以社区驱动为主的启动器，在启动核心、文档（CSKB）、语言本地化和资源翻译等领域接受来自社区的为爱发电。包括赞助在内，这些都是支持LauncherX及其他项目的表现，为此我们除了感激，只能报以在多方面与我们深入交流的**内测权限**等特别权利。这些接受贡献的项目由我们一起构建，我们一起将这些美观实用的趁手工具带到现实之中，感谢社区中每一位热心市民的贡献。

以下是可以获取内侧权限的方法（均需要登录状态正常的CSA日冕账户，可能需要提供账户对应邮箱）：

* 在LauncherX资源纠正计划 /「简明资源信息数据库」计划中累计成功贡献50次（提交50次通过审核的有效贡献），即可联系我们获取内测权限。
* 在我们的任意公开多语言仓库中贡献，维护完整的至少一门语言，即可联系我们，提供自己的日冕账户邮箱以获取内测权限。
* 向我们的公开项目仓库提交有效的Pull Request，在我们接受后即可联系我们获取内测权限。
* 加入我们，和我们一起构建，可以获取内测权限。
* 在稳定版率先发现重要bug（即，[MineBBS平台上的更新日志](https://www.minebbs.com/resources/launcherx.7182/updates)中没有写在**已知问题**那一栏的问题）并反馈给我们并得到认可，即可索取内测权限。
* 向我们赞助任意可接受金额，即可获取内测权限（赞助需要登录到官网主站后通过[赞助页面](https://corona.studio/user/sponsor)来完成。具体操作指引请参考：[赞助我们！](/zhCN/guide/general/donate.html)）
* 其他被我们认定是贡献行为的，我们会主动联系您以开通内测权限。  谨防诈骗！

::: warning 意外

很遗憾，目前（2025年2月10日）由于我们的服务器部署在海外，被支付平台屏蔽，所以**我们不再接受微信/支付宝赞助**。请直接通过爱发电和我们的官网进行赞助打赏和账户绑定，详见：[赞助我们！| 如何绑定订单号 | CSKB](/zhCN/guide/general/donate.html)

目前只有老腊肉有修改权限状态的能力。他可能与在中国大陆的各位存在时差。（2025年2月20日）

:::

::: danger 谨防诈骗！

 我们主动联系您开通权限时不会向您索取任何转账或验证码等信息！谨防诈骗！目前仅有**老腊肉**和**法棍**可能会主动联系用户开通权限，如果遇到信不过的人以给予权限为由和您联系，截屏并前往 LauncherX交流群 询问一下总是没错的。谨防诈骗！（相关阅读：[通用隐私政策和最终用户许可协议#免责声明 | 日冕知识库](/zhCN/geula.html#_3-免责声明) # [指路官方 | 日冕知识库](/zhCN/guide/contact.html) # [加入我们吧! | 日冕知识库](/zhCN/guide/joinus.html) # [我们的团队 | 日冕知识库](/zhCN/guide/team.html)）

:::

---

---
url: /ruRU/projbobcat/resourceCompleter/createAndConfigCompleter.md
---
# 创建和配置补全器

\[\[toc]]

## 初始化补全器

创建一个资源补全器的方法非常简单, 您只需要使用下面的代码即可完成补全器的初始化：

```c#

var completer = new DefaultResourceCompleter
{
    MaxDegreeOfParallelism = [MAX_DEGREE_OF_PARALLELISM],
    ResourceInfoResolvers = new List<IResourceInfoResolver>
    {
        ... // 资源信息解析器的初始化
    },
    TotalRetry = [NUMBER_OF_TOTAL_RETRY],
    CheckFile = [CHECK_FILE_AFTER_DOWNLOADED],
    DownloadParts = [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE]
};

```

::: tip

资源信息解析器的初始化相关教程请参见 [资源信息解析器](/ruRU/projbobcat/resourceCompleter/resourceInfoResolver/index) 章节

:::

在上述代码块中, 请将这些参数按照您的实际情况替换：

|                    项目                    | 数据类型    |              说明              |
|:----------------------------------------:|:--------|:----------------------------:|
|       \[MAX\_DEGREE\_OF\_PARALLELISM]        | INT     |    资源检查并行程度（同时检查游戏资源的数量）     |
|      \[CHECK\_FILE\_AFTER\_DOWNLOADED]       | BOOLEAN |  在文件下载完成后检查文件完整性（如果存在资源校检码）  |
| \[TOTAL\_DOWNLOAD\_SEGMENTS\_FOR\_LARGE\_FILE] | INT     |         大文件下载时的分片数量          |

::: warning

**\[MAX\_DEGREE\_OF\_PARALLELISM]** 和 **\[TOTAL\_DOWNLOAD\_SEGMENTS\_FOR\_LARGE\_FILE]**
的数值大小请视硬件性能酌情调整, 设置过大的数值可能会导致会导致吞吐量的下降.

:::

## 补全游戏资源

在完成资源补全器的初始化操作后, 您只需要调用补全方法即可开始执行检查和补全操作：

在异步上下文中, 使用 **CheckAndDownloadTaskAsync** 来完成安装：

```c#

var result = await completer.CheckAndDownloadTaskAsync(); // [!code focus]

if (result.TaskStatus == TaskResultStatus.Error && (result.Value?.IsLibDownloadFailed ?? false))
{
    // 在完成补全后, 资源检查器会返回执行结果. 
    // 您可以检查 result 中的属性值来确定补全是否完成
    
    // IsLibDownloadFailed 会反映启动必须的库文件是否已经成功补全
    // 通常来说, 如果库文件的补全失败, 很有可能会导致游戏的启动失败
}

```

在同步上下文中, 使用 **CheckAndDownload** 来完成安装：

```c#

var result = completer.CheckAndDownload(); // [!code focus]

```

## 报告进度

在某些情况下, 资源补全器可能会需要数分钟的时间来完成资源的检查和下载.
因此, 您可能需要实时向用户汇报补全器目前的进度.

### 报告资源检查器的进度

您可以通过注册事件 **GameResourceInfoResolveStatus** 来获取实时的检查进度：

```c#

completer.GameResourceInfoResolveStatus += (_, args) => 
    { ReportProgress(args.Progress, args.Status); };

```

其中,  **args.Progress** 指示了检查器当前的百分比进度. **args.Status** 则是检查器当前进度的文字描述.

### 报告补全器文件下载进度

您可以通过注册事件 **DownloadFileCompletedEvent** 来获取实时的检查进度：

```c#

completer.DownloadFileCompletedEvent += (sender, args) =>
{
    // sender 参数为补全器上一个成功下载的文件, 类型为 DownloadFile
    // args 返回了该文件的下载状态（成功 / 失败）, 以及文件的重试计数, 
    // 类型为 DownloadFileCompletedEventArgs
};

```

::: tip

* [DownloadFile 类结构](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/DownloadFile.cs)
* [DownloadFileCompletedEventArgs 事件结构](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Event/DownloadFileCompletedEventArgs.cs)

:::

### 报告下载中的文件的进度信息

您可以通过注册事件 **DownloadFileChangedEvent** 来获取实时的检查进度：

```c#

rC.DownloadFileChangedEvent += (_, args) =>
{
    // args 返回了下载中的文件的具体信息（已接收的字节数、总共的字节数、当前速度、百分比进度）
    // 类型为 DownloadFileChangedEventArgs
};

```

::: tip

* [DownloadFileChangedEventArgs 事件结构](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Event/DownloadFileChangedEventArgs.cs)

:::

---

---
url: /zhCN/projbobcat/resourceCompleter/createAndConfigCompleter.md
---
# 创建和配置补全器

\[\[toc]]

## 初始化补全器

创建一个资源补全器的方法非常简单，您只需要使用下面的代码即可完成补全器的初始化：

```c#
var completer = new DefaultResourceCompleter
{
    MaxDegreeOfParallelism = [MAX_DEGREE_OF_PARALLELISM],
    ResourceInfoResolvers = new List<IResourceInfoResolver>
    {
        ..。// 资源信息解析器的初始化
    },
    TotalRetry = [NUMBER_OF_TOTAL_RETRY],
    CheckFile = [CHECK_FILE_AFTER_DOWNLOADED],
    DownloadParts = [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE]
};
```

::: tip

资源信息解析器的初始化相关教程请参见 [资源信息解析器](/zhCN/projbobcat/resourceCompleter/resourceInfoResolver/index) 章节

:::

在上述代码块中，请将这些参数按照您的实际情况替换：

|                    项目                    | 数据类型    |              说明              |
|:----------------------------------------:|:--------|:----------------------------:|
|       \[MAX\_DEGREE\_OF\_PARALLELISM]        | INT     |    资源检查并行程度（同时检查游戏资源的数量）     |
|      \[CHECK\_FILE\_AFTER\_DOWNLOADED]       | BOOLEAN |  在文件下载完成后检查文件完整性（如果存在资源校检码）  |
| \[TOTAL\_DOWNLOAD\_SEGMENTS\_FOR\_LARGE\_FILE] | INT     |         大文件下载时的分片数量          |

::: warning

**\[MAX\_DEGREE\_OF\_PARALLELISM]** 和 **\[TOTAL\_DOWNLOAD\_SEGMENTS\_FOR\_LARGE\_FILE]**
的数值大小请视硬件性能酌情调整，设置过大的数值可能会导致会导致吞吐量的下降。

:::

## 补全游戏资源

在完成资源补全器的初始化操作后，您只需要调用补全方法即可开始执行检查和补全操作：

在异步上下文中，使用 **CheckAndDownloadTaskAsync** 来完成安装：

```c#
var result = await completer.CheckAndDownloadTaskAsync(); // [!code focus]

if (result.TaskStatus == TaskResultStatus.Error && (result.Value?.IsLibDownloadFailed ?? false))
{
    // 在完成补全后，资源检查器会返回执行结果。
    // 您可以检查 result 中的属性值来确定补全是否完成
    
    // IsLibDownloadFailed 会反映启动必须的库文件是否已经成功补全
    // 通常来说，如果库文件的补全失败，很有可能会导致游戏的启动失败
}
```

在同步上下文中，使用 **CheckAndDownload** 来完成安装：

```c#
var result = completer.CheckAndDownload(); // [!code focus]
```

## 报告进度

在某些情况下，资源补全器可能会需要数分钟的时间来完成资源的检查和下载。
因此，您可能需要实时向用户汇报补全器目前的进度。

### 报告资源检查器的进度

您可以通过注册事件 **GameResourceInfoResolveStatus** 来获取实时的检查进度：

```c#
completer.GameResourceInfoResolveStatus += (_,  args) => 
    { ReportProgress(args.Progress,  args.Status); };
```

其中， **args.Progress** 指示了检查器当前的百分比进度。**args.Status** 则是检查器当前进度的文字描述。

### 报告补全器文件下载进度

您可以通过注册事件 **DownloadFileCompletedEvent** 来获取实时的检查进度：

```c#
completer.DownloadFileCompletedEvent += (sender,  args) =>
{
    // sender 参数为补全器上一个成功下载的文件，类型为 DownloadFile
    // args 返回了该文件的下载状态（成功 / 失败），以及文件的重试计数，
    // 类型为 DownloadFileCompletedEventArgs
};
```

::: tip

* [DownloadFile 类结构](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/DownloadFile.cs)
* [DownloadFileCompletedEventArgs 事件结构](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Event/DownloadFileCompletedEventArgs.cs)

:::

### 报告下载中的文件的进度信息

您可以通过注册事件 **DownloadFileChangedEvent** 来获取实时的检查进度：

```c#
rC.DownloadFileChangedEvent += (_,  args) =>
{
    // args 返回了下载中的文件的具体信息（已接收的字节数、总共的字节数、当前速度、百分比进度）
    // 类型为 DownloadFileChangedEventArgs
};
```

::: tip

* [DownloadFileChangedEventArgs 事件结构](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Event/DownloadFileChangedEventArgs.cs)

:::

---

---
url: /zhCN/guide/joinus.md
---
# 加入我们吧!

::: info

此招募文档描述了目前我们需要的人手类型和其他您可能想知道的东西。

更新日期: 2024/4/3

审核群号: `1040526762`

审核规则见下页。(#)

:::

## 加入后可以得到什么…

首先，**权利与义务是对等的**。您若想享受加入后的权利，除了需要证明您有实力， 也需要履行作为成员的义务，才可以享受作为成员的对应权利。

加入我们后，您可以:

**如果您参与开发工作，您将会：**

* 获取源码控制的较高权限，按需访问团队在数年间积累下来的源代码和工具链。

* 有机会调用团队资源。

**如果您参与游戏相关工作（如CMF群组服）、 和开发的工作（如质量控制），您将能够：**

* 锻炼有关方面的能力，并积累实战经验。

**不论如何，您都可以：**

* 与组内菊苣深入交流，获得一些人生经验。

* 扩展人脉关系。

* 锻炼团队合作能力，提升团队合作意识。

* 在Minecraft社区中拥有获得认可的头街。

## 团队现在有什么需求?

**自带项目的大佬：**
我们欢迎任何人自带项目入群。如果您有一个想法却因没有人手或平台难以实现，那么加入我们吧！

**C#、Avalonia开发：**
熟悉C#的各类语法，对AvaloniaUI（至少WPF）以及**MVVM**有比较深刻的理解。对设计模式、算法优化、HTTP请求方面有开发经验。

**Minecraft服务器相关人员：**
包括服务器技术和建筑师等。对于运维人员，最好有Linux发行版系统终端的使用经验。

**文职人员：**
负责团队外宣、法律顾问等相关事宜，或对RPG服务器的故事编排为剧情，总之是偏向文科的文字工作。

**美工，CG：**
参与UI的设计和外宣图片等的绘制。CG人员主要负责服务器宣传片制作以及建筑渲染。如果有 Minecraft皮肤和材质等绘制能力那么也欢迎！

**吉祥物：**
\~~不需要什么技能，只要进管理群说说话就好。（如果可以的话，希望能够主动晋升为文职人员，或承担公众社交管理员的工作！）~~
如今的吉祥物必须承担社区管理工作或宣传工作。散发你的个人魅力，营造更有活力、更加健康的社区氛围！

*值得注意的是，我们并不要求在任何一方面拥有实战经验。本工作室提倡终身学习的精神，也希望成为一个实践的平台。*

## 我可以! 如何加入?

**首先，很高兴您能有与我们同行的自信！接下来您需要：**

* 加入团队的审核群（企鹅：**1040526762**）并且注明您的意向。
* 根据群文件**审核规则**展示自己的能力，并接受团队成员提问。
* 等待团队成员讨论后向您发送通知。
* 搞定！流程大约时长：20min左右。

*（内部人员人事处理可能耗时更久，我们的成员之间可能存在时差。）*

## 其他信息…

其他常见问题，您或许会关心的。

Q：我会因为年龄、性别等原因受歧视吗？
**A：当然不会！我们希望建立一个包容而有活力的群体，这也是我们没有年龄等自身因素限制的原因。**

Q：我能从中获得经济利益吗？
**A：如果您参与的项目有盈利性质，那么团队内部将按照贡献程度进行分成。**

Q：如果我因为学业（中考、高考等）而不得不脱离团队工作，会被踢出吗？
**A：当然不会。我们的理念之一就是终身学习，而学习的重中之重就是要以学校教学为先， 所以只要您在不得不脱离之前告知管理员即可，我们会为您留一年时间：若超过一年期限且没有返回报到，您或许会被要求停职并重新审核。您总共可以延长报到时限3次。 请注意，为了团队工作进度，在您告离期间，除了您领导的项目，我们会尝试让其他人接手您未完成的工作，直到您回来。**&#x6B64;外，我们希望您尽可能每日都能参与工作。但是如果受限于学业安排导致一周或一个月内能参与的时间有限 (且比较规律)，您完全只需要让我们知道一下，并且不需要暂停职位。具体安排需要视具体情况而定。

---

---
url: /zhCN/guide/standard/cskb-formula.md
---
`@useFixer`

# 单元组件

这里存放可以直接复制以供复用的组件。建议编辑人员遵守格式使用。

请尽可能跟随统一的全站风格！

相关阅读：[Markdown Extensions | VitePress](https://vitepress.dev/guide/markdown)

\[\[toc]]

## 版权声明

::: warning 我们对CSKB内容版权的管理

无论是转载还是原创，引起的版权纠纷均由该文章的上传者承担。

此外，如果引用内容受到跨域访问阻止，请自行解决。

:::

### 转载他人文章

如果转载他人撰写的、并非首发于CSKB的文章，**必须** 在开头一级标题后附上此段。

模板中存在可选的内容。使用时，在可选段中 **至少选择一个** 并删除表示可选的`?`问号。

:::warning 转载文章

本文是转载文章，<修改状态>。如果你觉得这篇文章不错并想要引用或转载，请根据这些信息联系原作者。

原作者：作者在原文的署名

引用链接?：[页面标题](#link)

引用文章?：<参考文献格式的简短信息>

许可证：<许可证>

转载信息上次更新于 <日期>

:::

解释：

* 修改状态：依据许可，在这里解释转载的文章`未修改`、`有少量修改`、`有补充和修改`。如果有修改或补充，建议将那一部分标记出来。

* 引用链接和引用文章：如果有引用链接，可以不写引用文章；如果有引用文章，引用链接可以不写，也可以标注原文所在书本的**官方**购买链接（非购物平台）、版权页面（实在没有就不写）

* 参考文献格式的简短信息：见[引用内容和参考文献](#引用内容和参考文献)。

* 许可证：允许的许可证有多种

  * 口头许可：

    * 公开口头许可：如果原文页面存在评论区，可以在评论区询问作者是否允许搬运到CSKB，你必须说明你要搬运到CSKB，例如：

      ```txt
      你好！这篇文章很棒，我能将它搬运/转载到知识库网站kb.corona.studio吗？
      ```

      在搬运的时候，要按照作者的要求进行搬运。此类许可证可以不标注在转载信息中。

    * 非公开口头许可：请求许可的过程与公开口头许可一致，只是转为通过私信原作者、给原作者发邮件来进行沟通。请保存好这类许可的原本证据。在`许可证`这一栏应填写指向许可截图的链接。

  * 公共许可证：无论是CC系列的共享许可证还是其他什么许可证，只需要在这里写明许可证的名称。当然也可以把许可证的公开链接附在名称上。

  * 购买许可：请向原作者索取许可凭证，按需插入链接指向凭证链接或凭证的截图。可以参考上文中【口头许可-非公开口头许可】的方式。

* 日期：成文的日期。你的实际文章公开时间是可查询的，因为CSKB合并分支的时候会留下记录。

### 非成员的作者声明

如果提交文章者并非Corona Studio的成员，首先，非常感谢您的无私贡献！但是我们建议您额外进行一些操作以保护您的权利，比如在**一级标题**后添加以下内容作为版权声明。

*如果您是从其他平台复制了这篇文章到CSKB，那么这段声明也适用。但是如果这篇文章并非您原创，而您却添加了这段标记，那么我们将会讨论对您的惩罚。请确保这篇文章为您的原创，并且妥善处理了一些可能引起版权纠纷的内容。*

::: info 原创文章

这篇文章由 `<作者名称>` 原创。<联系方式>

许可证：<许可证>

成文于：<日期>

<其他内容>

:::

解释：

* 作者名称：您活跃在圈子里用的昵称，或者其他能代表您本人的名字。
* 联系方式：可选，如果您希望读者能与您联系，请在这里留下合适的联系方式，您当然可以选择不填。
* 许可证：您可以选择在这里填入CC系列共享许可证，或是其他能指向许可证的链接，或是`禁止转载`、`未经许可禁止转载`这类文字声明。
* 日期：写完这篇文章时候的日期 。
* 其他内容：可以在这里写一些其他补充文本。建议不多于100字。

## 警告

### 未能及时更新内容

如果对应的软件服务发生了更迭但是文章内对应的信息并未来得及修改，可以添加这个标记以警告读者。

::: danger 内容过时

本文内涉及到的部分信息过时，可能与最新的情况不符。

<在这里可以写涉及的内容是哪些，或是一个文章内子标题列表>

:::

### 内容施工中

如果规划了一整篇文章但是碍于各种原因需要在部分内容未完成的情况下立刻部署提交大部分文章，务必添加类似如下的提示：

::: info WIP

内容施工中。

:::

### 内容准确性存疑

如果认为文章内存在未被核实的内容或不确定的言论，可以在文章的 **开头一级标题后** 和 **文章中任意位置** 添加这个标记。

::: warning 存疑

部分内容真实性或准确性存疑，但是为了表述文本，仍然展示了存疑的内容。

<有必要的话可以写免责声明>

<这里可以将存疑的部分和疑点写下>

::: details 疑点

<如果内容太长可以写在折叠框里>

:::

## 引用、更新与勘误记录

此类记录类文本可以直接使用无序列表置于文末。如果太长，可以使用`details`块来收折。这里的内容仅供参考，你可以按照 “太长就收折，一个也不能少” 的原则自由发挥。

### 引用内容和参考文献

写在列表里的参考文献信息必然不能像写json似的写得很详细，所以建议使用这样的格式一行写完。

::: warning Oops！
由于在统一全站的句号和逗号期间半角逗号加空格的组合被替换为了全角逗号，请在书写参考文献内容时依照语言使用对应的标点符号。
:::

```
文章，书名，作者，出版社（或平台），年份（或版次）

比如：
Программирование на MySQL，«Программирование на MySQL»，Алексей Калинин，ДМК Пресс，2020
```

对于一段三行的引用列表，可以这样写：

* Database Normalization Description，Microsoft Learn: Microsoft 365 troubleshooting by helenclu，simonxjx，venusmi，dariomws，MaryQiu1987; Microsoft，06.06.2024 (u)

* Программирование на MySQL，«Программирование на MySQL»，Алексей Калинин，ДМК Пресс，2020

* MySQL数据库入门，《Introducing MySQL Database》by 传智播客，清华大学出版社，01.03.2015

:::tip 参考文献

* Database Normalization Description，Microsoft Learn: Microsoft 365 troubleshooting by helenclu，simonxjx，venusmi，dariomws，MaryQiu1987; Microsoft，06.06.2024 (u)

* Программирование на MySQL，«Программирование на MySQL»，Алексей Калинин，ДМК Пресс，2020

* MySQL数据库入门，《Introducing MySQL Database》by 传智播客，清华大学出版社，01.03.2015

:::

### 更新记录

如果一篇文章需要记录每一次更新的内容，建议将其收折。比如：

::: details 更新记录

2025年1月14日：更新内容需要简短

2025年5月14日：也可以在更新内容中加入链接

2025年8月10日：用于指向CSKB分支的提交记录

:::

### 勘误

勘误同样建议收折，但是如果前期内容很少，可以暂时不收折。比如：

::: details 勘误

* codingEric 提出了在 [标题](#) 处关于xxx的错误
* [Feiron Iguista](mailto:frigeso@icloud.com) 提出了关于[别的内容](#link-to-github-issues-or-somewhere-else)的错误
* ……

感谢以上热心市民！

:::

## 其他

### 为一个段落启用段前缩进

::: danger 老腊肉不喜欢

由于老腊肉不喜欢段前缩进，所以不要滥用。

目前根据我们的规则，只有简体中文、繁体中文、日语、朝鲜语是有资格启用段前缩进的。

启用段前缩进，需要满足以下条件：

::: details 启用条件

* 只能出现在教程类文档中，或前后文段密集、无法分割、长度较长并且与标题粘合紧密。
* 在上下文中，只能依靠段前缩进平衡视觉感。
* 在版面中需要通过段前缩进来整合视觉条理。
* 在vitepress中，受制于布局和版面设计，为很短小的文段（大多数情况下不能占满一行的那种）启用段前缩进将会很丑。请在尝试使用后通过热重载预览来进行参考和比对，最终在提交前确认是否要启用。
* 必须是使用中文汉字、日文、朝鲜文这类语言文字的文档中才能启用。

:::

如果要给个别段落启用段前缩进，首先要在文章上启用扩展功能。
在文档的最开头处添加：`@useFixer`即可启用扩展。
然后，你需要在此文章内的段落的末尾添加一个任意内容的`code`块，比如：

```markdown

这只是一个很短的段落而已，对于它而言不需要段首缩进。但是如果整个段落很长很长很长的话，或许为了视觉友好考虑，或是为了规整文字的调性、平衡视觉，我们可以启用这样的段前缩进。只需要注意，保证`code`块处于末尾，这样的话它会隐藏，而段首的缩进就会出现。`i`

```

它的效果如下：

这只是一个很短的段落而已，对于它而言不需要段首缩进。但是如果整个段落很长很长很长的话，或许为了视觉友好考虑，或是为了规整文字的调性、平衡视觉，我们可以启用这样的段前缩进。只需要注意，保证`code`块处于末尾，这样的话它会隐藏，而段首的缩进就会出现。`i`

***

但是如果在这个code块后有其他文本内容，取消缩进将失效。比如：

```markdown

这只是一个很短的段落而已，对于它而言不需要段首缩进。但是如果整个段落很长很长很长的话，或许为了视觉友好考虑，或是为了规整文字的调性、平衡视觉，我们可以启用这样的段前缩进。只需要注意，保证`code`块处于末尾，这样的话它会隐藏，而段首的缩进就会出现。我们建议使用`i`作为标准的启用标签，这很合适，难道不是吗？

```

它的效果如下：

这只是一个很短的段落而已，对于它而言不需要段首缩进。但是如果整个段落很长很长很长的话，或许为了视觉友好考虑，或是为了规整文字的调性、平衡视觉，我们可以启用这样的段前缩进。只需要注意，保证`code`块处于末尾，这样的话它会隐藏，而段首的缩进就会出现。我们建议使用`i`作为标准的启用标签，这很合适，难道不是吗？

***

这意味着，正常的段落包含code块将不受影响。如果段末实在需要保留code块，请在段末添加一个标点符号。

::: warning 即便如此…

为了方便排查问题，尤其是在使用实时渲染编辑器的情况下（比如Typora），尽管任意段落末尾的code块都会被视作启用此段的缩进，也请遵循语义化规范在块内书写类似于`make-indent`/`indent`/`i`这样的内容，便于辨别，而不要使用空格：在实时渲染编辑器中仅空格的code块可能难以辨认。

:::

---

---
url: /zhCN/guide/links.md
---
# 友情链接…

## 友链！

此处展示的友情链接仅限同类的知识共享型站点。与此同时，还包含了一些参考较多的文档站（可能是单向友链）

如果你认为你的站点是与我们并肩的好伙伴，欢迎与我们交换友链！查看[我们的联系方式](/zhCN/guide/contact)

*标注 `*` 的是单向，标注 `^` 的是因为各种特殊情况导致的暂时单向。*

## 赞助商

这里列举大力赞助我们的好心人，他们有自己的生意。

## 如何在这里展示？

首先当然是[联系我们！](/zhCN/guide/contact.html)

然后，说明来意：

1. 想要和 CSKB/官网 交换友链？让我们确认一下！只要我们互相是志同道合的，那么我们就可以交换友链。
2. 希望长期向我们提供赞助？太好了！感谢您的物质支持，只要是我们受得起的长期赞助，我们当然乐意照单全收（被打）

然后请等待在下一次网站更新，只有在确认通过后的下一次网站更新才会将我们珍贵的「合作者信息」登上相应的页面。

---

---
url: /zhCN/lxguide/others/adjust-ram-gc-ja.md
---
# 合理分配游戏内存、选择GC、配置JavaAgent

使用LauncherX启动，游戏即便不进行特殊配置也能通过一系列默认配置达到通常标准和环境下很优质的性能。但是，由于用户电脑环境变数过多，有时候您或许需要学会对您的游戏进行一些额外配置来让您尽可能地发挥电脑的性能.

:::warning 本文可能有较多纰漏

希望热心市民能够找到后反馈到邮箱: frigeso@icloud.com

:::

\[\[toc]]

## 分配内存

内存是程序运行的众多关键之一，分配足够的内存将有助于您的游戏流畅稳定地运行。此处介绍的内存分配仅包含计算机基本的运行内存，而不包括其他的缓存、虚拟内存或GPU内存(显存).

一般而言，内存分配与许多因素相关，比如: 游戏版本、资源包规格、JRE、模组和模组加载器。与此同时也受到一系列外部因素影响，比如: 硬件的装机内存量、启动游戏时尚在运行的程序的内存总用量、硬件内存性能等.

接下来将详细分析这些因素，希望能对您有所帮助.

### 游戏因素

#### 1) 游戏版本

对于不同版本的原版游戏，基础建议内存各不相同.:`< 1.15`: 建议512MB或更高`1.15 ~ 1.17`: 建议1024MB或更高`1.17 +`: 建议2048MB或更高

#### 2) 资源包规格

一般而言，根据贴图的分辨率不同(16x 32x 64x之类)，内存需求就会不同，因为贴图材质需要被加载到内存中，所以越大的材质加载到内存中，需要的分配的内存总量越大。光影包也是如此.

#### 3) JRE

一般来说，来自不同组织/公司的不同JRE构建之间都有所差异，因为它们都是为了不同的应用环境优化的，但是整体差别并不会太大。(仍然可能存在JRE不同导致的兼容性问题，但是出现在mod客户端的可能性更大) 不同JRE可能提供不同的优化特性，这些特性里有的功能可能需要提高LauncherX权限(管理员或超级用户)

比如，OpenJ9 JRE使用OpenJ9 JVM，整体占用偏低，调度相对保守，因而游戏可能无法完全利用好已分配的大额内存。但是对于硬件性能较差的电脑，可能可以保证游戏稳定运行.

Azul Zulu和Alibaba Dragonwell是面向云计算的JDK构建，因而在应对高并发任务时可以发挥相对更好的性能.

更详细的测试，参见: 蒸汽通量 在 知乎 的文章: [几张性能对比，让你明白高版本 Java 更适合 Minecraft](https://zhuanlan.zhihu.com/p/350543981)

当然，如果您实在搞不明白自己需要选择什么样的JRE，以下是我们的建议:

:::tip OpenJDK - OracleJDK(或Oracle官网下载的Java) - Azul Zulu

越靠左越稳定，越靠右性能优化越好。当然，这里列举的JRE都还挺稳定的，细微差别可能需要您亲自感受.

参考本站指南：[下载合适的Java运行时 | 日冕知识库](/zhCN/lxguide/others/download-jre)

:::

#### 4) 模组和加载器

##### a) 加载器

加载器，比如Forge、Fabric，在对游戏进程进行混入等操作时均会耗费内存。分配给游戏的内存越多，加载越流畅，直到达到加载的性能瓶颈。

与此同时，加载器维护的接口也大有不同，因此不同的加载器也有性能区别。一般认为，Fabric比Forge更加轻量级，占用也会相应更少.

##### b) 内容模组

内容模组由于向游戏中添加了新内容，会占用更多内存。具体而言，应该视单个模组中会注册和创建的方块、物品、实体量而定。与此同时，模组越多，需要的内存越多.

##### c) 优化模组

这是模组中的特例。有一些内存优化模组将会提高内存利用率或优化模组内存调度，但也可能带来一些意外的游戏行为，甚至可能与一些模组不兼容。

关于推荐的优化模组，参见此MC模组百科链接(搜索结果): [MCMOD搜索: 内存优化](https://search.mcmod.cn/s?key=%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96\&filter=%26mold%3D1)

#### 5) 其他

除此之外，游戏世界中的每个区块(包含方块的x\&y轴16\*16大小区域)、每个实体(生物、掉落物和其他有模型的存在)都是被实际写入到内存的。一般而言，可以通过调整渲染距离来减少一次加载的区块数量来降低游戏占用。(本地游戏中通过加载器特性进行加载的区块可能也会被写入到内存) 但是如果您的可用容量足够，应该为游戏尽可能提高内存量以满足更多的区块同时加载，并且也要为区块加载和卸载之间的阶段、垃圾回收器尚未工作的时刻预留好内存以供更流畅的区块加载。在内存中，一个区块占用的空间大约是40KB.

在较新版本中(大约是1.17)添加了模拟距离调整。模拟距离是控制玩家周围生物被触发的距离的参数。越大的模拟距离，会导致越远的加载区块中的生物被加载，从而消耗更多内存。请自行在游戏中感受和测试，因为对于不同的生物(之类的实体) 需要消耗的内存量不等。并且，生物AI还会额外消耗CPU资源.

### 外部因素

#### 1) 硬件装机量

这是十分显而易见的! 您的电脑倘若只有少量的硬件内存，可分配给游戏的就不得不变少。倘若您的电脑只有4GB运行内存，那即便您在LauncherX设置为8GB也是没用的，还有可能导致崩溃、甚至是有资料丢失的风险.

#### 2) 其他程序占用

在游戏进行的过程中，其他程序(包括LauncherX，但是LauncherX在后台占用极低.) 同样会占用您的硬件内存。这里面包括您的操作系统维持运行的必要消耗，也包括您打开的其他应用程序的消耗.

#### 3) 硬件内存性能

可以通俗地理解为内存频率对需要分配的内存量之影响。粗略来看，内存规格代数会体现出系列内存速度不同，但是实际远比“频率”这一单一指标要复杂。对于游戏而言，内存条频率越高，读写速度越快，则在执行交换(比如卸载区块同时加载区块)的时候就能更快地完成内存回收。不过，这一切实际上影响很小。除非您的内存优化已经到了锱铢必较的地步，那么对于越低频率的内存，建议给游戏分配的内存越多，但也没多到哪去.

### 总结

玩得卡顿了就加内存，物理内存不够加就关闭一些其他无关程序，不然就多装几条内存吧.或者，您希望了解更多关于**垃圾回收**的内容，以期进一步优化内存利用? 请接着往下看吧!

## 选择垃圾回收器(GC)

垃圾回收器(Garbage Collector，GC) 是专用于回收被占用内存的工具，依照不同的策略将不同类型的对象实例回收以释放内存资源。对于Minecraft来说，这是不可或缺的。一般而言，对于特定的游戏配置，需要尝试和调校来找出最合适的GC配置。并且，在JVM中运行的程序缺少可用内存情况下， GC 性能更为显著.

在LauncherX中可以通过选择框选择GC。目前可选的有: Disable，G1GC，SerialGC，ParallelGC，CmsGC，ZGC.

接下来将介绍这些选项，同时将其可能适合的场景列出.

* Disable: 禁用GC，非常不建议。这将会让游戏的内存回收机制回到最被动的阶段，可能导致您玩着玩着就卡死闪退。若您需要尝试没在此列出的GC(Shenandoah)，可以选择此项然后在Java虚拟机高级参数中填写对应参数.
* G1GC: \[并行+并发] 以垃圾回收为首要任务的垃圾回收器默认选择的单核GC，对游戏而言适用性最广，不知道选哪个就选它.
* SerialGC: \[串行] 单核GC。只建议在内存量较少的环境下使用，甚至可以说**不建议用于1.6.4以后的版本**?  *LauncherX的调用参数并非Serial Old* 。
* ParallelGC: \[并行] 多核优化的GC。可以避免在运行垃圾回收时引发的游戏线程阻塞，但是可能需要分配较多内存.
* CmsGC: \[并发] 全称**Mostly Concurrenct Mark and Sweep Garbage Collector**，在Java14开始被删除。它的优势是工作时**运作过程短暂、延迟低，多核优化**，在游戏期间对计算性能影响较小。但是回收可能不及时，建议搭配较大内存，可能更适合用于多mod客户端.
* ZGC: \[?] 对于需要处理突发任务较多的场景(比如多人联机的房主或服务器端)，此GC可有更好的性能。但是，这个GC只在Java15或更高版本JRE可用(在Java11推出为实验功能)。其他方面与G1GC相似.

## 配置JavaAgent

:::danger 危险!

您首先需要确保您即将使用的JavaAgent包来自可信任的源。比如，从可信任的团队官网通过加密链接下载的、已经由您亲自进行本地校对的软件包。您必须知道您这么做的后果，以及后果是否符合您的预期。一般而言，加载JavaAgent可能会被在线游戏服务器视为作弊，请确认您行为的合规性。除此之外，因加载JavaAgent导致的 \[任何] 游戏行为异常、网络攻击或信息泄露等问题均不由我们负责，LauncherX不具备检测和拦截危险行为的能力。因此，若要通过JavaAgent来优化游戏，请 \[一定要自行确保安全性]，否则不要使用JavaAgent!

:::

### 简介

JavaAgent本身是使用了用于更高级的Java虚拟机内调试的一套接口的软件包，本身是旨在便于在Java程序运行时进行调试，也可用于注入软件进程以进行篡改、优化、性能分析等一系列操作。简而言之，Java Agent可以理解为是一种特殊的Java程序，是在Java5以后Instrumentation接口的客户端。

在 \[设置-全局游戏设置-启动设置(下半部分比较偏高级设置的部分)-JavaAgent设置]处，存在两个并列的输入框: 前者输入JavaAgent软件包的路径，后者输入JavaAgent的参数.

接下来，我们将结合Github项目: [**Minecraft Threadpool Agent**](https://github.com/saharNooby/minecraft-thread-pool-agent) 来介绍使用方法。但是请注意，并非是我们推荐使用它，任何使用JavaAgent的行为导致的意外均不由我们负责。

根据该项目的描述，这是一个用于扩大游戏可用线程池的JA，可用于客户端和服务器端，主要面对1.13之后发布的游戏版本的相关优化，用于减少CPU占用和提升启动性能、减少加载时间。根据介绍，它的作用在同时启动多个客户端/服务端时候最明显。作者表示，此JA目前 **并未在单人游戏中测试，但是在多人游戏中测试无碍，且理论上不会对单人游戏造成负面影响** 。详见该项目的README.

### 用法:

1. 在此仓库的Release中下载构建 (或使用源码自行构建)
2. 在LauncherX中:
   1. 在Java虚拟机高级参数中添加: `-DminecraftThreadPoolSize=2 -DminecraftBootstrapThreadPoolSize=1 -DminecraftMainThreadPoolSize=2`
   2. 在JavaAgent参数中添加: \[第一个输入框] `<您的下载路径目录>/minecraft-thread-pool-agent-1.0.0-shaded.jar` ; \[第二个输入框] 空 (仅在JavaAgent的提供者/开发者要求您添加额外参数时再在此填入内容)
   3. 请注意: 上文中的`/`是您的系统路径分隔符，视您的操作系统而定: 如果是Windows，且不是日语/韩语的环境/区域，您应该使用`\`，否则您应该使用`¥`; 如果是macOS或Linux，使用`/`。对于较现代的Windows，可能接受`/`符号分隔，但是需要您保证 **整个路径都使用同样的分隔符** .
3. 确认LauncherX生成的拼接预览无误，启动游戏测试.
4. 需要注意的是，您可以直接按照README中的提示将参数加入到Java虚拟机高级参数中，但是使用LauncherX拼接可以避免一些难以察觉的输入失误.

:::warning 我们强烈反对一切作弊行为

:::

## 勘误

暂无。

上次更新: 2024-03-17

## 参考资料

按引用顺序排列

* *
* cncounter，GC参考手册-Java版 | GC参考手册，cncounter，2020年6月23日，https://www.bookstack.cn/read/gc-handbook/
* 壹氿，终于把CMS垃圾收集器搞懂了~ | :JVM，掘金，2021年10月28日，https://juejin.cn/post/7023935314703941663
* “非著名程序员杨某”，一文讲透Java Agent是什么玩意？能干啥？怎么用？| : Java开发技巧系列，知乎，2023年6月17日，https://zhuanlan.zhihu.com/p/636603910
* saharNooby，minecraft-thread-pool-agent | Java agent that allows to modify Minecraft client/server thread pool size，GitHub，Oct 1。2020，https://github.com/saharNooby/minecraft-thread-pool-agent

---

---
url: /zhCN/lxguide/settings/item/lx-account.md
---
# 启动器账户

:::tip

通过一个日冕账号，您可以使用许多由我们提供的可拓展LauncherX体验的在线功能。有关账户管理策略，请查看我们的[通用最终用户许可协议](/zhCN/geula).

:::

\[\[toc]]

## 未登录状态

### 操作

操作按钮: 登陆

:::info

点击登录以使用更多在线服务，比如P2P联机和其他好友在线功能.

:::

## 已登陆状态

### 操作

##### 操作按钮组: 注销 | 保存

:::info

使用“注销”按钮将当前登陆的日冕账号登出。使用“保存”按钮来尝试使下方配置的账户设置生效

:::

### 账户和启动器相关设置

###### 用户基础设置:

**用户状态**: `选择框` | 默认: 在线 / <上次登陆时设置的状态>

###### 先导版本体验设置:

**更新通道**:  `选择框` | 默认: 稳定 / <上次登陆时设置的值>

:::info

这里控制总体的更新渠道选择。可选值有: 稳定，预览。后者必须要保持日冕账户登陆，并且账户已经有有效的预览资格.

:::

**发行分支**:  `选择框` | 默认:  稳定 / 空

:::info

三个预览更新通道分为Higgs(最快)、Neutrino(快)、Proton(较稳定，较慢)。请注意: “快”是指更新、修复问题、推出新功能的频率，并非直接影响LauncherX性能的选项.

:::

## 小窍门

您可以在登陆状态下在不修改当前账户设置的情况下点击“保存”按钮来让LauncherX检查更新.

---

---
url: /zhCN/lxguide/features/tricks/default-jre-for-pack.md
---
# 在完整包中包含默认选中的Java

::: danger 请注意！可能违反协议

在您自行分发的游戏完整包中包含Java运行时的行为可能违反了该运行时构建的分发许可协议或其他等效法律文件。这是您的个人行为，我们建议您再三确认合理性再进行操作。

:::

如果您希望让您导出的游戏默认使用您提供的Java，可以遵循以下指引操作来实现。

1. 准备好您的游戏和JRE，在启动器工作目录中创建一个文件夹并在其中解压JRE

2. 点击要导出的游戏的设置，假设刚才解压JRE的文件夹叫`jre`且打开这个文件夹就能看到`bin`文件夹：

   * 在Java路径中输入`./jre/bin/javaw.exe`
   * 非Windows或许应该输入`./jre/bin/java` 但是具体使用的是哪个Java二进制文件需要依照实际情况决定（java还是javaw）

3. 点击保存，尝试启动（仅在上一步中输入的JRE和当前系统匹配时可以启动）

4. 如果启动不成功，请检查路径输入是否有误。启动成功后，可以通过任务管理器右键游戏进程来打开其所在文件夹以核对是否正常调用了预期的Java（Windows）

5. 右键点击要导出的游戏，按照您的预期，将其作为完整包导出。

   ::: warning 请注意！

   目前通过这种方式导出的完整包 **不能使用API压缩**

   :::

6. 导出后，打开导出的zip文件，将之前的`jre`文件夹拖入/加入到其根目录中

7. 将zip完全解压到某地即可测试是否默认选中了附带的Java。

::: warning 部分细节未经测试

暂时无法确认：在macOS/Linux下，保存JRE的文件夹应该跟随其他文件夹一起解压到Documents还是保持和启动器本身在一起。

:::

---

---
url: /ruRU/projbobcat/beforeWeStart.md
---
# 在我们开始之前

在我们正式开始使用 ProjBobcat, 您需要对您的项目属性做一下必要的检查和调整以满足 ProjBobcat 的运行需要.

\[\[toc]]

## 运行时要求

您需要保证您项目的 dotNET 框架至少运行在 .NET 6.0 及更高的版本当中以满足.

目前受支持的 .NET 版本：

* .NET 6.0
* .NET 7.0 （推荐）

::: warning

我们在先前的版本更新中已经移除了对 **.NET 5.0** 运行时的支持.

:::

## 项目属性

由于 Windows 系统机制, 您需要在项目属性中关闭 **首选 32 位** 的生成选项. 否则您在使用 ProjBobcat 部分组件时会出现预料之外的结果.

您需要在 Visual Studio 中切换到项目的属性页面, 并找到 **首选 32 位** 的勾选框, 并将其取消勾选.

## 32 位系统支持

::: warning

ProjBobcat 从项目立项开始就决定放弃对 32 位系统的全部支持, 因为它真的很老, 很老了（

:::

---

---
url: /zhCN/projbobcat/beforeWeStart.md
---
# 在我们开始之前

在我们正式开始使用 ProjBobcat，您需要对您的项目属性做一下必要的检查和调整以满足 ProjBobcat 的运行需要。

\[\[toc]]

## 运行时要求

您需要保证您项目的 dotNET 框架至少运行在 .NET 6.0 及更高的版本当中以满足。

目前受支持的 .NET 版本：

* .NET 8.0

::: warning

我们在先前的版本更新中已经移除了对 **.NET 5.0**、 **.NET 6.0** 与 **.NET 7.0** 运行时的支持。

:::

## 项目属性

由于 Windows 系统机制，您需要在项目属性中关闭 **首选 32 位** 的生成选项。否则您在使用 ProjBobcat 部分组件时会出现预料之外的结果。

您需要在 Visual Studio 中切换到项目的属性页面，并找到 **首选 32 位** 的勾选框，并将其取消勾选。

## 32 位系统支持

::: warning

ProjBobcat 从项目立项开始就决定放弃对 32 位系统的全部支持，因为它真的很老，很老了（

:::

---

---
url: /zhTW/projbobcat/beforeWeStart.md
---
# 在我們開始之前

在我們正式開始使用 ProjBobcat, 您需要對您的專案屬性做一下必要的檢查和調整以滿足 ProjBobcat 的執行需要.

\[\[toc]]

## 執行時要求

您需要保證您專案的 dotNET 框架至少執行在 .NET 6.0 及更高的版本當中以滿足.

目前受支援的 .NET 版本：

* .NET 6.0
* .NET 7.0 （推薦）

::: warning

我們在先前的版本更新中已經移除了對 **.NET 5.0** 執行時的支援.

:::

## 專案屬性

由於 Windows 系統機制, 您需要在專案屬性中關閉 **首選 32 位** 的生成選項. 否則您在使用 ProjBobcat 部分元件時會出現預料之外的結果.

您需要在 Visual Studio 中切換到專案的屬性頁面, 並找到 **首選 32 位** 的勾選框, 並將其取消勾選.

## 32 位系統支援

::: warning

ProjBobcat 從專案立項開始就決定放棄對 32 位系統的全部支援, 因為它真的很老, 很老了（

:::

---

---
url: /ruRU/dashboard.md
---
# 在这里你可以看到有关仪表盘组件的一些帮助知识

---

---
url: /zhCN/lxguide/features/dashboard.md
---
# 在这里你可以看到有关仪表盘组件的一些帮助知识

---

---
url: /zhTW/dashboard.md
---
# 在這裡你可以看到有關儀表盤元件的一些幫助知識

---

---
url: /zhCN/lxguide/settings/item/multi-game.md
---
# 多人游戏

::: warning 随时更新

本文内容随时可能过时。此处暂时仅展示主要信息。

2025年3月15日

:::

## 界面

点击【连接到服务】按钮后：

![](/img/lxguide/features/ui-p2p.webp)

***

点击【创建房间】：

![](/img/lxguide/features/ui-p2p-create.webp)

***

点击【加入房间】

![](/img/lxguide/features/ui-p2p-join.webp)

***

## 相关信息

开源项目：

* [ConnectX](https://github.com/Corona-Studio/ConnectX)
* [Hive.Framework](https://github.com/Corona-Studio/Hive.Framework)

相关页面：

* [P2P联机 | 日冕知识库](/zhCN/lxguide/features/p2p.html)

---

---
url: /zhCN/lxguide/others/report-with-logs.md
---
# 好好利用日志文件!

本文将介绍如何在参与测试时或遭遇自己无法解决的问题时使用程序日志来帮助解决问题。当然，这种信息对于我们排除问题也是十分有用的。部分内容不可避免地可能存在一些隐私痕迹，但请相信我们只是需要解决问题，并会帮您保护隐私.

\[\[toc]]

## LauncherX日志

LauncherX日志存在于LauncherX目录下。在Windows中，该目录和LauncherX本体存在于一个文件夹里; 而对于macOS，它存在于 `用户文件夹(小房子图标)/资源库(图书馆图标)/Application Support/`之中 (可以在此目录中按下按键`L`来快速定位L开头的项目。如果您手足够快可以快速点击`La`); 而对于Linux，该目录存在于/home/documents/ 下。其中的LauncherLog文件夹中储存着启动器的日志，而如果启动过游戏则会产生GameLog以储存部分游戏日志。如下图所示:

![LauncherX目录](/img/lxguide/reportWithLogs/lx_log_folder_direction.png)

如下图所示的是LauncherX的日志文件内容。您应该将距离错误发生时最新的那个文件用于问题分析.

![LauncherX Log Example](/img/lxguide/reportWithLogs/lx_launcher_log_example.png)
...

## EventVwr日志(仅Windows)

### 什么是EventVwr?

EventVwr，即Event Viewer 事件查看器。它存在于System32目录下，名称为`eventvwr.exe`，可以通过`Win + R`快捷键「运行」窗口直接打开。它会事无巨细地记录系统中的事件，包括作为应用程序的LauncherX的部分崩溃信息.

首先，使用上述快捷键，输入eventvwr并点击运行.

![run new](/img/lxguide/reportWithLogs/win_r.png)

在新出现的`事件查看器`窗口里找到默认就在左侧的目录导航栏，如图选中 `Windows日志 - 应用程序`

![choose](/img/lxguide/reportWithLogs/expand_eventvwr_navigation.png)

在中间靠上的窗口中依次点击**红色错误图标，且来源为「.NET Runtime」的项目** ，并在下方确认是否是来自LauncherX的项目.

![figure correct item](/img/lxguide/reportWithLogs/lx_eventvwr_item.jpg)

调整下半部分的大小 (鼠标拖拽上下窗口的中间分界线) 确认是否如上图所示: Application: LauncherX.Avalonia.exe并且包含许多「at」开头的错误信息。如果是，您可以将这些错误信息复制发给我们 (LXIT/邮箱等，详见: [向我们反馈](/zhCN/lxguide/report-issue))

:::tip

请记好LauncherX发生错误时的时间，这有助于快速寻找对应的事件项目。如若需要刷新事件管理器展示的列表，请点击左上角菜单栏的「操作-刷新」

:::

## macOS日志

### 不是崩溃弹窗吗?

崩溃弹窗中的内容往往包含的是与系统内核深度相关的信息，一般对诊断LauncherX没有任何帮助.

### 如何获取LauncherX崩溃瞬间的日志

首先，请确认这个错误会**稳定复现**.

然后，打开终端，并找到您的LauncherX主文件 (一般应该放在**应用程序**文件夹，文件名称一般是`LauncherX.Avalonia.app`)

右键点击它并点击“显示包内容”

在包内容中，依次打开目录: Contents/MacOS/ 。这里面应该可以找到一个名为LauncherX.Avalonia的文件。这是LauncherX的入口.

将这个文件拖入终端并点击Enter，LauncherX就会伴随着终端窗口中的日志滚动而开始运行.

在这个状态下尝试复现导致崩溃的问题。如果确实崩溃了，终端窗口中应该会显示如图的内容:

![figure correct item](/img/lxguide/reportWithLogs/lx_macos_logs.png)

请将这一段**Unhandled Exception**复制给我们作为线索.

## Linux日志

使用终端运行LauncherX将会显示完整的日志。请参考上文关于**macOS日志**的内容向我们提供线索!

## 游戏日志

游戏未按照预期运行？甚至使用官方启动器之类的都一切正常、唯独LauncherX在同样配置下出问题？游戏窗口一闪而过？“没有找到主类或路径编码不正确”？使用测试启动功能获取更多错误信息，或拿着这些信息来向我们反馈！参见：[LauncherX 测试启动](/zhCN/lxguide/features/launch-test.md)

与此相关的阅读: [了解更多关于日志窗口的信息](/zhCN/lxguide/features/log-window)

---

---
url: /ruRU/dashboard/search.md
---
# 如何使用仪表盘搜索

您可以在聚合搜索输入框中输入任何您想要查找的内容. 在您输入内容后, 下方会弹出智能提示来帮助您快速的导航到搜索结果页面

## 使用指定的搜索引擎来查找内容

在默认情况下, LauncherX 会使用 必应（Bing）来查找您的搜索内容.
如果您想指定聚合搜索使用的搜索引擎, 您可以在您的搜索内容前加入下面的前缀：

| 搜索引擎 |  值  |
|:----:|:---:|
|  百度  | bd: |
|  谷歌  | g:  |
|  必应  | b:  |

### 样例

* 使用百度搜索 “1.16.5材质包”：bd:1.16.5材质包
* 使用谷歌搜索 “1.16.5材质包”：g:1.16.5材质包
* 使用必应搜索 “1.16.5材质包”：b:1.16.5材质包

---

---
url: /zhCN/lxguide/features/dashboard/search.md
---
# 如何使用仪表盘搜索

您可以在聚合搜索输入框中输入任何您想要查找的内容。在您输入内容后，下方会弹出智能提示来帮助您快速的导航到搜索结果页面

## 使用指定的搜索引擎来查找内容

在默认情况下，LauncherX 会使用 必应（Bing）来查找您的搜索内容。
如果您想指定聚合搜索使用的搜索引擎，您可以在您的搜索内容前加入下面的前缀：

| 搜索引擎 |  值  |
|:----:|:---:|
|  百度  | bd: |
|  谷歌  | g:  |
|  必应  | b:  |

### 样例

* 使用百度搜索 “1.16.5材质包”：bd:1.16.5材质包
* 使用谷歌搜索 “1.16.5材质包”：g:1.16.5材质包
* 使用必应搜索 “1.16.5材质包”：b:1.16.5材质包

---

---
url: /zhTW/dashboard/search.md
---
# 如何使用儀表盤搜尋

您可以在聚合搜尋輸入框中輸入任何您想要查詢的內容. 在您輸入內容後, 下方會彈出智慧提示來幫助您快速的導航到搜尋結果頁面

## 使用指定的搜尋引擎來查詢內容

在預設情況下, LauncherX 會使用 必應（Bing）來查詢您的搜尋內容.
如果您想指定聚合搜尋使用的搜尋引擎, 您可以在您的搜尋內容前加入下面的字首：

| 搜尋引擎 |  值  |
|:----:|:---:|
|  百度  | bd: |
|  谷歌  | g:  |
|  必應  | b:  |

### 樣例

* 使用百度搜索 “1.16.5材質包”：bd:1.16.5材質包
* 使用谷歌搜尋 “1.16.5材質包”：g:1.16.5材質包
* 使用必應搜尋 “1.16.5材質包”：b:1.16.5材質包

---

---
url: /ruRU/projbobcat/installers.md
---
# 安装器

在 ProjBobcat 中, 我们已经为开发者实现了您在 MineCraft 开发过程中可能遇到的大部分模组基础设施.

## 支持列表

|      项目名称       |    支持状态     ||
|:---------------:|:-----------:|:---:|
|   Forge （旧版）    |     受支持     |  ✅   |
|   Forge （新版）    |     受支持     |  ✅  |
|   LiteLoader    |     受支持     |  ✅  |
|     Fabric      |     受支持     |  ✅  |
|    Optifine     |     受支持     |  ✅  |
|      Quilt      |  受支持（实验性）   |  ⚠  |
| CurseForge 整合包  |     受支持     |  ✅  |

---

---
url: /zhCN/projbobcat/installers.md
---
# 安装器

在 ProjBobcat 中，我们已经为开发者实现了您在 MineCraft 开发过程中可能遇到的大部分模组基础设施。

## 支持列表

|      项目名称       |    支持状态     ||
|:---------------:|:-----------:|:---:|
|   Forge （旧版）    |     受支持     |  ✅   |
|   Forge （新版）    |     受支持     |  ✅  |
|   LiteLoader    |     受支持     |  ✅  |
|     Fabric      |     受支持     |  ✅  |
|    Optifine     |     受支持     |  ✅  |
|      Quilt      |  受支持（实验性）   |  ⚠  |
| CurseForge 整合包  |     受支持     |  ✅  |

---

---
url: /ruRU/projbobcat/installationAndConfig.md
---
# 安装并配置 ProjBobcat

\[\[toc]]

## 从发行包安装

### Nuget

目前, 您可以方便的从 Nuget 上搜索并下载 ProjBobcat 的软件包, 您可以在 Visual Studio 的包管理器中搜索 ProjBobcat 并将其添加到您的项目中.

或者, 您也可以手动在 “程序包管理器控制台” 中执行下面的命令：

```bash
NuGet\Install-Package ProjBobcat -Version 1.16.0
```

### .NET CLI

要通过 .NET CLI 来安装 ProjBobcat, 您只需要将终端切换到包含 .csproj 文件的项目目录, 并在终端中执行：

```bash
dotnet add package ProjBobcat --version 1.16.0
```

### PackageReference

PackageReference 是微软为现代 .NET 项目推出的一种新的软件包管理规范,
详细信息可以在 [MSDN](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files)
中查看

您只需在项目的 **\[项目名].csproj** 文件中添加：

```xml
<PackageReference Include="ProjBobcat" Version="1.16.0" />
```

::: tip
其中, **1.16.0** 为 ProjBobcat 的版本号, 您可以将其替换为其他的版本号,
所有的发行版本都可以在 [ProjBobcat - Nuget](https://www.nuget.org/packages/ProjBobcat#versions-body-tab) 中查看.
:::

## 从源码引用

另外一种使用 ProjBobcat 的方法是直接添加代码仓库到您的项目引用.

::: info
在执行下面的命令前, 您可能需要先安装 [Git CLI](https://git-scm.com/)
:::

### 克隆 ProjBobcat 仓库

使用命令行切换到项目解决方案的根目录, 并在命令行中执行下面的代码来完成仓库的克隆：

```bash
git clone https://github.com/Corona-Studio/ProjBobcat.git
```

### 使用 Git Submodule（子模块）的方式拉取 ProjBobcat

::: tip
Git Submodule 是一个非常实用的功能, 在这里我们只展示了其最基本的用例.
在 [Git 官方文档](https://git-scm.com/book/en/v2/Git-Tools-Submodules) 中您可以查看到更多的使用案例.
:::

使用命令行切换到项目解决方案的根目录, 并在命令行中执行下面的代码来完成仓库的克隆：

```bash
git submodule add https://github.com/Corona-Studio/ProjBobcat.git
```

### 添加对 ProjBobcat 的引用

接下来, 在 Visual Studio 的 **解决方案资源管理器** 视图中, 右键点击位于树状图顶层的解决方案名称.
并选择 **“添加”-“现有项目”**, 并在文件浏览窗口中找到刚刚克隆的 ProjBobcat 项目文件夹中的 **ProjBobcat.csproj**.

接着, 在 **解决方案资源管理器** 找到您需要引用 ProjBobcat 的项目, 并右键单击, 选择 **“添加”-“项目引用”**.
最后在弹出窗口中勾选 ProjBobcat 即可完成对其的引用.

## 使用前配置

### 修改默认连接数

在使用 ProjBobcat 之前, 您需要在程序的入口点（通常是 **App.xaml.cs** 或 **Program.cs**）
中添加一些代码来初始化 ProjBobcat 的相关服务.

由于 .NET 运行时默认的最大连接数限制, 在使用 ProjBobcat 下载模块时可能会遭遇性能瓶颈.
因此, 您需要在入口处添加下面的代码来修改默认的最大连接数：

```c#{3}
 using System.Net;

 ServicePointManager.DefaultConnectionLimit = 512;
```

### 注册并初始化基础服务

接下来, 您需要在入口点添加这些代码来完成 ProjBobcat 服务的初始化：

#### 初始化服务容器

```c#
ServiceHelper.Init();
```

#### 初始化 CurseForge API 服务（可选）

该服务为可选项目, 如果您没有使用任何 CurseForge 相关服务, 您可以忽略这个步骤.

::: tip
在注册 CurseForge 服务前, 您需要准备 CurseForge 官方下发的 API KEY.
如果您还没有, 请前往 [申请页面 - CurseForge](https://support.curseforge.com/en/support/solutions/articles/9000208346-about-the-curseforge-api-and-how-to-apply-for-a-key)
来获得您的 API KEY.
:::

::: warning
API KEY 为敏感的个人凭据, 请妥善保存 API KEY 并不要将其泄露给其他人.
:::

```c#
CurseForgeAPIHelper.SetApiKey("[YOUR API KEY]");
```

将 **\[YOUR API KEY]** 替换为您从 CurseForge 官方获取的 API KEY.

#### 初始化下载服务

在初始化下载服务时您可以选择自定义请求时所使用的 User Agent（默认为 "ProjBobcat"）.

```c#
HttpClientHelper.Ua = "[YOUR UA]"; // 可选
HttpClientHelper.Init();
```

### 配置微软登录验证器

关于 Azure Active Directory 应用具体的注册方法请移步：
[如何注册 Azure 应用](/ruRU/projbobcat/createNewAzureApp)

::: tip
在配置微软验证器前, 您需要在 Azure 注册您的应用, 并对其进行正确的配置.
在您完成配置之后, 您会获得一串 Client ID.

相关资料：

* [Azure 官网](https://azure.microsoft.com/en-us/)
* [Device code flow](https://learn.microsoft.com/en-us/azure/active-directory/develop/scenario-desktop-acquire-token-device-code-flow?tabs=dotnet)

:::

::: warning
CLIENT ID 为敏感的个人凭据, 请妥善保存 CLIENT ID 并不要将其泄露给其他人.
:::

```c#
MicrosoftAuthenticator.Configure(new MicrosoftAuthenticatorAPISettings
{
    ClientId = "[YOUR CLIENT ID]",
    TenentId = "consumers",
    Scopes = new[] { "XboxLive.signin", "offline_access", "openid", "profile", "email" }
});
```

在取得 Client ID 后, 将 **\[YOUR CLIENT ID]** 替换为您的 Client ID.

---

---
url: /zhCN/projbobcat/installationAndConfig.md
---
# 安装并配置 ProjBobcat

\[\[toc]]

## 从发行包安装

### Nuget

目前，您可以方便的从 Nuget 上搜索并下载 ProjBobcat 的软件包，您可以在 Visual Studio 的包管理器中搜索 ProjBobcat 并将其添加到您的项目中。

或者，您也可以手动在 “程序包管理器控制台” 中执行下面的命令：

```bash
NuGet\Install-Package ProjBobcat -Version 1.40.0
```

### .NET CLI

要通过 .NET CLI 来安装 ProjBobcat，您只需要将终端切换到包含 .csproj 文件的项目目录，并在终端中执行：

```bash
dotnet add package ProjBobcat --version 1.40.0
```

### PackageReference

PackageReference 是微软为现代 .NET 项目推出的一种新的软件包管理规范，
详细信息可以在 [MSDN](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files)
中查看

您只需在项目的 **\[项目名].csproj** 文件中添加：

```xml
<PackageReference Include="ProjBobcat" Version="1.40.0" />
```

::: tip
其中，**1.140.0** 为 ProjBobcat 的版本号，您可以将其替换为其他的版本号，
所有的发行版本都可以在 [ProjBobcat - Nuget](https://www.nuget.org/packages/ProjBobcat#versions-body-tab) 中查看。
:::

## 从源码引用

另外一种使用 ProjBobcat 的方法是直接添加代码仓库到您的项目引用。

::: info
在执行下面的命令前，您可能需要先安装 [Git CLI](https://git-scm.com/)
:::

### 克隆 ProjBobcat 仓库

使用命令行切换到项目解决方案的根目录，并在命令行中执行下面的代码来完成仓库的克隆：

```bash
git clone https://github.com/Corona-Studio/ProjBobcat.git
```

### 使用 Git Submodule（子模块）的方式拉取 ProjBobcat

::: tip
Git Submodule 是一个非常实用的功能，在这里我们只展示了其最基本的用例。
在 [Git 官方文档](https://git-scm.com/book/en/v2/Git-Tools-Submodules) 中您可以查看到更多的使用案例。
:::

使用命令行切换到项目解决方案的根目录，并在命令行中执行下面的代码来完成仓库的克隆：

```bash
git submodule add https://github.com/Corona-Studio/ProjBobcat.git
```

### 添加对 ProjBobcat 的引用

接下来，在 Visual Studio 的 **解决方案资源管理器** 视图中，右键点击位于树状图顶层的解决方案名称。
并选择 **“添加”-“现有项目”**，并在文件浏览窗口中找到刚刚克隆的 ProjBobcat 项目文件夹中的 **ProjBobcat.csproj**。

接着，在 **解决方案资源管理器** 找到您需要引用 ProjBobcat 的项目，并右键单击，选择 **“添加”-“项目引用”**。
最后在弹出窗口中勾选 ProjBobcat 即可完成对其的引用。

## 使用前配置

### 修改默认连接数

在使用 ProjBobcat 之前，您需要在程序的入口点（通常是 **App.xaml.cs** 或 **Program.cs**）
中添加一些代码来初始化 ProjBobcat 的相关服务。

由于 .NET 运行时默认的最大连接数限制，在使用 ProjBobcat 下载模块时可能会遭遇性能瓶颈。
因此，您需要在入口处添加下面的代码来修改默认的最大连接数：

```c#{3}
using System.Net;

ServicePointManager.DefaultConnectionLimit = 512;
```

### 注册并初始化基础服务

接下来，您需要在入口点添加这些代码来完成 ProjBobcat 服务的初始化：

#### 初始化服务容器

```c#
ServiceHelper.Init();
```

#### 初始化 CurseForge API 服务（可选）

该服务为可选项目，如果您没有使用任何 CurseForge 相关服务，您可以忽略这个步骤。

::: tip
在注册 CurseForge 服务前，您需要准备 CurseForge 官方下发的 API KEY。
如果您还没有，请前往 [申请页面 - CurseForge](https://support.curseforge.com/en/support/solutions/articles/9000208346-about-the-curseforge-api-and-how-to-apply-for-a-key)
来获得您的 API KEY。
:::

::: warning
API KEY 为敏感的个人凭据，请妥善保存 API KEY 并不要将其泄露给其他人。
:::

```c#
CurseForgeAPIHelper.SetApiKey("[YOUR API KEY]");
```

将 **\[YOUR API KEY]** 替换为您从 CurseForge 官方获取的 API KEY。

#### 初始化下载服务

在初始化下载服务时您可以选择自定义请求时所使用的 User Agent（默认为 "ProjBobcat"）。

```c#
HttpClientHelper.Ua = "[YOUR UA]"; // 可选
```

### 配置微软登录验证器

关于 Azure Active Directory 应用具体的注册方法请移步：
[如何注册 Azure 应用](/zhCN/projbobcat/createNewAzureApp)

::: tip
在配置微软验证器前，您需要在 Azure 注册您的应用，并对其进行正确的配置。
在您完成配置之后，您会获得一串 Client ID。

相关资料：

* [Azure 官网](https://azure.microsoft.com/en-us/)
* [Device code flow](https://learn.microsoft.com/en-us/azure/active-directory/develop/scenario-desktop-acquire-token-device-code-flow?tabs=dotnet)

:::

::: warning
CLIENT ID 为敏感的个人凭据，请妥善保存 CLIENT ID 并不要将其泄露给其他人。
:::

```c#
MicrosoftAuthenticator.Configure(new MicrosoftAuthenticatorAPISettings
{
    ClientId = "[YOUR CLIENT ID]",
    TenentId = "consumers",
    Scopes = new[] { "XboxLive.signin",  "offline_access",  "openid",  "profile",  "email" }
});
```

在取得 Client ID 后，将 **\[YOUR CLIENT ID]** 替换为您的 Client ID。

---

---
url: /zhCN/lxguide/features/installing-games.md
---
# 安装游戏

LauncherX提供多种游戏安装方式。

\[\[toc]]

## 通过下载

通过内置的游戏下载，可以下载包括可选扩展组件（比如Forge、Fabric）在内的许多游戏。操作步骤如下：

* 点击导航栏上的【下载】

* 在列表中寻找或搜索想要下载的游戏版本，点击对应的下载按钮

* 在弹出的 “安装” 弹窗中，至少选择一项以继续安装。

  * 如果要安装原版游戏，直接让列表中第一项保持选中，然后点击【安装】

  * 如果要安装带有附属组件的游戏，选中它并选择一个具体的版本，然后点击【安装】

    ::: tip 关键信息

    得益于LauncherX强大的任务队列管理系统，你可以一次性选中多个游戏进行安装。

    但是请注意，如果在对应的原版游戏未被安装的情况下安装了附属组件，那么该游戏将无法启动。

    你可以在安装界面的每一个输入框更改对应游戏的名称。

    :::

* 等待下载安装完成。若在任务中心发现安装失败，请先确认自己的网络连接正常。参考：[管理账户 | 日冕知识库](/zhCN/lxguide/settings/special/manage-accounts.html)

## 安装整合包

LauncherX支持 **Modrinth格式** 和 **Curseforge格式** 的整合包。只需要将这类整合包拖入LauncherX窗口（或在【游戏列表】中使用【更多-添加游戏资源-整合包】选择将安装的整合包）即可开始安装。了解更多：[LauncherX的整合包支持 | 日冕知识库](/zhCN/lxguide/features/modpack-support.html#导入)

## 迁移游戏

LauncherX可以使用其他目录作为游戏目录，如果想要LauncherX正确识别一个已有游戏的目录，这个目录必须是启用了一般版本隔离的（并非MultiMC类的版本隔离）。或者直接将包含 **已版本隔离的游戏版本根目录**（在`.minecraft/versions/`下的文件夹）粘贴到LauncherX当前选中的游戏目录的versions文件夹中。但是后者并不一定总是有效，具体取决于游戏类型，参考：[游戏列表 | 日冕知识库](/zhCN/lxguide/features/gamelist.html)

---

---
url: /zhTW/projbobcat/installationAndConfig.md
---
# 安裝並配置 ProjBobcat

\[\[toc]]

## 從發行包安裝

### Nuget

目前, 您可以方便的從 Nuget 上搜索並下載 ProjBobcat 的軟體包, 您可以在 Visual Studio 的包管理器中搜索 ProjBobcat 並將其新增到您的專案中.

或者, 您也可以手動在 “程式包管理器控制檯” 中執行下面的命令：

```bash
NuGet\Install-Package ProjBobcat -Version 1.16.0
```

### .NET CLI

要透過 .NET CLI 來安裝 ProjBobcat, 您只需要將終端切換到包含 .csproj 檔案的專案目錄, 並在終端中執行：

```bash
dotnet add package ProjBobcat --version 1.16.0
```

### PackageReference

PackageReference 是微軟為現代 .NET 專案推出的一種新的軟體包管理規範,
詳細資訊可以在 [MSDN](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files)
中檢視

您只需在專案的 **\[專案名].csproj** 檔案中新增：

```xml
<PackageReference Include="ProjBobcat" Version="1.16.0" />
```

::: tip
其中, **1.16.0** 為 ProjBobcat 的版本號, 您可以將其替換為其他的版本號,
所有的發行版本都可以在 [ProjBobcat - Nuget](https://www.nuget.org/packages/ProjBobcat#versions-body-tab) 中檢視.
:::

## 從原始碼引用

另外一種使用 ProjBobcat 的方法是直接新增程式碼倉庫到您的專案引用.

::: info
在執行下面的命令前, 您可能需要先安裝 [Git CLI](https://git-scm.com/)
:::

### 克隆 ProjBobcat 倉庫

使用命令列切換到專案解決方案的根目錄, 並在命令列中執行下面的程式碼來完成倉庫的克隆：

```bash
git clone https://github.com/Corona-Studio/ProjBobcat.git
```

### 使用 Git Submodule（子模組）的方式拉取 ProjBobcat

::: tip
Git Submodule 是一個非常實用的功能, 在這裡我們只展示了其最基本的用例.
在 [Git 官方文件](https://git-scm.com/book/en/v2/Git-Tools-Submodules) 中您可以檢視到更多的使用案例.
:::

使用命令列切換到專案解決方案的根目錄, 並在命令列中執行下面的程式碼來完成倉庫的克隆：

```bash
git submodule add https://github.com/Corona-Studio/ProjBobcat.git
```

### 新增對 ProjBobcat 的引用

接下來, 在 Visual Studio 的 **解決方案資源管理器** 檢視中, 右鍵點選位於樹狀圖頂層的解決方案名稱.
並選擇 **“新增”-“現有專案”**, 並在檔案瀏覽視窗中找到剛剛克隆的 ProjBobcat 專案資料夾中的 **ProjBobcat.csproj**.

接著, 在 **解決方案資源管理器** 找到您需要引用 ProjBobcat 的專案, 並右鍵單擊, 選擇 **“新增”-“專案引用”**.
最後在彈出視窗中勾選 ProjBobcat 即可完成對其的引用.

## 使用前配置

### 修改預設連線數

在使用 ProjBobcat 之前, 您需要在程式的入口點（通常是 **App.xaml.cs** 或 **Program.cs**）
中新增一些程式碼來初始化 ProjBobcat 的相關服務.

由於 .NET 執行時預設的最大連線數限制, 在使用 ProjBobcat 下載模組時可能會遭遇效能瓶頸.
因此, 您需要在入口處新增下面的程式碼來修改預設的最大連線數：

```c#{3}
 using System.Net;

 ServicePointManager.DefaultConnectionLimit = 512;
```

### 註冊並初始化基礎服務

接下來, 您需要在入口點新增這些程式碼來完成 ProjBobcat 服務的初始化：

#### 初始化服務容器

```c#
ServiceHelper.Init();
```

#### 初始化 CurseForge API 服務（可選）

該服務為可選專案, 如果您沒有使用任何 CurseForge 相關服務, 您可以忽略這個步驟.

::: tip
在註冊 CurseForge 服務前, 您需要準備 CurseForge 官方下發的 API KEY.
如果您還沒有, 請前往 [申請頁面 - CurseForge](https://support.curseforge.com/en/support/solutions/articles/9000208346-about-the-curseforge-api-and-how-to-apply-for-a-key)
來獲得您的 API KEY.
:::

::: warning
API KEY 為敏感的個人憑據, 請妥善儲存 API KEY 並不要將其洩露給其他人.
:::

```c#
CurseForgeAPIHelper.SetApiKey("[YOUR API KEY]");
```

將 **\[YOUR API KEY]** 替換為您從 CurseForge 官方獲取的 API KEY.

#### 初始化下載服務

在初始化下載服務時您可以選擇自定義請求時所使用的 User Agent（預設為 "ProjBobcat"）.

```c#
HttpClientHelper.Ua = "[YOUR UA]"; // 可選
HttpClientHelper.Init();
```

### 配置微軟登入驗證器

關於 Azure Active Directory 應用具體的註冊方法請移步：
[如何註冊 Azure 應用](/zhTW/projbobcat/createNewAzureApp)

::: tip
在配置微軟驗證器前, 您需要在 Azure 註冊您的應用, 並對其進行正確的配置.
在您完成配置之後, 您會獲得一串 Client ID.

相關資料：

* [Azure 官網](https://azure.microsoft.com/en-us/)
* [Device code flow](https://learn.microsoft.com/en-us/azure/active-directory/develop/scenario-desktop-acquire-token-device-code-flow?tabs=dotnet)

:::

::: warning
CLIENT ID 為敏感的個人憑據, 請妥善儲存 CLIENT ID 並不要將其洩露給其他人.
:::

```c#
MicrosoftAuthenticator.Configure(new MicrosoftAuthenticatorAPISettings
{
    ClientId = "[YOUR CLIENT ID]",
    TenentId = "consumers",
    Scopes = new[] { "XboxLive.signin", "offline_access", "openid", "profile", "email" }
});
```

在取得 Client ID 後, 將 **\[YOUR CLIENT ID]** 替換為您的 Client ID.

---

---
url: /zhTW/projbobcat/installers.md
---
# 安裝器

在 ProjBobcat 中, 我們已經為開發者實現了您在 MineCraft 開發過程中可能遇到的大部分模組基礎設施.

## 支援列表

|      專案名稱       |    支援狀態     ||
|:---------------:|:-----------:|:---:|
|   Forge （舊版）    |     受支援     |  ✅   |
|   Forge （新版）    |     受支援     |  ✅  |
|   LiteLoader    |     受支援     |  ✅  |
|     Fabric      |     受支援     |  ✅  |
|    Optifine     |     受支援     |  ✅  |
|      Quilt      |  受支援（實驗性）   |  ⚠  |
| CurseForge 整合包  |     受支援     |  ✅  |

---

---
url: /zhCN/lxguide/settings.md
---
# 对本类文档的解释：什么是“专题”，什么是“分类”：

*创建日期：2023年11月28日，修改日期：2023年11月28日，作者：Feiron Iguista*

针对LauncherX的配置调整，我们提供了两种解释性文档：**专题**和**分类**。

一言以蔽之，**专题**相当于是特殊化的、可能连结多个设置分类的、着重于解释我们的特色功能的**设置指引**。

而**分类**是以**LauncherX设置的不同选项卡**为分类基础区分的，针对每一类中每一项设置的具体解释。

::: warning

在文档的最初的编写阶段，标题中含有#的是未完成的项目。

:::

## 专题

详细而言，专题会指引您完成比较曲折的操作。比如，调整启动器的整体外观到您中意的风格，或者结合“固定启动账户”和“游戏账户管理”来使您可以快速使用常用的账户启动游戏。

不过，想必您在阅读理解了**分类**板块之后，能够充分地发挥您的主观能动性并且玩出我们或许也未曾设想的花样。我们期待您能够深入地体验我们的产品！

## 分类

这个板块会随着LauncherX的具体更新而更新，恕不另行通知。

*致翻译贡献者：这个板块更新相对更加频繁。请合理安排提交*.

详细而言，这里会指出LauncherX每一项具体的设置代表着什么。有些涉及启动原理的项目可能同样适用于其他启动器，但是我们当然**更希望您能一直使用LauncherX**.

我们将会在这里告诉您最具体的设置方法，比如：如何设置JVM高级启动参数？离线模式的本地皮肤是什么原理？如何合理配置GC（垃圾回收器）？诸如此类。

相信您在理解所有设置之后能够自行找出适合自己的最佳游戏体验。

---

---
url: /zhCN/lxguide/others/general.md
---
# 常见名词解释

其他: 这里存放着一些解释文字的文字，和一些特性说明等其他内容.

\[\[toc]]

:::info

善用浏览器的页内搜索功能! 可以尝试组合键 `Ctrl + F` 或者 `⌘ + F`。如果是在手机上浏览，请试着在浏览器的功能菜单里找一找有没有搜索功能.

:::

## 游戏类

### 与Minecraft游戏运行相关的名词解释

:::

###### 日志

在游戏尝试启动阶段、JRE(JVM)已启动的时候就会输出到游戏版本目录下logs文件夹中的.log文件或者.log.bz压缩包。如果LauncherX开启了[**游戏日志实时输出**](/zhCN/lxguide/features/log-window)功能，那么将会在其中展示实时的日志，方便人类可以读懂“游戏现在在干什么”。*这个词也可能是指由启动器产生的日志文件，请根据上下文判断。与此同时，存在名为“crash-report”的Forge崩溃报告与这个词有极大的联系，后者本质上也是一种日志，但是是用于分析Forge崩溃原因的。无论如何，请具体分析*.

***

###### 启动参数

在启动游戏时，附加给游戏的启动命令。*本页中「环境类」类别有相同的词，可以结合另一个释义深入了解*.

***

###### 待补充

2024年3月13日 最后更新

## 环境类

:::info 与计算机软件环境相关的名词解释。但是一般而言，这里只会解释和Minecraft相关的环境的名词。

:::

### 环境

计算机软件运行所需要的前置条件。*您可以把Mod的前置也理解为一种环境(的一部分)，但是一般而言的环境的定义比前置更大*.

***

### JRE

全称为「Java Runtime Environment」，Java运行时环境。这是运行Java软件必要的一套环境。一般而言，无论是一般的JRE还是JDK，其中都包含JRE，而JRE一般包含JVM(Java Virtual Machine，Java虚拟机)，这为Java的跨平台等特性提供了运行的框架。*很温暖，像家一样*…

***

### 启动参数

或使用更广泛范围下的说法: 「JVM参数/Java参数」。您需要将它和Java Agent作出区分，一般而言，要想优化游戏启动，只需要更改JVM参数。*对于JavaAgent设置的解释将在晚些时候LauncherX设置说明完成了「JavaAgent设置」分段后补充*。  -  这是在启动JVM时附加在启动指令末尾的一串以`-`开头、使用空格分隔的附加字符，一般而言是用于指定JVM运行行为的。所以如果使用得当，将会为您的Minecraft游戏带来更好的体验。比如，您可以通过附加`-Xmx5G` 来为Java程序设定最高使用**5GB**内存的限额(实际用量视设备可用内存和程序需要情况而不同。而指定内存已经由LauncherX在[全局游戏设置](/zhCN/lxguide/settings/item/global) 中提供了带有**可视化提示**的输入框可供直接使用.)  -  由于「但凡是使用JVM的程序，都可以使用JVM参数指定行为」，所以您同样可以用这种方法来优化其他在JVM中运行的程序或游戏(比如**Project Zomboid**，您可以在游戏目录中的`ProjectZomboid64.bat`中通过将默认的`-Xmx3072m`改到更大来允许游戏使用更多的物理内存.)

***

### JA

为了节省空间而使用的 **JavaAgent** 的缩写.

***

###### 待补充

2024年3月13日 最后更新

## Corona Studio

:::info 日冕工作室特色。

:::

###### %*一切严格的按词分隔的“帕斯卡大小写”单词*%

可能是Rider对单词拼写的要求太严格了，或者老腊肉对帕斯卡大写法有种奇怪的执着，总之像「*Minecraft*」这样的单词在LauncherX中可能会呈现为「MineCraft」…

***

###### 吔!

这是个语气词! 但还是放进来了! 这是Corona Studio常有的! 发音和用法均同“耶!”!

***

###### 待补充

2024年3月13日 最后更新

:::info

想起来了会更新的。催更请发邮件到 <frigeso@icloud.com>，告诉我您搞不明白哪个词。勘误也发到这个邮箱好了www

:::

---

---
url: /zhCN/lxguide/faq.md
---
# 常见问题

> 本文初次编成于 2025年8月10日。挺臭的说是。

\[\[toc]]

## 前言

如果遇到问题，日志将是确认问题的绝佳线索。这些CSKB链接将会让你知道如何搜集这些线索。

* LauncherX本体相关问题：[好好利用日志文件!  | 日冕知识库](/zhCN/lxguide/others/report-with-logs.html)
* 游戏异常启动问题：[测试启动 | 日冕知识库](/zhCN/lxguide/features/launch-test.html)

反馈问题，参见：[报告异常&建言新策 | 日冕知识库](/zhCN/lxguide/report-issue.html)。

附加日志的时候，可以在Github Issue中直接粘贴为代码块，或是使用[mclo.gs](https://mclo.gs)来提供错误日志！

## 运行相关

### 无法打开启动器

::: warning 先决条件

LauncherX作为一个绿色软件，必须手动将程序本体解压到一个预先准备好的文件夹内才能运行。如果弹出Windows Defender的警告，请点击【显示更多/高级选项】，然后点击【仍要运行】。相关阅读：[开始 (LauncherX) | 日冕知识库](/zhCN/lxguide/startup/)

关于Windows7相关的问题，参见：[Windows 7 用户指南 | 日冕知识库](/zhCN/lxguide/startup/others/win7.html)

:::

#### A. 部分特定的Windows系统环境下启动器没有主窗口和前台进程

* 症状：双击解压后的启动器，仅会创建相关的文件夹和文件，并且任务管理器中有对应的后台任务，但是没有启动器窗口出现；
* 解决方法：从官方下载最新版本对应架构的VCRedist并安装（2015~2022合集版）。
* 常见于：Windows11家庭版，Windows10部分较老版本

***

#### B. 对于部分早期版本Windows11和Windows10的“快速异常检测失败”错误

* 症状：在尝试运行启动器时出现弹窗【发生了快速异常检测失败。将不会调用异常处理数据，并且进程将立即中止】或无响应，在eventvwwr中提示上述弹窗中可能出现的文本或只出现和LauncherX相关的类型为1000的错误。
* 解决方法：有热心市民报告Windows更新包【KB5046714】可能解决该问题，但是我们建议直接进行系统更新。温馨提示：Windows10仍然可以接收到此修复更新，不必更新到Windows11。Windows10的官方支持很快将会结束。
* 常见于：部分早期版本Windows11和Windows10
* 参考信息不可考。感谢热心市民的反馈。

***

#### C. 部分未知的、无迹可寻的Windows下可能出现的双击无法运行，并没有相关文件和文件夹被创建

* 症状：与【A】类似但是没有文件被创建
* 解决方法：尝试使用powershell启动
* 常见于：未知
* 提示：此方法可能不能解决问题，并且有遇到此情况的个别用户在稍后报告双击启动器可以正常打开。
  *建议作为走近科学素材录制。*

***

#### D. 在EventVwr中明确异常代码：0xc0000602

* 症状：与【A】可能类似，但是记录了明确的异常代码0xc0000602（仅在较新的系统和基于dotNET9的LauncherX中可能出现）
* 解决方法：
  * 使用组合键 `Windows` + `i` 打开设置 → 点击【隐私和安全】→ 点击【Windows安全】→ 点击【打开Windows安全】（按钮文本可能因系统版本而有细微差异，使用任意方法打开Windows安全中心即可）
  * 在边栏（如有）**找到**【应用程序和浏览控制】然后点击它
  * 找到图标为【】的Exploit Protection（漏洞防护）点击位于其标题和描述下方的【可能与标题同名的链接】*这个链接一般使用系统主题色，点击后可以进入对应的详细设置。*
  * 在Exploit Protection设置里，点击【程序设置】，然后点击【添加】，然后点击【添加使用程序名称】（?）
  * 在弹出窗口输入LauncherX的文件名，默认状态应该是`LauncherX.Avalonia.exe`。该输入框不支持通配符。
  * 点击添加以保存。然后对LauncherX进行安全设置：向下滚动找到【硬件强制实施的堆栈保护】，勾选上【替代系统设置】，然后确保其下方的开关**保持为关闭状态**，然后点击弹窗中下方的【应用】（保存）按钮。
  * 重新尝试启动LauncherX
* 常见于：Windows11，可能是24H2+的系统
* 参考信息：[启动器无法启动并在Windows日志中提示0xc0000602错误 · Issue #352 · Corona-Studio/LXIT](https://github.com/Corona-Studio/LXIT/issues/352)。感谢热心市民的反馈。

***

#### E. macOS启动闪退

* 症状：在第一次使用后再次打开LauncherX，弹出系统的程序崩溃弹窗
* 解决方法：前往macOS的【设置-(搜索)通知】，找到管理应用程序通知权限的列表，在其中找到LauncherX.Avalonia.app，为其赋予通知权限。
* 常见于：所有macOS

***

## 功能相关

### 下载相关：通用错误排除指南

如果在下载游戏或进行资源补全的时候频繁遇到错误、重试后仍然遇到错误，请尝试按照以下保守方案调整设置（选其一有效即可）：

* 在网络设置中，保持开启多重源补全，降低下载线程到32；
* 在全局设置-启动器行为中，把重试次数调到最高 - 在网络设置中，关闭多重源补全，降低下载线程到16（多次尝试均无法解决问题则调到1），切换下载服务器到Bangbang93的下载服务器；
* 在全局设置-启动器行为中，把重试次数调到最高 - 在网络设置中，关闭多重源补全，降低下载线程到5，切换下载服务器到官方；
* 在全局设置-启动器行为中，把重试次数调到最高（有条件的话可以在这个的基础上打开游戏加速器加速Minecraft国际服）
* 尝试切换网络到手机热点
* 尝试使用代理优化网络环境（游戏加速器，必须加速Minecraft国际服，且使用路由模式而非进程模式 (举例：小黑盒加速器的路由模式为模式2。其他加速器请参考对应的官方说明手册等文档)）

::: warning 必须要有理有据

所有用户的网络环境都可能受到不同的因素影响：可能是系统软件原因，也可能是电脑硬件原因，甚至可能是路由器设置、运营商、有关部门的行为影响，或是尝试访问的服务的服务器出现了各种问题。LauncherX的下载功能经过了成百上千次的测试和实际数据保证功能的健壮性。除非有充分的证据证明下载时的问题是由启动器造成的，否则开发组没有义务来解决用户自己的问题（甚至可能压根就不是用户或开发者的问题）。

辨认网络问题需要自行在弹窗或任务中心中查看错误信息。
关键词：SSL、TooManyRequests、远程主机关闭了连接、Connection reset by peer、补全游戏资源失败

:::

***

### 基于ConnectX的联机

#### A. 无法加入联机房间/联机游戏

##### 可能性1：没有在系统防火墙中放行

* 症状：点击【连接到服务】等待太久
* 解决方法：根据网络上提供的适合你的系统的方法，为LauncherX通过防火墙放行

***

##### 可能性2：当前网络安全等级过高

* 症状：用户能加入ConnectX的游戏房间，但是看不到游戏世界
* 解决方法：在Windows的网络设置中，设置当前网络为**专用网络**。为了你的设备安全，不要在你不熟悉的网络环境启用专用网络。

***

##### 可能性3：当前NAT级别过高

* 症状：直连模式下，无法稳定保持连接，或完全无法加入ConnectX房间
* 解决方法：改用更宽松NAT环境的网络，或在创建房间时启用中继连接。*中继连接使用我们的免费中继服务，这其中包含我们自己租赁的云服务器，也接纳中继节点赞助。请考虑通过爱发电赞助来维持所有人使用中继连接！*

***

##### 可能性4：游戏使用不同的IP协议

* 症状：在游戏中看不到游戏世界
* 解决方法：（所有人）尝试在LauncherX设置【全局-启动器行为】确认打开【强制使用IPv4堆栈】，然后重启游戏。*打开这个开关将会导致游戏无法连接到IPv6的服务器。*
* 常见于：Forge修改后的游戏

***

##### 可能性5：Mod导致的联机异常

* 症状：进行整合包联机时，出现异常。
* 解决方法：自行排查导致异常的mod。

***

##### 可能性6：网络环境太差

* 请联系运营商或网络管理员。这常见于受管制的公司网络或学校网络。

***

##### 可能性7：游戏开放的局域网世界绑定在异常网卡/IP段

* 症状：找不到游戏世界。且有玩家的本地网络IP段与其他玩家不同（通过电脑上启动两个游戏并在其中一个开放本地世界，在另一个游戏的多人游戏中找到的局域网游戏入口处可以看到实际的本地IP）
* 解决方法：IP段与其他玩家不同的玩家需要自行尝试调整网络设置，或使用其他网卡作为联网首选。

***

#### B. 提示缺失组件

* 症状：在点击联机按钮后，弹窗内提示缺失VCRedist
* 解决方法：自行下载安装VCRedist完整版本。

***

### 整合包相关

#### A. 无法拖入安装资源/整合包

* 症状：拖入任何文件均无反应
* 解决方法：不要使用管理员模式启动LauncherX
* 常见于：Windows

***

***

::: info 文章信息

上次更新：2025年9月15日

本文维护者：@fr1g, ...

// 本文维护者在首次更新本文时应该在此接上自己在Github的用户名

:::

---

---
url: /zhTW/projbobcat/resourceCompleter/createAndConfigCompleter.md
---
# 建立和配置補全器

\[\[toc]]

## 初始化補全器

建立一個資源補全器的方法非常簡單, 您只需要使用下面的程式碼即可完成補全器的初始化：

```c#

var completer = new DefaultResourceCompleter
{
    MaxDegreeOfParallelism = [MAX_DEGREE_OF_PARALLELISM],
    ResourceInfoResolvers = new List<IResourceInfoResolver>
    {
        ... // 資源資訊解析器的初始化
    },
    TotalRetry = [NUMBER_OF_TOTAL_RETRY],
    CheckFile = [CHECK_FILE_AFTER_DOWNLOADED],
    DownloadParts = [TOTAL_DOWNLOAD_SEGMENTS_FOR_LARGE_FILE]
};

```

::: tip

資源資訊解析器的初始化相關教程請參見 [資源資訊解析器](/zhTW/projbobcat/resourceCompleter/resourceInfoResolver/index) 章節

:::

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|                    專案                    | 資料型別    |              說明              |
|:----------------------------------------:|:--------|:----------------------------:|
|       \[MAX\_DEGREE\_OF\_PARALLELISM]        | INT     |    資源檢查並行程度（同時檢查遊戲資源的數量）     |
|      \[CHECK\_FILE\_AFTER\_DOWNLOADED]       | BOOLEAN |  在檔案下載完成後檢查檔案完整性（如果存在資源校檢碼）  |
| \[TOTAL\_DOWNLOAD\_SEGMENTS\_FOR\_LARGE\_FILE] | INT     |         大檔案下載時的分片數量          |

::: warning

**\[MAX\_DEGREE\_OF\_PARALLELISM]** 和 **\[TOTAL\_DOWNLOAD\_SEGMENTS\_FOR\_LARGE\_FILE]**
的數值大小請視硬體效能酌情調整, 設定過大的數值可能會導致會導致吞吐量的下降.

:::

## 補全遊戲資源

在完成資源補全器的初始化操作後, 您只需要呼叫補全方法即可開始執行檢查和補全操作：

在非同步上下文中, 使用 **CheckAndDownloadTaskAsync** 來完成安裝：

```c#

var result = await completer.CheckAndDownloadTaskAsync(); // [!code focus]

if (result.TaskStatus == TaskResultStatus.Error && (result.Value?.IsLibDownloadFailed ?? false))
{
    // 在完成補全後, 資源檢查器會返回執行結果. 
    // 您可以檢查 result 中的屬性值來確定補全是否完成
    
    // IsLibDownloadFailed 會反映啟動必須的庫檔案是否已經成功補全
    // 通常來說, 如果庫檔案的補全失敗, 很有可能會導致遊戲的啟動失敗
}

```

在同步上下文中, 使用 **CheckAndDownload** 來完成安裝：

```c#

var result = completer.CheckAndDownload(); // [!code focus]

```

## 報告進度

在某些情況下, 資源補全器可能會需要數分鐘的時間來完成資源的檢查和下載.
因此, 您可能需要實時向用戶彙報補全器目前的進度.

### 報告資源檢查器的進度

您可以透過註冊事件 **GameResourceInfoResolveStatus** 來獲取實時的檢查進度：

```c#

completer.GameResourceInfoResolveStatus += (_, args) => 
    { ReportProgress(args.Progress, args.Status); };

```

其中,  **args.Progress** 指示了檢查器當前的百分比進度. **args.Status** 則是檢查器當前進度的文字描述.

### 報告補全器檔案下載進度

您可以透過註冊事件 **DownloadFileCompletedEvent** 來獲取實時的檢查進度：

```c#

completer.DownloadFileCompletedEvent += (sender, args) =>
{
    // sender 引數為補全器上一個成功下載的檔案, 型別為 DownloadFile
    // args 返回了該檔案的下載狀態（成功 / 失敗）, 以及檔案的重試計數, 
    // 型別為 DownloadFileCompletedEventArgs
};

```

::: tip

* [DownloadFile 類結構](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/DownloadFile.cs)
* [DownloadFileCompletedEventArgs 事件結構](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Event/DownloadFileCompletedEventArgs.cs)

:::

### 報告下載中的檔案的進度資訊

您可以透過註冊事件 **DownloadFileChangedEvent** 來獲取實時的檢查進度：

```c#

rC.DownloadFileChangedEvent += (_, args) =>
{
    // args 返回了下載中的檔案的具體資訊（已接收的位元組數、總共的位元組數、當前速度、百分比進度）
    // 型別為 DownloadFileChangedEventArgs
};

```

::: tip

* [DownloadFileChangedEventArgs 事件結構](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Event/DownloadFileChangedEventArgs.cs)

:::

---

---
url: /zhCN/lxguide/startup.md
---
# 开始

欢迎使用LauncherX！我们不断致力于为您打造美观便捷的使用体验。

\[\[toc]]

> 本文创建日期：2023年7月14日，修改日期：2024年3月6日，作者：Feiron Iguista

***

::: warning

请注意：LauncherX不在任何一个平台上支持32位或更低的操作系统。

:::

## 环境要求

基本上，对于所有的桌面环境，前置条件基本上是一致的。

首先，为了能够让LauncherX稳定地大展拳脚，您的**电脑需要满足以下条件**:

**软件要求**

Windows7及更新版本的64位操作系统、Windows 10 或更新版本的 for ARM 64位操作系统 *或*    macOS 12 及更新版本 (基于Intel芯片或Apple芯片) *或*    带有Xfce/GNOME之类桌面环境的Linux 64位操作系统 (建议内核版本高于5).

**硬件要求**

**CPU**: 主频高于2.5GHz的至少4核心64位处理器 (amd64/ARM64/x86-64)**运行内存**: 不少于4GB        **GPU**: 建议性能高于: Intel UHD 770 (集成显卡) / 建议性能高于: Radeon RX560**存储空间**: 预留100MB (Windows: ~30MB，Linux和macOS: ~60MB。预留更多空间以供下载等缓存使用。实际上安装游戏需要为游戏预留一定空间。)

## 下载LauncherX

接下来，该**下载LauncherX**了:

我们推荐优先使用**包含运行时的独立版**。请前往[官网下载](https://corona.studio/launcherx/download)稳定版，或赞助我们以取得测试版；或者在我们的**配置助手**发布后，使用配置助手来为您选择合适的LauncherX。这将是最适合普通用户的方案（敬请期待）。

下载LauncherX的一般流程如下：

* 打开[官网](https://corona.studio/launcherx/download)

* 一般而言，网页会根据你的电脑来推荐下载的版本。你需要下载对应你电脑系统和CPU架构的版本，如果网页选择了和你电脑情况不一致的版本，请用下载按钮右侧的**三角按钮**（如果是MIN站 ，直接在网页上点击对应正确构建的按钮来开始下载）来选择正确对应你电脑的选项。如果你不知道如何确认你的电脑系统版本和CPU架构，参见：[辨识计算机环境 | 日冕知识库](/zhCN/guide/general/check-system.html)
  :::tip 截至目前，大多数用户使用的是Windows x64。

* 下载完毕后，将LauncherX解压并放置到一个合适的地方。
  :::tip 关于存放位置
  macOS建议放在【应用程序】(也就是说Applications) 目录下; Linux可以放在任何你常用于存放程序的地方，Windows同样，但是**不要放在桌面或其他难以打理的地方**，最好放在一个空文件夹里，因为Windows版LauncherX会在当前所在位置解压出自己的工作目录和默认的游戏文件夹。
  Linux和macOS版本的LauncherX会在一个合适的地方存储LauncherX的配置文件和默认游戏目录，电脑上任意地方的LauncherX将共用该配置文件；Windows版本则会在每个LauncherX所在的位置创建独立的默认游戏目录和配置文件。

  :::

## 开始使用LauncherX

那么现在，无论是Windows，macOS还是Linux某个带桌面环境的发行版，也无论架构是x86-64，x86-S，amd64还是ARM64，您已经根据当前操作系统下载好了对应的LauncherX到您希望其所运行的文件夹中。那么您就可以像运行其他程序一样双击它的图标来运行了。

接下来，面对所有已知可能出现的问题，您都可以在此系列文档的【初次启动】部分 (按操作系统不同分成三篇) 找到说明并了解可能的解决方法。

::: info

由于设备不同，您在初次启动时可能会遇到些小麻烦，为此我们感到十分抱歉。我们正在努力解决这些严重影响体验的问题，因而本文将会不定期发生变更，恕不另行通知。

如果需要提供反馈，请参考：[报告异常&建言新策 | 日冕知识库](/zhCN/lxguide/report-issue.html)

:::

## 共有的问题

由于我们的Java运行时检测机制是通过 “搜索-执行” 模式工作以确认该运行时是否可用，所以在您启动LauncherX时候，可能会遇到来自Java的错误弹窗。您完全可以直接将它关闭，因为这并不影响LauncherX运行; 且如果您没有选择任何一个被LauncherX判断为有问题的JRE作为游戏启动所使用的Java，那么您的游戏启动几乎不可能受到受损JRE的影响。由于每次LauncherX启动都会检查搜索到的JRE是否可用，因此您应该将该受损的运行时**移除**，或者用自动化窗口关闭工具（比如 火绒弹窗拦截）对错误弹窗进行精准打击。

## 下一步

假设您的LauncherX现在能正常运行，但是您不知道接下来该做什么？参考：[安装游戏 | 日冕知识库](/zhCN/lxguide/features/installing-games.html)，下载并安装您的游戏。

在提问前应该**先在本站查阅**，对于一些常见问题，我们时常会更新这篇文章：[常见问题 | 日冕知识库](/zhCN/lxguide/faq.html)

已经加入了内部测试？参考：[切换更新通道 | 日冕知识库](/zhCN/lxguide/others/switch-channel.html)

---

---
url: /zhCN/lxguide/features/tricks.md
---
# 怎么做到的？好怪，再看一眼

这里还有一些使用LauncherX时候的“奇技淫巧”。

奇技具有以下特征：

* 通过有技巧性的操作实现原本LauncherX本不明确支持的功能
* 在原理上并未利用bug
* 或许是隐藏功能

如果你发现了什么新的奇技，可以和我们分享。我们或许会在整理后发布在这里。

---

---
url: /zhCN/lxguide/features/tricks/debug-lang-file.md
---
# 我想贡献多语言了！

::: tip 太好了！

感谢您，热心市民！贡献多语言的仓库在这里：[Corona-Studio/LauncherX-i18n: The i18n project for LauncherX (github.com)](https://github.com/Corona-Studio/LauncherX-i18n)。

关于提交，您若有不了解的地方，可以参考：[提交本地化翻译贡献 | 日冕知识库](/zhCN/guide/general/contribute-to-i18n)

:::

当LauncherX文件夹（与LauncherX.json同级的名为LauncherX的文件夹）中包含有一个`External.axaml`之后，启动LauncherX，就可以在LauncherX的**设置-外观-文本**中找到一个名为 `[开发者]使用外部语言文档进行调试` 的开关。打开它后，将会强制使用这个External.axaml作为当前的语言文件，并且伴有明显的水印注明这是测试模式。

## 为什么需要这个？

实际上，LauncherX中许多文本块只是针对汉语汉字量身定制的。这意味着，如果使用其他语言表达，则或多或少会出现以下问题：

* 显示效果不佳
* 无法完整显示内容
* 文本使界面变形
* ...

使用这个功能可以帮助翻译贡献者灵活确认表达方式，是否需要使用缩写？这样/那样写会不会导致表意不明？总之，需要找到一种 “ ‘信达雅’ 与 ‘合适’ 之间的平衡点”。

## 为什么崩溃？

或许您在使用过程中，某次重启LauncherX时候遇到了崩溃，可能有以下原因：

* 标签、键名等出现重复
* 文件无效或损坏
* 标签或键名的尖括号或引号未闭合/或发生了意外的闭合
* 模板字符串的大括号（比如：{0} 需要使用 {1}）被破坏
* 文件内出现了非法的符号（有没有在标签之外的地方出现奇怪的符号？）
* ...

请在其中找到问题然后解决，然后再次尝试打开LauncherX。如果想要获得详细的崩溃原因，请参考：[好好利用日志文件! | 日冕知识库](/zhCN/lxguide/others/report-with-logs)

---

---
url: /zhCN/guide/contact.md
---
# 指路官方

###### 与我们取得联系！

*更新于：2024年3月23日*

| 平台                          | 联系方式                                                     |
| ----------------------------- | ------------------------------------------------------------ |
| QQ群（LauncherX 1）           | 589798569                                                    |
| QQ群（LauncherX 2）           | 772039197                                                    |
| QQ群（CMFS）                  | 419902868                                                    |
| QQ群（ProjBobcat）            | 677872263                                                    |
| QQ群（新成员审核）            | 1040526762                                                   |
| #########                     | ########                                                     |
| Bilibili                      | [llr老腊肉](https://space.bilibili.com/31267692)             |
| 合作QQ频道(包含LauncherX支持) | [「我的世界」](https://pd.qq.com/s/1qab65hj3)                |
| KOOK                          | [CoronaStudio](https://www.kookapp.cn/app/invite/rCdGVn)     |
| 酷安                          | [CoronaStudio](https://www.coolapk.com/feed/24778166)        |
| MineBBS                       | [CoronaStudio](https://www.minebbs.com/members/coronastudio.83949/) |

::: warning

部分联系方式可能不对所有地区的用户开放。

:::

---

---
url: /zhCN/guide/general/contribute-to-i18n.md
---
# 提交本地化翻译贡献

::: tip 感谢您的无私工作！

本文将以LauncherX i18n提交为例，通过 `Github Desktop` 提交贡献内容。

简而述之，大体的步骤为：确认提交贡献的项目仓库-fork-提交修改-提交Pull Request-等待合并

:::

\[\[toc]]

## 准备工作

::: info 先决条件

* 您持有一个Github账户， 且具备连接到Github的方法与能力
* 您当然可以是个Git新手。或许您可以去查看：[协作处理拉取请求 - GitHub 文档](https://docs.github.com/zh/pull-requests/collaborating-with-pull-requests) 来了解一般的工作模式
* 您下载了Github Desktop并且在上面登陆了您的Github账户

:::

与其他我们公开征集贡献的仓库一样，您需要先登陆好您的Github账户，然后打开[Corona-Studio/LauncherX-i18n: The i18n project for LauncherX (github.com)](https://github.com/Corona-Studio/LauncherX-i18n)，找到【fork】按键，点击它。

接下来可以按照默认的设置，直接点击【Create Fork】进行下一步。一切正常的话，您此时应该会被导航到您名下的fork仓库。您的提交都需要先暂存在这里。

## 开始操作

### 1) 提交到名下的fork

1. 在您名下的fork仓库页面，点击【Code】按钮，它一般具有特别的颜色

2. 点击【Open in Github Desktop】。如果浏览器询问您是否允许此网站打开Github Desktop，请允许

3. 确保连接可用性，然后在您方便使用的路径下，点击【Clone】然后等待完成

4. 完成后，您可以通过诸如Visual Studio Code之类的编辑器进行编辑。变更产生后，您将可以将内容提交到您的fork仓库。

   ![githubDesktopUI](/img/general/misc/ghdesktop-example-ui.png)

   左侧您可以看到作出更改的文件，左下方的第一个输入框是必填的，这里概述您此次提交做了什么；而第二个可用于对第一个输入框的补充说明。完成了这方面的填写，即可点击下方的【Commit to xxx】提交更改。

5. 此时，如图中显示为 “Pull origin” 的按钮处会变为 “Push origin”，点击它将可以把本地仓库的变更同步到Github上托管的您名下的fork仓库。

### 2) 将名下的fork仓库内容提交到我们的上游仓库

在您的变更提交到您名下的fork仓库之后，还没完：

1. 打开我们的上游仓库（在您名下的仓库会显示 “**forked from xxx**”，点击这个链接可以前往我们的上游仓库）
2. 点击【Pull Requests】（这个按钮和Code、Issues等标签类按钮同级）
3. 点击【New pull request】
4. 点击【compare across forks】
5. 点击切换【head repository: 】中的内容，切换到您名下的fork仓库，然后点击【Create pull request】
6. 填写简要的说明\[1]和详细的说明\[2]（如有必要），然后点击【Create pull request】
7. 等待我们进行审核、编辑和合并即可！在通过之后，您会收到邮件提醒（取决于您的Github设置）

### 3) 同步我们的上游仓库

我们的上游仓库时不时会有内容更新，这可能来自管理员，也可能来自其他贡献者。

#### a) 同步仓库

1. 在浏览器中打开您名下的fork仓库
2. 点击Sync with upstream（或其他文字链接，类似于此）
3. 请注意：这可能导致您的未提交修改内容丢失。但是好在Git会保存您的历史记录。
4. 在Github Desktop中，点击Fetch Origin以从Github获取仓库最新信息。如果有更新变更，此处会变为【Pull origin】按钮可供点击。
5. 点击【Pull origin】以将仓库的新变更拉取到本地。

#### b) 处理冲突

来自各方的修改都可能引发冲突，即便绝大多数情况下冲突都由我们来辨识和处理解决。但是当您遇到冲突，请按照Github Desktop的提示和冲突检查器找到冲突的行。一般而言，冲突与原文可能以以下格式展示：

```txt
>>>>>>>> 
冲突，来自上游
========
原文，您的内容
<<<<<<<<

// 请以实际情况为准
```

您需要自行确认哪些内容是您需要保留的。将不需要的内容包括**冲突标识符**（）一并删除后，在Github Desktop中mark as resolved（或等待它自行检查）

参考文章：[在 GitHub 上解决合并冲突 - GitHub 文档](https://docs.github.com/zh/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/resolving-a-merge-conflict-on-github)

## 跋&注意事项

* 测试您的语言文档，参见：[我想贡献多语言了！ | 日冕知识库](/zhCN/lxguide/features/tricks/debug-lang-file)

* 您可能在此期间遇到各种问题。欢迎来到我们任何一个交流群中就您遇到的问题提问，但是我们更希望您可以自己先去使用搜索引擎或聚合类AI查询相关的解决方法。

* ::: warning 不要修改别人的内容

  您应该专心于自己主要贡献的部分。如果您认为其他人的什么地方写的有问题，可以先通过issue提交您的意见和建议。

  :::

---

---
url: /zhCN/guide/code_of_joining_application.md
---
# 新成员审核规则

编辑中，编辑完成后将会由llr复核然后公开.

---

---
url: /zhCN/guide/account.md
---
# 日冕账户 CSA

日冕账户(Corona Studio Account，CSA) 是对于绝大多数由我们提供在线服务可用的账户，用于识别唯一的用户。为了防止出现一些不必要的纠纷，请不要外借您的账户。

如需删除账户，请登录到[corona.studio](https://corona.studio/user)后，在[个人中心](https://corona.studio/user)找到注销账户的按钮。此操作不可逆，将会删除包括我们保存的必要用户数据、赞助记录、皮肤站信息（如有）之内的一切数据。

---

---
url: /zhCN/CMFS/servers/pure/exam.md
---
# 日冕重工 审核服务器

这个服务器是专供有意愿加入日冕重工的朋友进行能力考核的内部原版创造模式服务器。

---

---
url: /zhCN/lxguide/features/tricks/icons.md
---
# 更多LauncherX图标

::: info 即将到来

我们将在合适的时间开始提供一些LauncherX图标下载，敬请期待！

:::

预计将在地址 <https://iconeks.kami.su/lx> 提供一些预处理的多样图标可选。

---

---
url: /zhCN/mc-starter/useful-links.md
---
# 有用的链接（建议收藏）

这里存放了一些游玩Minecraft Java版时可能经常用到的链接。

点击链接后可能会要求登录。

| 链接                                                         | 介绍                         |
| ------------------------------------------------------------ | ---------------------------- |
| [Realms管理](https://www.minecraft.net/en-us/msaprofile/myrealms) | 用于管理当前账户的Realms订阅 |
| [更改皮肤](https://www.minecraft.net/en-us/msaprofile/mygames/editskin) | 用于修改当前账户的皮肤和披风 |
| [更改ID](https://www.minecraft.net/en-us/msaprofile/mygames/editprofile) | 用于更改当前账户的玩家名称   |

---

---
url: /zhCN/CMFS/servers/project-lappland/rules.md
---
# 服务器规则

\[\[toc]]

## 禁止

* 原版生电
* 卡服以及其他创造大量实体的行为
* 不宣而战 - 偷袭行为和其他不正当破坏行为将受到惩罚
* 破坏任务地点
* 利用bug的其他恶性的行为
* 围堵任务地点或副本入口
* 其他违反公序良俗的行为

## 明确允许

* 向任何非保护期内的聚落宣战（必须先通过系统功能发起）
* 约架PVP（必须通过系统功能发起，且参与双方都将临时启用死亡不掉落）

---

---
url: /zhCN/CMFS/servers.md
---
# 查看附属服务器和子服务器

CMFS系列游戏服务器基本可分为纯净服和模组服两种。其中，纯净服组成一个群组服网络，而模组服基本各自独立。

---

---
url: /zhCN/guide/standard.md
---
# 标准说明文档

这里保存着公开的日冕产品测试标准等标准的说明文档.

---

---
url: /zhCN/lxguide/settings/special/check-network.md
---
# 检测网络：

###### 利用 LauncherX 的“网络–>网络连接测试”功能来判断您当前网络环境

LauncherX 在“**网络–>网络连接测试**”中准备了一套便捷的网络测试工具。您可以使用它并根据它的返回内容来判断游戏相关的网络服务在您当前的互联网环境中的可用性。

\[\[toc]]

***

### 使用

打开 LauncherX 的“设置”，在“网络”选项卡中滚动到页面靠底部的位置，您可以找到“网络连接测试”设置项。点击下方的“启动”按钮，您可以开始一次新的网络测试。

稍后，下列的每一项测试都会有一个结果被展示出来。

### 返回结果

本段介绍一切可能的返回结果，并解释背后部分可能的的原因。

如下所示，一般而言，每一项的检测结果会直接影响项目展现的颜色。

::: info

**（服务稳定）延迟：???ms \[超时或出错?次]**

这意味着您可以正常访问该服务，但是具体效果仍然视网络性能而定。

:::

::: warning

**服务出现波动，可能会出现暂时性的服务中断，或是由于您本地的网络问题导致丢包严重。**

这意味着您有可能会无法访问该服务。如果您无法进一步优化网络环境，则请多一些重试的耐心。

:::

::: danger

**服务出错，目前已停止提供服务，或是由于您本地网络的原因导致无法成功与服务器通讯。**

在测试中许可的重试机会次数范围内没有一次是成功连接上该服务的，这意味着如果您必须使用该服务的话，您将必须为此优化您的网络连接。

:::

### 测试条目

*这里的内容随时可能会变更。一般会在 LauncherX 具体的内容出现更新后的第一时间内出现修改。*

截止到2023年11月28日，LauncherX 会对以下服务进行测试，包括但不限于来自游戏官方的服务和我们的服务、第三方提供的服务等。

* `corona.studio`：这是我们的官网。
* `api.corona.studio`：这是我们的服务接口地址。它提供了这些服务：日冕账户登录、权限认证、联机建立、新闻信息获取（部分）、检查更新。
* `minecraft.net`：这是 Minecraft 官网。它可能主动屏蔽了检测信号从而显示为“服务出错”。
* `session.minecraft.net`：这是用于登陆验证的
* `account.mojang.com`：这是提供 Mojang 账号管理的地址。在使用 Microsoft 账户登陆的今天显得没那么必要了。
* `authserver.mojang.com`：这是 Mojang 用于正版登陆账号验证的服务。在尝试登入开启正版验证的服务器时，服务器会与之建立连接并查询您的登录信息。这意味着您首先得能与其建立连接并获取一个有效的会话。*相关参考文章*：[解决“无效的会话”问题](/zhCN/CMFS/help/invalid-session)
* `sessionserver.mojang.com`：同上，这是用于鉴定您是否是正版玩家的服务。
* `api.mojang.com`：这里提供了一系列 Mojang 官方的服务，包括您的正版账户的UUID等信息。
* `textures.minecraft.net`：这里保存着您正版账户的皮肤，用于我们 “游戏帐户管理” 中的 “皮肤预览” 和 “游戏帐户头像” 。
* `mojang.com`：这是 Mojang 的官网。
* `resources.download.minecraft.net`：这是 Minecraft 官方的资源下载服务，如果您无法访问该服务，请尝试在下载游戏资源时候让 LauncherX 自动选择下载服务器或选用另外两个镜像下载服务。*相关参考文章*：[LauncherX设置 分类：“网络”](/zhCN/lxguide/settings/item/network)
* `libraries.minecraft.net`：同上。
* `launchermeta.mojang.com`：保存了一些启动器必须的游戏信息，在安装新游戏的时候会需要它。
* `bmclapi2.bangbang93.com`：由 bangbang93 提供的游戏资源下载服务。如果您在中国大陆境外，则可能无法访问此服务。虽然与我们关系不大，但是您可以考虑为了这个公益性质的下载服务存活并变得更好而[赞助BMCLAPI](https://bmclapidoc.bangbang93.com/#)
* `download.mcbbs.net`：由MCBBS提供的游戏资源下载服务。他们貌似也默认屏蔽了除了中国大陆以外的所有连接。
* `addons-ecs.forgesvc.net`：这是 CurseForge API，用于下载和安装 Mod（也用于CF格式的整合包安装）。*相关参考文章*：[安装整合包到游戏目录](/zhCN/lxguide/features/modpack-support)

###### *弃用的检测项*

* 暂无

###### *勘误*

::: details

暂无

:::

---

---
url: /ruRU/CMFS.md
---
# 欢迎来到 CMFS 指南

首先, 感谢你选择加入 CraftMineFun Server Minecraft群组服务器（以下简称CMFS）. 本系列指南将会帮助你理解关于CMFS的一切, 并发挥你的主观能动性, 利用我们提供的特色玩法来建设、游览.
和您的朋友们一起, 抑或是在这里认识新朋友, 合作游玩, 或者竞赛角逐.
请放心, 由我们的团队来维护您的体验.
如果您遇到了游玩体验上的问题, 请**立即联系我们**！

\[\[toc]]

:::warning 所有服务器处于暂停运营的状态

请等待另行通知（2022年11月27日）

或加入群 **419902868** 等待第一时间的通知.

:::

## 组成部分

* CMFS-Pure 纯净生存服务器！您可以通过特定版本的Minecraft来加入游戏, 体验由我们精心构思的独特玩法. *这个服务器正在维护*
* CMFS-SquareCraft 枘方世界服务器 我们和枘方世界合作的Mod服务器. 在我们高性能的稳定的服务器中享受Minecraft“活的灵魂”：高度自由, 高度扩展.  *这个服务器处于设想状态*
* CMFS-Eksamen 您可以自由地加入这个服务器以申请进行日冕工作室的建筑组（日冕重工）的审核. 这里本质上是个原版创造模式建筑服, 在我们严格的环境中体现您的Minecraft建筑实力. 当我们有招新需求时, 会根据已提交审核的作品质量发出进一步审核的邀请：通过后, 您将加入我们的建筑组, 或许您不仅能在这里发展自身能力, 还能在这里发现同好？ *这个服务器正在构件中*
* CMFS-Juego 这里有我们准备的各种主流的小游戏和竞技场, 以及由我们构思的独特小游戏. 其中区分多个不同的游戏版本, 提供了不同时代的体验.  *这个服务器暂无负责人*
* CMFS-Login “四通八达. ” 这个服务器是整个CMFS的入口, 是负责分散诸位玩家到其想要到达的服务器的中转服务器. 您需要在这里通过CMFS账号或绑定CMFS账号的日冕服务账号来登入群组服.  *这个服务器需要和Pure一并重构*

## CMFS-Pure 指南

---

---
url: /zhCN/CMFS.md
---
# 欢迎来到 CMFS 指南

——首先，感谢你选择加入 CraftMineFun Server - Minecraft群组服务器（以下简称CMFS）。本系列指南将会帮助你理解关于CMFS的一切，并发挥你的主观能动性，利用我们提供的特色玩法来建设、游览。和您的朋友们一起，抑或是在这里认识新朋友，合作游玩，或者竞赛角逐。请放心，由我们的团队来维护您的体验。如果您遇到了游玩体验上的问题，请**立即联系我们**！

:::warning 存在服务器处于暂停运营的状态

请等待另行通知（2025年2月27日）

或加入群 **419902868**(CMFS主群) 等待第一时间的通知。

:::

## 组成部分

### CMFS-Pure

负责人：法棍`#纯净群组` `#生存` `#插件`

*暂时因技术原因停服*

***

### CMFS-Lappland

负责人：法棍`#RPG` `#生存` `#轻剧情` `#MOD` `#原创`

*正在策划中，敬请期待！*

此服务器计划正在招贤纳士！

***

### CMFS-Radost

负责人：Dxir`#纯净群组` `#小游戏` `#多版本`

*正在建造中，敬请期待！欢迎入伙共建！*

---

---
url: /ruRU/guide.md
---
# 欢迎来到日冕知识库（CSKB）

在这里您可以查阅到日冕工作室所属项目的部分技术文档、疑难解答, 以及 Minecraft 相关的各种技术规范和样例

---

---
url: /zhCN/guide.md
---
# 欢迎来到日冕知识库（CSKB）

在这里您可以查阅到日冕工作室所属项目的部分技术文档、疑难解答，以及 Minecraft 相关的各种技术规范和样例

---

---
url: /zhTW/CMFS.md
---
# 歡迎來到 CMFS 指南

首先, 感謝你選擇加入 CraftMineFun Server Minecraft群組伺服器（以下簡稱CMFS）. 本系列指南將會幫助你理解關於CMFS的一切, 併發揮你的主觀能動性, 利用我們提供的特色玩法來建設、遊覽.
和您的朋友們一起, 抑或是在這裡認識新朋友, 合作遊玩, 或者競賽角逐.
請放心, 由我們的團隊來維護您的體驗.
如果您遇到了遊玩體驗上的問題, 請**立即聯絡我們**！

\[\[toc]]

:::warning 所有伺服器處於暫停運營的狀態

請等待另行通知（2022年11月27日）

或加入群 **419902868** 等待第一時間的通知.

:::

## 組成部分

* CMFS-Pure 純淨生存伺服器！您可以透過特定版本的Minecraft來加入遊戲, 體驗由我們精心構思的獨特玩法. *這個伺服器正在維護*
* CMFS-SquareCraft 枘方世界伺服器 我們和枘方世界合作的Mod伺服器. 在我們高效能的穩定的伺服器中享受Minecraft“活的靈魂”：高度自由, 高度擴充套件.  *這個伺服器處於設想狀態*
* CMFS-Eksamen 您可以自由地加入這個伺服器以申請進行日冕工作室的建築組（日冕重工）的稽核. 這裡本質上是個原版創造模式建築服, 在我們嚴格的環境中體現您的Minecraft建築實力. 當我們有招新需求時, 會根據已提交稽核的作品質量發出進一步稽核的邀請：通過後, 您將加入我們的建築組, 或許您不僅能在這裡發展自身能力, 還能在這裡發現同好？ *這個伺服器正在構件中*
* CMFS-Juego 這裡有我們準備的各種主流的小遊戲和競技場, 以及由我們構思的獨特小遊戲. 其中區分多個不同的遊戲版本, 提供了不同時代的體驗.  *這個伺服器暫無負責人*
* CMFS-Login “四通八達. ” 這個伺服器是整個CMFS的入口, 是負責分散諸位玩家到其想要到達的伺服器的中轉伺服器. 您需要在這裡透過CMFS賬號或繫結CMFS賬號的日冕服務賬號來登入群組服.  *這個伺服器需要和Pure一併重構*

## CMFS-Pure 指南

---

---
url: /zhTW/guide.md
---
# 歡迎來到日冕知識庫（CSKB）

在這裡您可以查閱到日冕工作室所屬專案的部分技術文件、疑難解答, 以及 Minecraft 相關的各種技術規範和樣例

---

---
url: /zhCN/skript/register-entry.md
---
# 注册起始点

:::tip 本文中起始点是包含了Event、Function、Command之类触发脚本具体逻辑的、作为一段脚本第一行和其相关配置的内容.

:::

\[\[toc]]

## 定义

**起始点** :   是定义一段脚本触发起点的语句，一般包含事件、方法、指令。严格来说，指令注册相当于一种特殊的事件监听，而指令也可以视为一种可以在游戏或控制台中快捷调用的方法。

## 类型

### Event 事件

事件是最基础的、与Bukkit事件关联紧密的触发器，一般随着事件触发也会附带一些和当前触发事件相关的局部变量，但是这些事实上的局部变量使用 表达(expression) 的方式使用。比如对于事件`on explode`，存在表达`event-location`表示「单个爆炸事件发生时的位置」，诸如此类。它们传递了事件相关的具体信息。此外，如果您学过JavaScript，可以将这一系列表达视为 object.addEventListener(event，eventCallback，…) 中，eventCallback可以作为参数接受的Event对象.

要注册事件，将事件以0缩进置于单行，并在事件名称后加上冒号，换行后的内容直到下一个起始点之前都属于一段脚本.

```skript
 # 注册投掷物击中事件监听
 on projectile hit:
 		event-block is gravel:
 				broadcast "Hit on a gravel" 
```

### Function 方法/函数

方法是相对安全的一段被封装的逻辑，可以返回一个值用于在调用后赋值给变量。它可以接受多个参数并进行处理.

要注册方法，以0缩进开始按照格式编写方法声明:

```skript
# 如果需要返回值 (即，如果方法计算结果需要被赋值给变量(插入字符串也算赋值变量)):
function NameOfFunction(argumentName: <Type> ...):: <Optional Return Type>:

# 或者，如果不需要返回值(返回为void/<null>):
function NameOfFunction(argumentName: <Type>):

# 换行后的一个缩进内容开始即为方法的逻辑内容
# <Type>/<Optional Return Type>为传入参数的sk内置类型，比如: text，player，number...
# 方法名不可重复.
```

并在次行以一个单位的缩进开始编写逻辑.

换行后的内容直到下一个起始点之前都属于一段脚本方法的内容.

### Command 命令

命令可以视为一个可通过游戏内指令触发的方法，因为它可以接受参数。但是它不能替代方法，原因是:

* 不能直接返回值到调用的脚本语句中。但是可以在处理逻辑的最后将结果赋值给一个全局变量.
* 脚本内调用任何命令都必须使用`make xxx execute command`， 因此传参类型的选择更少.

要开始定义一个命令，需要以0缩进开始按格式编写命令声明:

```skript
 # 请通过实际测试来确认同名指令覆盖的情况.
command /commandName <...args>: # 在此之后一个缩进的内容是声明命令的属性.
		<...properties>
		trigger:
				
				# 在trigger后一个缩进的内容会被视为命令的逻辑内容.
				
 # <...args>: 可选的参数定义。如果希望命令能够接受参数，使用以下方式为参数添加「槽位」:
 		# command /commandName [<Type>]:  
    # 实际使用中，预留的参数位可以不填。对应的逻辑需要在编写脚本逻辑时候自行判断.
    # 依照定义的参数顺序，可以在逻辑中使用expression “arg-x” (x为从1开始的参数序号)来取得传入的值.
    # 比如: command /ACommand [<text>] [<text>]: 接受两个参数，arg-1即为第一个[<text>]
    
 # <...properties>: 除了trigger这个必要属性之外的一切可选属性。下文会介绍各个可选属性.
 # 这些属性都需要在trigger之前.
```

:::warning 请注意

在实际运用中，可能会出现命令传入数字然后进行计算的情况。但是Skript解释器有可能将`arg-1`识别为「arg减去1」.

为了避免这种情况引发的意外，请尝试改用以下expression中的其他形式表达参数

:::

源代码中，解释器接受以下表达来指代参数:

```sk
[the] last arg[ument][s]
[the] arg[ument][s](-| )%number%
[the] (1st|2nd|3rd|4-90th) arg[ument][s]
[the] arg[ument][s]
[the] %type%( |-)arg[ument][( |-)%number%]
[the] arg[ument]( |-)%type%[( |-)%number%]
```

示例:

```sk
the last argument
arg-1
argument 6
13th arguments
the argument
the player argument
arg-item type-3
```

摘抄自: [Skript Hub Tutorial文章 by Blueyescat](https://skripthub.net/tutorials/10)。

## 扩展

### Command声明时的可选属性

可选属性的值直接用双引号包裹并写在属性名的冒号后方.

**executable by**: 可被执行的对象，可选: player，command block，console
　　**usage**: 接受text，用于向客户端返回此命令的用法.
　　**description**: 接受text，提供给其他插件的命令描述。
　　**permission**: 接受text，可以是权限管理插件的权限组.
　　**permission message**: 接受text，在无权限使用指令时的错误信息。比如「你无权使用!」
　　**cooldown**: 接受数字+时间单位，这是命令使用的冷却时间。比如: cooldown: 10 seconds
　　**cooldown message**: 接受text，在尝试于冷却期内使用命令时的错误信息.
　　**cooldown bypass**: 接受text，可以绕过冷却的权限名称，可以是权限管理插件的权限组.
　　**cooldown storage**: 接受一个变量，将可以通过全局变量保存玩家的冷却阶段，并且冷却将在服务器重启/插件重载后持续生效。　　**aliases**: 接受直接输入，定义这个指令的别名

*待补充*

### options定义

一般可以将这类入口声明在文件最开头的地方。它接受一系列预设的变量定义。它不包含具体的逻辑.

在此定义的内容可以通过`{@Name}`作为变量调用.

---

---
url: /zhCN/lxguide/features/launch-test.md
---
# 测试启动

::: warning 兼容性问题
我们注意到，截止至2025年5月1日，Linux多数发行版无法使用此功能。
:::

\[\[toc]]

## 功能简述

这个功能可以通过系统终端/控制台来展示包括JVM错误在内的完整日志以供排除错误。

## 使用说明

1. 在游戏列表中找到需要调试的游戏
2. 点击游戏的设置按钮（）或双击游戏以打开游戏设置
3. 找到靠近窗口右上角的启动按钮（，往往带有一个红色的点状星号）并点击
4. 等待命令行窗口弹出
5. 若是需要提供反馈信息，请等待命令行完成运行停止滚动（对于游戏意外崩溃问题）并提供截图。后续如有需要请继续提供更多相关截图，故建议不要过早关闭该窗口。

---

---
url: /zhCN/lxguide/features/test-launch.md
---
# 测试启动

---

---
url: /zhCN/lxguide/features/gamelist.md
---
# 游戏列表

本文介绍了LauncherX游戏列表和管理机制

::: warning 只支持常见的版本隔离

LauncherX强制启用版本隔离，并且只支持版本隔离。这意味着官方游戏目录和MultiMC类游戏目录均不能直接供LauncherX使用。

在有关的游戏目录转换工具出现后，将会更新此文章并附加使用说明。

:::

\[\[toc]]

## 基本功能

LauncherX的游戏列表提供了最基本的已安装游戏的展示功能。

首先，如果没有游戏被安装，此处将显示为：【 无】。

当当前游戏目录存在游戏时，将会展示一个类似表格列表的界面。

### 表头

表头由【更多】、【游戏名称搜索框】、【版本】、【游戏时长】、【操作】四栏组成。其中，【更多】是可以点击的菜单按钮；【游戏名称搜索框】可以键入文字，以在游戏列表中搜索已安装的游戏，并且点击靠右的部分可以变更以游戏名称为维度的正逆排序；【版本】亦可以点击以从游戏版本号为维度对游戏进行排序；除此之外的项目不可排序。

::: warning 已知问题

已知当前按游戏名称排序的实际点击位置处于输入框右侧，但是不在表示排序方向的图标上。目前暂时可以先选中搜索框以确认其范围，然后点击靠右的空白区域尝试切换排序。为此给各位用户带来的不便，我们十分抱歉。

:::

### 列表本身

在游戏列表中存在以下两个状态的条目：

* 游戏。在每一行（项）开头有可供固定游戏到主界面的图钉按钮，末尾有【游戏设置 】按钮和【启动游戏】按钮。

::: details 详细信息

* 双击此行游戏条目可以快捷打开游戏设置；

* 点击游戏设置按钮可以打开游戏设置；

* 右键点击将弹出右键菜单：

  * 生成导出配置 如果已经存在`FOLDERRULES`，将询问是否需要覆盖以重新生成

  * 编辑导出配置 当存在导出配置文件`FOLDERRULES`时用于打开文件并编辑

  * 检查游戏文件
    将会启动游戏资源检查，如果有文件缺失将会进行资源补全。

  * 删除（存在二次确认）
    删除这个游戏。

  * 二级菜单：打开
    使用系统默认文件管理器打开与此游戏相关的常用文件夹。

    * 版本根目录
    * 日志
    * 存档
    * 游戏截图
    * 资源包
    * 模组
    * 光影包

  * 二级菜单：导出为&#x20;
    将该游戏通过多种方式导出为整合包。

    * 发布为完整包
    * CurseForge整合包
    * Modrinth整合包

* 点击启动游戏将按当前设置启动游戏：
  如果启用了【固定账户】（[全局游戏设置 # 在账户页面固定账户 | 日冕知识库](/zhCN/lxguide/settings/item/global.html#在账户页面固定账户-开关-默认-关闭)），则将会使用选中固定的账户启动游戏；
  否则，将会在点击后询问使用哪个账户。

:::

* 无效目录。在每一行（项）开头有一个无视主题颜色的红色警告标志 ，并且末尾有一个红色的badge，描述了无法识别的原因。

::: details 详细信息

这种游戏条目无法被作为游戏启动。右键点击后有对应的右键菜单。

这种条目之所以出现，是因为可能有一个游戏的文件出现了损坏，或是有一个新游戏尚未完成安装，抑或是用户自己在versions里创建了一个并非游戏的文件夹。如果是一个正在安装的游戏的话，在游戏安装完成后刷新游戏列表，该条目将会恢复正常。

* 刷新点击后将刷新整个游戏列表。
* 删除（存在二次确认）
  删除这个目录。
* 二级菜单：打开
  使用系统默认文件管理器打开与此游戏相关的常用文件夹。
  * 版本根目录
  * 日志
  * 存档
  * 游戏截图
  * 资源包
  * 模组
  * 光影包

:::

## 游戏设置

目前（2025年2月10日）LauncherX允许游戏存在部分独立的设置。独立设置将覆盖全局游戏设置。

* 游戏名称：在游戏列表中展示的友好名称
* 游戏路径  不要擅自轻易修改！
* 图标：在官方启动器可以展示的游戏图标
* 内存大小：此游戏启动时分配的内存大小
* Java路径：指定游戏使用的Java环境（参考阅读：[在完整包中包含默认选中的Java | 日冕知识库](/zhCN/lxguide/features/tricks/default-jre-for-pack.html)）
* 额外参数：指定此游戏启动时的附加参数
* 游戏窗口大小：游戏的窗口 `宽` × `高`
* 全屏：是否启动即开启全屏模式

::: info

这里不存在游戏窗口标题设置。如果想要让标题显示游戏名称，参考：[全局游戏设置#游戏窗口设置-组合设置 | 日冕知识库](/zhCN/lxguide/settings/item/global.html#游戏窗口设置-组合设置) 为全局启用标题栏占位符。

这里也不存在单独的启动后加入服务器管理。目前我们规划了一种更独特的管理方法，敬请期待。

:::

此外，游戏设置中提供模组管理，可以在其中检视模组、禁用模组、删除模组；可以预览此游戏的截图；可以预览资源包和光影信息。

::: tip 你知道吗？

在游戏设置的大界面里，如果模组、截图、资源、光影的文件夹存在，鼠标悬浮在标签按钮上时会出现一个打开文件夹的图标 ，点击这个图标即可打开对应的文件夹。

:::

## 重要提示

1. LauncherX可以发现手动粘贴到游戏列表目录`versions`文件夹中的游戏版本文件夹。
2. 对于一些在安装过程中涉及释放基础库的游戏，可能并不适用#1中的游戏安装方法。比如：Forge
3. 对于非默认的游戏主目录（LauncherX工作目录中的`.minecraft`文件夹），LauncherX无法实时监控内容变更。如果发现实际情况和游戏列表内显示的不一致，请手动点击刷新。

---

---
url: /zhCN/lxguide/features/log-window.md
---
# 游戏实时日志窗口

---

---
url: /zhCN/lxguide/features/manage-server.md
---
# 游戏服务器管理

:::warning

根据老腊肉的说法，这个功能是面向服务器整合包制作者的，因而暂未打算允许为每个单独的游戏作适配。如果对单独游戏单独的服务器管理的功能需求较高，则会考虑制作此功能。请通过[这里的方式](/zhCN/lxguide/report-issue) 让我们知道!

更新日期: 2024年3月4日

:::

## 介绍

当您在设置中选择了一个已经添加的服务器，那么每次启动游戏都会在游戏启动后自动尝试加入该服务器。

## 步骤

若要设置和管理服务器，请按照下述顺序寻找入口按钮:

* 点击导航栏的“设置”
* 在“全局游戏设置”中向下滚动以寻找: “启动后加入服务器 + \[管理服务器(按钮)]”
* 点击按钮“管理服务器”
* 点击右上角的“添加”
* 在弹出窗口中输入目标服务器的信息。如果您找不到弹出窗口的“添加”按钮，请耐心等待LauncherX获取协议版本信息。在确认您的协议版本选择无误后(一般也不需要修改)，点击添加。
* 您可以添加多个服务器。在完成添加后，点选一个服务器，然后点击左上角的“返回”，即可保存已选择的服务器。继而，您可以在“设置”中该设置的入口处确认是否已经选中您想要选择的服务器.

:::tip

一般而言，此刻启动游戏将可以直接加入到目标服务器。如果没有，请尝试换一个对应的协议版本并重新添加，然后选中.

:::

---

---
url: /zhCN/projbobcat/additionalParsers/gameProfileParser.md
---
# 游戏档案解析器

游戏档案解析器负责将搜索到的本地游戏写入到官方启动器的配置文件中。

## 初始化解析器

初始化解析器的方式非常简单：

```c#
var launcherProfileParser
    = new DefaultLauncherProfileParser(rootPath，clientToken)
```

其中，**rootPath** 为核心所在的根目录（即 .minecraft 文件夹所在的目录）。
**clientToken** 为一个随机生成的 GUID。

---

---
url: /zhCN/projbobcat/additionalParsers/accountProfileParser.md
---
# 游戏账号解析器

游戏档案解析器负责将用户账户写入到官方启动器的配置文件中。

## 初始化解析器

初始化解析器的方式非常简单：

```c#
var launcherAccountParser
    = new DefaultLauncherAccountParser(rootPath，clientToken)
```

其中，**rootPath** 为核心所在的根目录（即 .minecraft 文件夹所在的目录）。
**clientToken** 为一个随机生成的 GUID。

---

---
url: /ruRU/projbobcat/resourceCompleter/resourceInfoResolver/versionInfoResolver.md
---
# 版本信息解析器

\[\[toc]]

版本信息解析器提供了对游戏资产文件的解析和验证功能, 这些文件存放在
`.minecraft/versions/{GAME_VERSION}/{GAME_VERSION}.jar` 目录下, 这些文件是启动 MineCraft 所必需的核心文件.

## 初始化解析器

你可以通过下面的代码来初始化初始化解析器：

```c#

var resolver = new VersionInfoResolver
{
    BasePath = "[GAME_ROOT_PATH]",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES]
};

```

在上述代码块中, 请将这些参数按照您的实际情况替换：

|           项目            |               说明                |
|:-----------------------:|:-------------------------------:|
|    \[GAME\_ROOT\_PATH]     |   游戏根目录, 通常为 .minecraft 文件夹的路径   |
| \[SEARCHED\_VERSION\_INFO] | 要检查的版本的 VersionInfo （通过游戏定位器获得） |
|   \[CHECK\_LOCAL\_FILES]   |    检查本地文件（如果为 false, 则跳过所有检查）    |

---

---
url: /zhCN/projbobcat/resourceCompleter/resourceInfoResolver/versionInfoResolver.md
---
# 版本信息解析器

\[\[toc]]

版本信息解析器提供了对游戏资产文件的解析和验证功能，这些文件存放在
`.minecraft/versions/{GAME_VERSION}/{GAME_VERSION}.jar` 目录下，这些文件是启动 MineCraft 所必需的核心文件。

## 初始化解析器

你可以通过下面的代码来初始化初始化解析器：

```c#
var resolver = new VersionInfoResolver
{
    BasePath = "[GAME_ROOT_PATH]",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES]
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|           项目            |               说明                |
|:-----------------------:|:-------------------------------:|
|    \[GAME\_ROOT\_PATH]     |   游戏根目录，通常为 .minecraft 文件夹的路径   |
| \[SEARCHED\_VERSION\_INFO] | 要检查的版本的 VersionInfo （通过游戏定位器获得） |
|   \[CHECK\_LOCAL\_FILES]   |    检查本地文件（如果为 false，则跳过所有检查）    |

---

---
url: /zhTW/projbobcat/resourceCompleter/resourceInfoResolver/versionInfoResolver.md
---
# 版本資訊解析器

\[\[toc]]

版本資訊解析器提供了對遊戲資產檔案的解析和驗證功能, 這些檔案存放在
`.minecraft/versions/{GAME_VERSION}/{GAME_VERSION}.jar` 目錄下, 這些檔案是啟動 MineCraft 所必需的核心檔案.

## 初始化解析器

你可以透過下面的程式碼來初始化初始化解析器：

```c#

var resolver = new VersionInfoResolver
{
    BasePath = "[GAME_ROOT_PATH]",
    VersionInfo = [SEARCHED_VERSION_INFO],
    CheckLocalFiles = [CHECK_LOCAL_FILES]
};

```

在上述程式碼塊中, 請將這些引數按照您的實際情況替換：

|           專案            |               說明                |
|:-----------------------:|:-------------------------------:|
|    \[GAME\_ROOT\_PATH]     |   遊戲根目錄, 通常為 .minecraft 資料夾的路徑   |
| \[SEARCHED\_VERSION\_INFO] | 要檢查的版本的 VersionInfo （透過遊戲定位器獲得） |
|   \[CHECK\_LOCAL\_FILES]   |    檢查本地檔案（如果為 false, 則跳過所有檢查）    |

---

---
url: /zhCN/lxguide/settings/special/independent-config.md
---
# 版本隔离与独立设置

:::warning

LauncherX是**强制版本隔离**的，这意味着LauncherX**不能直接地完整支持“非版本隔离”的游戏目录**.

:::

您下载、导入或安装的每一个独立的游戏版本都可以被专门进行设置。比如指定其使用特定的JRE，或者指定特别的启动参数.

在「游戏列表」中，您可以点击列表中任意一个代表游戏的项目，LauncherX将在主窗口的右侧抽出对应的具体设置界面。您可以像在[全局设置](/zhCN/lxguide/settings/item/global)中一样设置**仅对这个游戏生效的**设置项。记得点右上角的保存。独立的设置将针对这个游戏覆盖默认的全局设置.

---

---
url: /zhCN/CMFS/servers/project-lappland/gameplay.md
---
# 玩法

ProjLapp的剧情主要侧重于营造氛围和环境，主要玩法是特定的模组生存。

## 生存

全天候的玩法。围绕着故事进行经营、建立自己的聚落定居点、感受和邻居之间的“地缘事务”——就像19~20世纪的艾美莉卡西部一样，这里距离“总部”很远，这里是无主之地。

## 故事

你是怎么来到这里的？你又是为了什么来到这里？想必你有自己的答案——“总部”选定你参与到这样的远星拓荒之中，对你来说究竟是扬名立万的机会，还是将你推入了无底的深渊？

## 活动

限时游玩的故事或经营玩法。

---

---
url: /zhCN/lxguide/features/tricks/disable-animation.md
---
# 禁用动画

虽然LauncherX提供性能更好的动画接口，但是此接口存在暂未解决的问题，故作为【实验性动画】提供。这个动画接口的问题包括但不限于：

* 动画可能出现抽搐
* 同一类的动画在LauncherX启动后需要触发一次之后才能正常渲染，否则将不显示动画触发后的内容

如果您确实能舍弃动画，我们提供一种手动禁用动画的方式。很简单。

1. 关闭LauncherX（可选），前往LauncherX目录  （这个目录是和默认游戏目录和LauncherX.json同级的）
2. 在其中新建文件，命名为`REDUCE_ANI`，不要给它留下后缀名，这个文件应该是个完全的空文件。
3. 重新打开LauncherX，即可禁用动画。

---

---
url: /zhCN/projbobcat/authenticators/offline.md
---
# 离线验证模型

\[\[toc]]

该验证模型实现了最基础的验证功能。通常用于本地调试和验证。

:::warning

在生产环节使用该验证模型在部分国家和地区可能会**违反版权法或是最终用户协议**，详见 [Mojang 最终用户协议（英文）](https://www.minecraft.net/en-us/eula)

:::

## 初始化验证器

您可以通过下面的代码初始化离线验证器：

```c#
var offlineAuthenticator = new OfflineAuthenticator
{
    LauncherAccountParser = launcherAccountParser,
    Username = "[DISPLAY_NAME]"
};
```

在上述代码块中，请将这些参数按照您的实际情况替换：

|          项目           |             说明              |
|:---------------------:|:---------------------------:|
| launcherAccountParser |   对于启动器账户解析器的初始化，详见[此处]()   |
|    \[DISPLAY\_NAME]     | 游戏中的显示名称，通常是由英文字符、符号以及数字组成  |

:::tip

对于 **launcherAccountParser**（游戏档案解析器）的初始化，请参考[游戏档案解析器](/zhCN/projbobcat/additionalParsers/gameProfileParser)页面

:::

## 获取验证结果

在您完成验证模型的初始化后，您只需要调用离线验证器的验证方法来完成账户验证。

在异步上下文中，使用 **AuthTaskAsync** 来完成验证：

```c#
var authResult = await offlineAuthenticator.AuthTaskAsync(false);
```

在同步上下文中，使用 **Auth** 来完成验证：

```c#
var authResult = offlineAuthenticator.Auth();
```

## 解读验证结果

在验证方法完成之后，验证模型会返回验证结果，这是一个类型为 [AuthResultBase](https://github.com/Corona-Studio/ProjBobcat/blob/master/ProjBobcat/ProjBobcat/Class/Model/Auth/AuthResultBase.cs) 的对象。
所有的验证结果都包含一个枚举值 **AuthStatus**，该枚举值直接指示了验证结果的成功或是失败。
在下面您可以看到对验证结果的解读：

### 失败的验证结果

通过判断 **Error** 是否为空，您可以很轻松的判断验证模型返回的验证结果是否是有效的，
**Error** 对象会包含以下字段来告诉您一些细节：

|              字段               |        说明        |
|:-----------------------------:|:----------------:|
|    authResult.Error.Cause     |    导致问题的具体原因     |
|    authResult.Error.Error     |       错误名称       |
| authResult.Error.ErrorMessage | 错误的详细信息，可能包含解决方案 |

### 成功的验证结果

如果验证结果中的 **Error** 字段为空，则表示本次验证是有效的，成功的验证结果会包含下面的信息：

|             字段              |                   说明                    |
|:---------------------------:|:---------------------------------------:|
|        authResult.Id        | 该用户名的唯一标识符，ProjBobcat 使用特定的生成方式来生成这个标识符 |
|   authResult.AccessToken    |       用户账户的授权凭据，这对于离线验证模型是没有任何意义的       |
|    authResult.User.UUID     |    该用户的 UUID，与 **authResult.Id** 类似     |
| authResult.User.Properties  |    用户的属性数组，对于离线验证模型来说，该数组只包含唯一一个有效值     |

---

---
url: /zhCN/lxguide/settings/special/manage-accounts.md
---
# 管理账户

LauncherX提供一个完善的账户管理。

\[\[toc]]

::: tip 主页的管理账户入口

在主页，至少有一个一步前往“账户管理”界面的入口，就是在底部的导航栏上，一般显示着“本地账户管理”或“账户管理”，但是如果您登陆了日冕账户，此处将会显示您的**日冕账户用户名**。

:::

## 游戏账户

您的游戏账户是启动游戏后在游戏中代表您的身份标识。可以认为这就是玩家名，或者称之为ID。

您在初次设置LauncherX的时候便会有一个提示您添加账户的地方。实际上，在完成初次设置后，点击【账户管理】按钮，仍然可以进行添加、预览皮肤、删除、刷新、固定（如果开启了账户固定）账户的操作。以下是以初次设置游戏账户的示例。

### 注意

在本段中,我们建议您优先使用来自微软官方的Microsoft帐户登录您的Minecraft。虽然官方并未明确其对离线模式等无正版验证的游戏的反对态度，但我们仍然建议您通过购买Minecraft来支持和维护知识产权.

本文将指导您使用LauncherX在初次使用和后续使用中添加 **仅本地可用的** 游戏账户，包括以下类型:

* Microsoft 账户
* 离线模式账户
* AuthLib 帐户（原 Mojang 账户登录）

*由于官方已经停止对 Mojang 帐户的支持并开始迁移 Mojang 帐户到 Microsoft 帐户，故 LauncherX 将不再支持 Mojang 帐户登录。详情: [Mojang Java 版 Minecraft 帐户移动 | Minecraft](https://www.minecraft.net/zh-hans/mojang-account-move)*

### 初次设置

初次使用 LauncherX 时，您会看到 LauncherX 在向您打招呼之后要求您进行一些使用 LauncherX 必要的初始设置。在到达“添加账户”这一步时，您可以选择以下一个操作进行。点击“添加”按钮来开始.

#### =Microsoft帐户登录

点击弹出窗口中的“Microsoft帐户”按钮，LauncherX将会弹出一个包含验证链接、一次性验证代码和些许按钮的置顶窗口 ( 验证信息窗口 ).

![image-20230222204440416](/assets/image-20230222204440416.CbZu2DPU.png)

整个流程大约10秒即可完成 (受网络性能和您的浏览器是否保存了您的微软账户登录信息影响，这可能会有些许延长)。
考虑到微软的隐私策略，我们建议您在 3 分钟内完成这个流程，以免一次性验证代码失效。若一次性代码失效，您需要关闭当前的验证信息窗口并重复添加微软账户的操作.

* 点击“复制代码”，即可把您本次登录所需要使用的一次性代码复制到剪贴板。相关阅读：[\[Microsoft\]Windows10+内置剪贴板提示](https://support.microsoft.com/zh-cn/windows/%E5%89%AA%E8%B4%B4%E6%9D%BFwindows-c436501e-985d-1c8d-97ea-fe46ddf338c6)
* 点击“打开验证页面”，将会通过您的默认浏览器打开微软账户的验证页面.
* 将您复制的一次性代码按网页提示粘贴到指定的位置。如果微软要求您登录，请先在网页中登录您的微软账户.
* 弹出此窗口后，您需要“同意”以继续添加账户的操作.

![image-20230222204659302](/assets/image-20230222204659302.3ad4zMoe.png)

在 LauncherX 验证账户过程中，您可以继续进行下一步设置。

如果您认为验证过程太慢或失败，请考虑优化您当前的网络环境 (比如，使用针对 Xbox 登录的加速器或尝试离您的无线网络源近一些，如果您在使用的无线网络的话。)

###### 意外情况: Edge浏览器弹出需要安全验证设备:

![image-20230222204732083](/assets/image-20230222204732083.BMhcgG6A.png)

对于这种情况，您需要:

* 点击“取消”
* 在网页中点击“其他登录方法”,如图：![image-20230222204925338](/assets/image-20230222204925338.kW0y5m6W.png)
* 点击“使用我的密码”，或者选择任意您方便使用的登录方法 ![image-20230222205034775](/assets/image-20230222205034775.BycQG9xY.png)

#### =离线模式

这可以说是最简单的账户添加方法。您可以用 LauncherX 为您的本地游戏开启自定义皮肤，这个功能只会对您的本地客户端生效。 参见: 游戏账户管理/皮肤预览

* 点击“离线账户”
* 输入任意您想要的玩家名。注意，有些版本 ( 尤其是较老的版本 ) 不支持中文 ID。
* 离线模式只能供您游玩本地游戏和支持离线登入的服务器。

#### =AuthLib（外置登录）

借助 [AuthLib-Injector](https://github.com/yushijinhun/authlib-injector)，使用特殊的登录验证服务。在选择这一项登录之前，您应该确认您有来自某一方的 AuthLib 外置登录服务。

为此，您需要准备:

* 外置登录验证电子邮箱

* 对应的密码

* 对应验证服务的 AuthLib 服务器地址 (这对于外置登录是必须的，因为 LauncherX 不知道您需要向谁的 Yggdrasil API 进行验证。通常，这个地址类似 “https://<服务提供商的域名>/api/yggdrasil”)

  ::: info 快捷填入内容

  服务提供商或许会需要您将一个按钮拖入到启动器，LauncherX支持直接拖入到第三个输入框。

  :::

点击“外置登录（Mojang）”以开始。

* 弹出如图所示的窗口:   ![image-20230227091559255](/assets/image-20230227091559255.BP6hakQE.png)
* 对应输入先前您应该准备好的信息（AuthLib服务器栏支持拖入链接）
* 保存账户。这些信息将加密后作为凭证，在您登录支持对应的AuthLib服务的服务器后用于验证。

### 后续添加

在完成初次设置后，您可以进入 **设置-账户**，添加更多的游戏账户。

点击“添加账户”之后，一切操作与您在初次设置 LauncherX 时候完全一致。我们建议您在添加了微软账户后对应的添加一个相同ID的离线账户，以避免部分游戏在联网或未联网情况下无法启动的问题。

## 日冕账户

日冕账户是我们（日冕工作室）在为您提供服务时对您进行识别的凭证。LauncherX的仪表板、联机、参与测试等功能均需要登陆日冕账户。

对账户绑定设备等具体管理，请访问：[登录到服务 (corona.studio)](https://corona.studio/auth/login) 登陆后进行管理。

---

---
url: /zhCN/guide/general.md
---
# 综合操作指导

这里放了一些与我们工作室强相关的指导性文本，旨在介绍部分工作的一般操作流程等内容。

---

---
url: /zhCN/lxguide/settings/item/network.md
---
# 网络设置

\[\[toc]]

## 基础网络设置

**资源下载服务器**: `选择框` | 默认: Bangbang93的下载服务器

:::info

可选项: Bangbang93的下载服务器(BMCLAPI)，Mojang官方服务器。如果您身处中国大陆地区，使用Bangbang93的下载服务器或许更好。仅在Bangbang93的下载服务器不可用或过于缓慢时使用Mojang官方服务器。(Bangbang93的下载服务器可能会因为线路过于拥挤而出现短暂的不可用状况。虽然貌似与我们关系不大，但是: 这个下载源是公益且免费的，如果您有能力且希望这个公益下载源可以变得更好，您可以通过爱发电平台向发起人进行赞助。[赞助BMCLAPI](https://bmclapidoc.bangbang93.com/#))

:::

:::warning

从2024年2月20日起的LauncherX移除了对mcbbs下载源的支持.

:::

**下载线程数量**: `拖动条(整数)` | 默认: 160? | 单位: 个

:::info

控制下载或补全游戏资源时同时进行下载的线程数量。一般而言，宽带带宽越大，此时线程数量越多，整体下载速度越快、效率越高。 请注意，倘若选择了Mojang下载服务器，受制于API限制，不建议您选择大于5的线程数量，以避免大规模的下载失败。与此同时，实际下载速度受上游网络影响: 假如服务器方面出现拥堵，则整体下载速度同样会被拖慢.

因此，请酌情选择线程数量.

:::

**自动决定下载方式**: `开关` | 默认: 开

:::info

启用此项目来让LauncherX决定何时启用大文件分片下载.

:::

**使用大文件分片下载**: `开关` | 默认: 开 | 条件性开关

:::info

当上一个开关为启用状态时，此开关启用，并不允许切换其状态.

大文件分片下载可以在下载较大的游戏文件时将文件分成几部分进行多线程下载，从而最大化地利用网络资源，提升下载效率.

:::

**分片数量**: `选择框` | 默认: 16

:::info

可用的数量有: 1，2，4，8，16，32，64，128

使用分片下载时，对单一文件分片的数量。可以理解为这个文件在下载时会被分成多少份，所有分片下载完成后会合并成预期的目标文件。

此选项需要根据电脑性能酌情选择，因为无论是开启多线程下载还是下载完成后在后台合并都需要消耗本地硬件资源。(不过对于现代计算机来说，这些消耗貌似不足一提。)

:::

## 网络连接测试

:::tip

通过网络连接测试，您可以更好地了解您当前的网络状况，包括延迟，服务器状态等一些基础信息。同时也能帮您排除一些简单故障。

:::

**启动**: `按钮` 点击以启动网络测试.

关于网络测试的结果，参见: [专题: 检测网络](/zhCN/lxguide/settings/special/check-network)

---

---
url: /zhCN/lxguide/features/icon.md
---
# 自定义游戏图标

::: warning 差异

截止至2025年3月15日，**游戏设置**中的【图标】设置项与此功能无关。

:::

使用LauncherX的自定义图标特性可以让特别的游戏在游戏列表中更有辨识度。

![](/img/lxguide/features/game-icon.webp)

如图所示，由于Cobblemon官方导出的整合包中存在一个`icon.png`于游戏的根目录之下，其被LauncherX作为游戏图标展示在了游戏列表中。

## 操作指南

如果要为游戏应用一个图标，需先自行准备好图片文件。我们建议使用**长宽比为1:1**的，并且**带有透明背景的`PNG`格式图片**。

1. 准备好图片。它可以是你的整合包Logo。
2. 如有需要，使用`Photopea`或AI抠图功能，仅保留图标主体。
3. 将图片保存为`icon.png`并放置在`~/<游戏目录>/versions/<你的游戏版本>/`下。
4. 打开LauncherX的游戏列表。刷新后将可看到LauncherX取用了此图片为游戏图标。
5. 如果没有生效，请确保LauncherX是最新版本。

LauncherX仅接受特定命名以自动选为图标。如果最终图标不是正方形（长宽比1:1），那么图标会仅展示**始于中心点的最大的正方形部分**。

::: info 与整合包导出的兼容性

LauncherX在导出整合包时，如果存在`icon.png`，将会将其包含在整合包中。

:::

---

---
url: /zhCN/lxguide/features/tricks/env-vars.md
---
# 自定义环境变量

::: info 这个功能最初是面向Linux用户的
LauncherX暂不支持包装（前置）命令。使用此功能达成一样的效果。
:::

\[\[toc]]

## 文件格式

这是一个需要手动创建的文件。只有在特定目录下创建的名为`GAME_ENV`文件会被识别，其内容将会逐行被识别为环境变量。

这个文件内部格式如下：

```text

VARIABLE_NAME=value
OTHERVALUE=value

```

总而述之，其必须满足以下条件：

* 纯文本
* 每一行都是单独一个环境变量的定义
* 键值中间用等号连接

## 使用说明

### 对全局游戏启用

::: info 全局设置
在没有设置环境变量的游戏中将会使用此处保存的环境变量来作为默认值

:::

1. 前往LauncherX的运行根目录（可以通过游戏列表中的【更多-打开启动器根目录】）
2. 打开LauncherX目录，在其中新建`GAME_ENV`
3. 根据上文的格式写入环境变量
4. 保存，然后启动游戏观察是否有效。

### 对单个游戏启用

::: info 覆盖全局
对单个游戏启用的环境变量设置将会对对应游戏启用可以覆盖上文提到的全局设置的环境变量设置。

:::

1. 前往需要更改的游戏的目录（可以通过右键点击列表游戏【打开-打开版本根目录】）
2. 在游戏目录其中新建`GAME_ENV`
3. 根据上文的格式写入环境变量
4. 保存，然后启动游戏观察是否有效。

---

---
url: /zhCN/mc-starter/get-minecraft.md
---
# 获取适合你的Minecraft

::: info 这是写给完全第一次玩Minecraft的新手的玩家的文章

如果你真心想要了解这个游戏并在这个游戏里取得乐趣，那么请怀揣着一颗主动学习、举一反三的求知之心继续阅读吧!  本文将指引你开启Minecraft之路.

此外，官方也为你的游戏之旅准备了翔实的教程：[Minecraft Game Guides | Minecraft Help](https://help.minecraft.net/hc/en-us/sections/27983418545293)，还有Minecraft Wiki：[中文 Minecraft Wiki](https://zh.minecraft.wiki/) 可供查阅。

:::

## 前言

由于Minecraft分为多个版本，且都不太一样，本文将指引你找到适合你玩的版本。本文不涉及游戏玩法、机制之类的内容，只是尽可能指引想玩的新手购买、安装、下载，并最终能够玩上Minecraft.

## 选择版本

那么，选哪个Minecraft可以满足自己的游玩需求呢？

其实Minecraft有许多不同版本和衍生游戏可供选择。在当下(2024年5月22日)，一般而言，我们讨论的范围仅限于定义在「沙盒游戏」这个领域之内的Minecraft版本，现在仍在维护的仅有两个: **Java版(Java Edition)** 和 **基岩版(Bedrock Edition)**。除此之外还有一些同IP衍生游戏: Minecraft Legends、Minecraft Story Mode(故事模式) 、Minecraft Earth和 Minecraft Dungeons.

接下来将带你了解不同版本之间的区别，以及如何选择。如果你已经拥有一个Minecraft的许可 (即 你已经购买了Minecraft)，请使用本页面 **右侧的** 目录跳转到对应的章节.

\[\[toc]]

::: warning 这里不提教育版…

一般来说，基岩版内包含了教育版的部分内容.

::: details 正版的教育版授权需要由满足以下条件的实体才能购买:

* 拥有Microsoft 365（原Office 365）教育版账户
* 教育者要取得购买资格，必须是学术机构的全职或兼职教员/职员，并且拥有一个由学校提供的学校电子邮箱，以接受附加电子邮件的用户。
* 区域或学校要取得购买资格，必须是一个素质教育用户，这个用户的定义是专门教育其注册学生为目的的机构组织。
* 公共图书馆要取得购买资格，必须为所有给定的社区、区域或地区免费提供普通图书馆服务。
* 公共博物馆要取得购买资格，必须是一个本质上以永久基础教育或以审美为目的，并利用专业人员定期向公众展示一个有形物体的机构或机构组织。
* 家庭教育项目要取得购买资格，必须提供向学生提供中小学教育或学生出具其属于由国家认可的家庭教育组织或被一个当地学区明确承认此为一种可接受的教育方式或者州立承认/任何的教育组织的书面证明。

:::

### 1) 依据游玩设备

Minecraft可以运行在在很多不同的平台上。

#### a) 电脑

::: info 可用的游戏

Minecraft Java Edition (Java版)，Minecraft Bedrock Edition (基岩版)，Minecraft Legends，Minecraft Dungeons，Minecraft Story Mode

:::

在电脑上可以游玩的Minecraft有很多种。如果“只是想玩玩”，那么可以自由从Java版和基岩版之中选择。我们强烈建议从微软官方购买游戏以游玩。

#### b) 手机

::: info 可用的游戏

Minecraft Java Edition (Java版)，Minecraft Bedrock Edition (基岩版，含教育内容)，Minecraft Earth

:::

一般来说，在Google Play Store或App Store安装的Minecraft都是基岩版的范畴。同样的，由于基岩版和Java版使用不同的技术开发，其虽然尽可能地保持游戏规则、玩法和行为一致，但也存在一些不同之处。如果你只是想搭搭方块，进行自己的冒险，那么两个版本之间并无太大差别。——具体的差别体现在机制上: 红石、战斗，以及被戏称为「特性」的、可能在未来会被视为「非预期行为」的**游戏BUG**。就战斗机制举个例子，截止至目前，在基岩版中没有攻击冷却\* 并且举盾需要在副手持盾的情况下蹲下; 而Java版存在攻击冷却，举盾需要在副手持盾的情况下按住鼠标右键.

但是，Java版在移动设备上的安装相比于安装基岩版要麻烦不少。虽然我们 (Corona Studio) 有制作移动端Java游戏启动器的想法，但是目前还是先看看其他优秀的现有产品吧:

* pojavLauncher: 支持iOS设备、Android设备.
* FCL: 支持Android设备。

有关于上述启动器的使用方法，你可以在Bilibili、MineBBS等地搜索到很多教程，以及软件相关的下载地址。以下是一些推荐的教程:

#### c) 游戏机 (XBox之类的设备)

::: info 可用的游戏

Minecraft Legends，Minecraft Bedrock Edition (基岩版)，Minecraft Dungeons

:::

### 2) 依据想要玩的内容

一般来说，慕名前来游玩Minecraft的玩家一般都会选择定义为 **「沙盒游戏」** 的Minecraft，也就是 **Java版(Java Edition)** 或 **基岩版(Bedrock Edition)** 。 如何在这两种版本中做出选择，已经在上一段中介绍过了。

但是如果你想尝试不太一样的…

#### a) 策略动作类Minecraft: Legends

* 这个游戏具备多人玩法.

***

#### b) 肉鸽类Minecraft: Dungeons

* 这个游戏具备多人玩法.

***

#### c) AR（增强现实）Minecraft：Earth

* 这个游戏可以让你在 “自己家里建造”：通过手机摄像头和增强现实计算来在当前摄像头里的 “现实环境” 中 “放置方块”。

***

#### d) 剧情冒险Minecraft: 故事模式

* 游戏的玩法是玩家可以收集物品，解决谜题，并通过对话树与非玩家角色进行对话，以了解故事并确定下一步要做什么.

* 玩家做出的决定会影响当前章节和后续章节中的事件。或许可以当作一种视觉小说来看.

* 这个游戏具备一种基于网页投票的多人玩法 (第二部)，很诡异，并且貌似现在不可用.

## 购买

购买Minecraft可以在很多平台上完成，但是部分不同的版本仅在不同的平台可供购买。一般而言，目前Mojang作为微软的一员，所有Minecraft相关游戏均可在微软商店购买(除了部分已下架的游戏)。截止目前(2024年5月22日)，微软商店支持使用支付宝进行免密支付.

截止至目前，不同版本对应可购买的平台如下:

*括号中代表在不同平台的价格。比如，平台中的“minecraft.net”排在第一位，则价格“169(1，… )” 意味着「在minecraft.net上，游戏价格为169」*

| 版本                        | 平台                                         | 一般售价 (人民币元\*)  |
| --------------------------- | -------------------------------------------- | --------------------- |
| Minecraft Java版            | minecraft.net (除中国大陆区域以外)，微软商店 | 89 (与基岩版捆绑销售) |
| Minecraft 基岩版 (Windows)  | minecraft.net (除中国大陆区域以外)，微软商店 | 89 (与基岩版捆绑销售) |
| Minecraft 基岩版 (iOS)      | App Store (除中国大陆区域以外)               | 6.99美元\*             |
| Minecraft 基岩版 (Android)  | Google Play                                  | 6.99美元\*             |
| Minecraft 基岩版 (其他平台) | 未知                                         | 未知                  |
| Dungeons                    | minecraft.net，微软商店，steam               | 69 (1，2)  / 72 (3)   |
| Legends                     | steam                                        | 59.5                  |
| 故事模式                    | 已下架                                       | -                     |
| Earth                       | 已下架                                       | -                     |

### Java版

###### 基本步骤

准备环境

* 确认你的游玩设备。本文只介绍在电脑上使用LauncherX游玩的步骤。

* 前往[这里](https://corona.studio/lx)下载最新版LauncherX。下载LauncherX的教程在这里：[开始 | 日冕知识库](/zhCN/lxguide/startup/)

* 完成启动器配置后，前往【下载-游戏本体】，选择一个具体的版本号进行下载。使用LauncherX下载安装游戏的最完整教程在这里：[安装游戏 | 日冕知识库](/zhCN/lxguide/features/installing-games.html)

* 完成下载后，有一部分额外的资源需要在启动前确保完整，如果不完整，LauncherX将会自动尝试进行下载。点击【启动游戏】将会自动检查资源完整性。
  ::: tip 下载问题
  如果出现下载失败，请尝试让LauncherX自动选择下载源（一般情况下这是默认被选择的），并且尝试在【设置-全局游戏设置-启动器行为-重试次数】中调大重试次数。

  若下载失败一直出现，请检查自己的网络连接。[检测网络 | 日冕知识库](/zhCN/lxguide/settings/special/check-network.html)
  :::

* 点击启动游戏后，正常来说游戏将会启动。然后就可以开始游戏了！
  ::: info 游戏启动失败了！

  如果游戏启动失败，请参考：[游戏崩溃/异常分析专题 | 日冕知识库](/zhCN/mc-starter/advanced/analyze-exception/) 和后续内容文章自行进行排查，或将崩溃检测器的支持包导出后交由有能力分析错误日志的人进行诊断。
  :::

### 基岩版

###### 基本步骤

### Legends / 故事模式 / Dungeons/…

::: info 这不是传统的Minecraft！

参考前文以确认这是不是你要玩的Minecraft。

:::

正如之前所说的，这些游戏有着与一般Minecraft完全不同的玩法。

###### 如何购买和游玩?

* 依照上文\*\*\[关于购买]\*\*的表格，在对应的游戏平台搜索
* 购买，根据平台的提示下载安装
* 完成! 现在打开游戏吧！

::: tip Minecraft官方启动器和微软商店可以满足全部需求

要游玩这些游戏，可以直接在微软商店购买，然后通过微软商店/XBox/Minecraft启动器来游玩。也可以将游戏固定到开始菜单.

:::

###### 设备要求

以下是这三款游戏的最低设备要求：

* **Minecraft Dungeons**
  * 操作系统：Windows 10 (需要安装2019年11月以后的更新)
  * 处理器：intel Core i5 2.8GHz或等效处理器
  * 内存：8 GB
  * 显卡：NVIDIA GeForce GTX 660或等效GPU，要求至少2GB VRAM
  * 存储空间：至少6 GB可用空间
  * DirectX：DirectX 11
* **Minecraft Story Mode**
  * 操作系统：Windows XP SP 3
  * 处理器：Core 2 Duo 2GHz或等效处理器 (2010年以后电脑基本都可以)
  * 内存：3 GB
  * 显卡：任意带有512 MB RAM的显卡
  * 存储空间：至少3 GB可用空间
  * DirectX：9.0
* **Minecraft Legends**
  * 操作系统：Windows 10 (2020年5月更新或更高版本)
  * 处理器：Core i5 2.8GHz或等效处理器
  * 内存：8 GB
  * 图形卡：NVIDIA GeForce GTX 780或等效的GPU
  * 存储空间：至少24 GB可用空间
  * DirectX：12
* **其他更多**
  * 信息缺失，请根据应用商店提供的信息确认是否满足硬件要求。

### 关于网易代理的《中国版我的世界》

如果你只是想在完全受支持的环境下进行多人游戏并且可以负担内购、不打算操心太多扩展游戏玩法后调试相关的问题并且经常有游戏社交的需求，建议选择由网易代理的仅面向中国大陆用户的《我的世界》。网易公司代理了微软公司和Mojang AB在中国大陆地区包括游戏运营权在内的许多权利。

网易《我的世界》官方网站网址是：[全新视界 探索无限 | 网易《我的世界》](https://mc.163.com/index.html)

## 跋

如果你真的很喜欢Minecraft这个IP，那么建议在购买正版Minecraft之余，建议根据玩法喜好也尝试一下衍生的Dungeon、Legends等。但是如果你只打算游玩最经典的玩法，请考虑使用LauncherX游玩Java版。绝大多数情况下，Java版是兼顾兼容性和扩展性的最佳选择。

一般而言，为了区分网易代理版，会将原来的Minecraft称为国际版，而网易版就称呼为网易版或中国版。在某些情况下，要想自由地游玩国际版，对学习能力的要求要更高一些（也没高多少，会理解记忆会提问题就好）对于国际版和中国版，都存在对应的Java版和基岩版的差别：也就是说，国际版有的Java版和基岩版游戏之分，中国版也有。与此同时，根据经验，中国版的版本更新平均比国际版晚一年。

做出你的选择吧！

---

---
url: /zhCN/CMFS/help/invalid-session.md
---
# 解决“无效的会话”问题

::: info

在您加入开启**正版验证**服务器时可能会遇到来自游戏的错误提示。而这个错误提示往往伴随着解决此问题的建议。

也就是说，只有**正版账号** 在加入 开启**正版验证**的服务器时 才有可能会遇到这个问题。

:::

### 一般解决方法

这个错误只会在您启动游戏并加入某**正版验证**服务器时所使用的正版账号的验证信息失效时发生。可能的原因如下：

1. 游戏帐户的**验证信息过期**。
2. 在此设备登陆这个账户后，又在其他设备登陆该游戏帐户，导致**该验证信息失效**。

因此，唯一解决方案就是：**退出游戏**，然后**重新启动启动器**以让启动器重新获取验证信息用于正版登陆。

### LauncherX 用户

上述方法是原理性的，所以理论对任何启动器都有效。但是对于 LauncherX 用户来说，您无需重启启动器。只需要：

1. 退出游戏
2. 在恢复（默认）的 LauncherX 窗口中点击右下角您的账户名（或“请登陆”，如果您没有登陆日冕账户的话。）
3. 找到您出问题的账户（必然是微软账户，因为这是正版登陆的问题）
4. 右键点击它，并在右键菜单中点击“刷新”
5. 再次启动游戏

您当然也可以通过重启 LauncherX 的方式来刷新，不过倘若此刻您的 LauncherX 任务队列中存在着下载任务呢？

***

理论上，这样就可以获取到最新的验证信息，从而解决“无效会话”的问题了。

倘若仍然无法解决，您应该进行以下检查：

* 检查网络连接。如果您的连接存在问题，将很有可能导致无法正常获取您的正版账号信息。*相关参考文章*：[检测网络（LauncherX）](/zhCN/lxguide/settings/special/check-network)
* 检查您的正版账号状态。包括但不限于：账号启用状态（有没有出现封号？）和账号安全状态（账号是否被盗用？）。*相关链接*：[Microsoft账号管理](https://account.microsoft.com) | [Mojang账号管理](https://account.mojang.com) | [Microsoft帮助](https://support.microsoft.com/zh-cn/contactus/) | [Minecraft: 帮助](https://help.minecraft.net/hc/en-us)

---

---
url: /zhTW/projbobcat/resourceCompleter.md
---
# 資源補全器

在 ProjBobcat 中, 我們為開發者提供了用於補全 MineCraft 核心資原始檔的補全器.
這些資源包括：遊戲音訊、材質、貼圖、語言檔案、啟動所必須的庫檔案等.

---

---
url: /zhTW/projbobcat/resourceCompleter/resourceInfoResolver.md
---
# 資源資訊解析器

在 ProjBobcat 中, 我們使用 **資源資訊解析器**（ResourceInfoResolver）
來幫助資源補全器確定 MineCraft 缺失的檔案.

下表展示了目前 ProjBobcat 所支援的資源解析器：

|            類名            |                 簡介                  |
|:------------------------:|:-----------------------------------:|
|    AssetInfoResolver     |     用於解析遊戲所需要的資產（音訊、語言、字型和貼圖等）      |
| GameLoggingInfoResolver  | 用於解析 MineCraft 官方所提供的 log4j 日誌格式化元件 |
|   LibraryInfoResolver    |           用於解析遊戲啟動所必須的庫檔案           |
|   VersionInfoResolver    |       用於解析遊戲 JSON 中提供的 JAR 檔案       |

---

---
url: /ruRU/projbobcat/resourceCompleter/resourceInfoResolver.md
---
# 资源信息解析器

在 ProjBobcat 中, 我们使用 **资源信息解析器**（ResourceInfoResolver）
来帮助资源补全器确定 MineCraft 缺失的文件.

下表展示了目前 ProjBobcat 所支持的资源解析器：

|            类名            |                 简介                  |
|:------------------------:|:-----------------------------------:|
|    AssetInfoResolver     |     用于解析游戏所需要的资产（音频、语言、字体和贴图等）      |
| GameLoggingInfoResolver  | 用于解析 MineCraft 官方所提供的 log4j 日志格式化组件 |
|   LibraryInfoResolver    |           用于解析游戏启动所必须的库文件           |
|   VersionInfoResolver    |       用于解析游戏 JSON 中提供的 JAR 文件       |

---

---
url: /zhCN/projbobcat/resourceCompleter/resourceInfoResolver.md
---
# 资源信息解析器

在 ProjBobcat 中，我们使用 **资源信息解析器**（ResourceInfoResolver）
来帮助资源补全器确定 MineCraft 缺失的文件。

下表展示了目前 ProjBobcat 所支持的资源解析器：

|            类名            |                 简介                  |
|:------------------------:|:-----------------------------------:|
|    AssetInfoResolver     |     用于解析游戏所需要的资产（音频、语言、字体和贴图等）      |
| GameLoggingInfoResolver  | 用于解析 MineCraft 官方所提供的 log4j 日志格式化组件 |
|   LibraryInfoResolver    |           用于解析游戏启动所必须的库文件           |
|   VersionInfoResolver    |       用于解析游戏 JSON 中提供的 JAR 文件       |

---

---
url: /ruRU/projbobcat/resourceCompleter.md
---
# 资源补全器

在 ProjBobcat 中, 我们为开发者提供了用于补全 MineCraft 核心资源文件的补全器.
这些资源包括：游戏音频、材质、贴图、语言文件、启动所必须的库文件等.

---

---
url: /zhCN/projbobcat/resourceCompleter.md
---
# 资源补全器

在 ProjBobcat 中，我们为开发者提供了用于补全 MineCraft 核心资源文件的补全器。
这些资源包括：游戏音频、材质、贴图、语言文件、启动所必须的库文件等。

---

---
url: /zhCN/guide/general/donate.md
---
# 赞助我们！

::: info 本文包含一张白色居多的图片

如果您正在低环境光环境下使用本站的深色模式阅览，请做好准备。

:::

::: tip 就像街头艺人？

我们是一个用爱发电的组织，我们免费提供的软件离不开精神、更离不开物质上的支持。本文将介绍如何用最直接的方式向我们提供经济方面的物质支持。对于我们来说，哪怕是一次小小的赞助，都会被我们长久铭记。

如果您是未成年人，**请不要继续阅读此文章或尝试给我们打赏赞助。**

:::

如前文所说，我们是一个用爱发电的组织，通过**爱发电订单号**，我们将得以把您和您的日冕账户（CSA）相绑定，并以此给您提供**赞助者标识**，授权您接受**更敏捷、更快速相应**的LauncherX测试版更新通道 等服务或权限。若您注销并删除CSA账户，该赞助记录也将失效并不再可用。向我们提交爱发电订单号将额外提供此订单号相关的有效性信息，这些信息仅用于验证，使用过程遵守[爱发电使用条款](https://afdian.com/term)，且与支付相关的纠纷处理应与爱发电进行交涉。

赞助和绑定订单记录的方法如下：

1. 打开[日冕工作室官网的赞助页面](https://corona.studio/user/sponsor)。如果没有登录，请登录；如果登录后没有跳转到赞助页面，可以回来再点一次这个链接或通过用户中心的【赞助】按钮。
2. 点击下方卡片【前往爱发电赞助我们】的【前往】按钮以打开我们的爱发电页面。
3. 任意选择一个金额和周期，完成支付。
4. 成功支付后，回到您的爱发电的【管理】页面，在【订单-已支付】一栏可以找到最近的发电支付记录。找到最新的、被赞助人为【老腊肉】的卡片或条目，在靠下的地方可以找到【订单号】，其后有一个可供点击的【复制】文字按钮，点击以复制整个订单号。
   如图所示：
   ![guide-afd](/img/general/afd-guide.png)
5. 回到我们的官网赞助页面，将刚才复制的订单号粘贴到输入框中并提交。
6. 成功后将会有绿色框提示成功绑定，此时您就是我们的 “荣誉股东” 了！

如果期间遇到问题（比如，自己的订单号被绑定），请[联系我们](/zhCN/guide/contact.html)，我们可能会需要您提供一些信息和/或通过更多渠道来帮助我们核实信息，比如：

* 您的日冕账户注册邮箱
* 包含订单号的订单记录截图

我们会保护您的隐私，但是请仅在我们向您索要的时候再提供对应的信息。

::: warning 谨防诈骗

我们不会主动联系您来进行退款等操作。如果有人主动以相关理由与您联系，为确保安全，您可以通过爱发电站内私信功能等与我们核实。

:::

*双关了，欸嘿*

---

---
url: /zhCN/guide/general/check-system.md
---
# 辨识计算机环境

本文将简单介绍三类主流系统中判断系统版本和架构的方法。如果你确认你本来就知道，那就没必要看这篇文章。

\[\[toc]]

## Windows

### 首先，大致判断你的系统

#### 根据winver.exe

* 按下组合键`WIN` + `R`
* 在弹出窗口里输入`winver`，然后点击运行
* 在弹出窗口中可以看到你的系统版本。根据版本选择 **#1** 或是 **#2** 继续操作。

#### 根据外观

* 如果你的电脑系统开机后可看见 “欢迎使用”：
  这是Windows XP，我们的软件不支持。
* 如果你的任务栏和窗口标题栏看起来很圆润，或是在开机时候底部可见【Windows 7 xx版】或【Windows Vista】：
  这是Windows Vista或7，转到下文中的 **#1** 继续操作。
* 如果你的开始按钮不可见，或者开始按钮可见是一个斜面的四格图标，并且你的开始菜单是全屏的可以横向滚动的磁贴形式（全是大小不一的方块）：
  这是Windows8或Windows8.1，转到下文中的 **#1** 继续操作。
* 如果你的开始按钮旁有一个圆环图标或搜索图标（除非它们被关闭了），且开始菜单存在一些磁贴（不全是磁贴，不一定全屏，除非你自己更改过默认开始菜单），并且系统图标看起来是扁平的（而不是圆润的）并且开机动画是几个点转圈，登陆进入系统时背景是你的锁屏壁纸：
  这是Windows10。早期版本和后期红石更新有较大区别，但是八九不离十。下文中的 **#1** 和 **#2** 可能都适合你。
* 如果你的底部任务栏（除非你把它挪走了）上的开始按钮中可见【开始】字样，任务栏和窗口标题栏背景是灰色的，窗口是直角的，几乎不可见窗口动效动画：
  这可能是Windows XP、Windows 7、Windows8/8.1（精简版），或者更早的Windows。你可以尝试通过 **#1** 的步骤进行确认。这样的外观往往是被手动设置过后，或是处于安全模式（Windows 7 +），或是出于其他情况。
* 如果你开机后能看到锁屏界面并且时钟居中显示，或任务栏上的开始按钮是略显圆润的正方形四格图标，并且你在一些系统界面里点击右键出现的菜单是等边距的圆润的菜单（往往包含简洁的图标）：
  这是Windows 11。转到下文中的 **#2** 继续操作。
* 如果是这里没有提及的外观：
  你的系统外观可能被大幅度篡改了，或者本文未能及时更新（最后更新：2025年1月16日），尝试使用上文`winver.exe`方法判断系统版本。

::: info Windows Server

请注意，对于Windows Server，判断标准大致一致。

一般而言，Windows8及以后版本的Windows在UI风格上与WS2013及以后的Server版本一致，可以尝试找到设置后按#2方法操作，找不到设置则按#1方法。

对于更早版本的Windows Server，我们无法保证兼容性。

:::

### 其次，依据大致的系统版本确认详细信息

1. 较老的Windows （Vista/7/8/8.1/早期10）
   * 在桌面的空白区域右键点击鼠标，选择【属性】
   * 将会弹出一个来自控制面板的窗口。在这个窗口里可以查看系统的关键信息。
   * 找寻关键词，然后参考文末的[一般词对照表](#一般词对照表)来确认你的电脑使用的系统具体版本和CPU架构。

2. 较新的Windows（红石10/11）
   * 打开**系统设置**（或使用组合键`WIN` + `I`）
   * 搜索或找到：
     \[系统 -> **系统信息**] 或 \[系统 -> **关于**]
   * 在这里可以查看系统信息。参考文末的[一般词对照表](#一般词对照表)来确认你的电脑使用的系统具体版本和CPU架构。

## Linux

Linux用户一般都知道自己的操作系统版本和类型以及处理器架构。如果不知道的话，参见下文中**通用的方法**。

请注意，我们的产品除非是命令行应用程序，否则需要一个桌面环境来运行。

参考文末的[一般词对照表](#一般词对照表)来确认你的电脑使用的系统具体版本和CPU架构。

## macOS

一般而言，可以通过点击左上角的**Apple图标**后点击菜单中的【关于本机】来查看关键信息。

当然，如果你喜欢使用终端，除了使用下文**通用的方法**，还可以：

1. **打开终端**

   * 按下 **Command + 空格键**，输入 **“终端”**，然后按回车键打开终端。

2. **输入以下命令**

   ```bash
   sw_vers
   ```

3. **查看输出结果**

   * 终端会显示类似以下的信息：

     ```
     ProductName:    macOS
     ProductVersion: 13.0.1
     BuildVersion:   22A400
     ```

   * 其中，`ProductVersion` 表示 macOS 的版本号。

4. 如果想要查看**CPU架构**：

   * 在终端中输入以下命令：

     ```bash
     arch
     ```

   * 查看输出结果：

     * 如果结果是 **`arm64`**，说明你的系统当前运行在 **Apple Silicon（ARM 架构）**。
     * 如果结果是 **`i386`** 或 **`x86_64`**，说明你的系统运行在 **Intel 架构**。

参考文末的[一般词对照表](#一般词对照表)来确认你的电脑使用的系统具体版本和CPU架构。

## 通用的方法（xxfetch）

对于上述系统的现代化版本（即，肉眼可见的能感受到系统它很新：Windows10+，macOS10.15+，Linux(内核版本5+)）一般都可以通过安装一种fetch工具来获取当前的关键系统信息。甚至可以拿来截图装X

以下介绍了各个系统如何安装和使用`neofetch`：

### 安装Neofetch

#### **Windows**

在 Windows 系统上，可以通过在Powershell中可运行的包管理器 `scoop` 或者 `choco` 来安装 `neofetch`。

##### 使用 Scoop：

1. 确保已安装 Scoop（未安装请参考 [Scoop 的安装指引](https://scoop.sh/) Quickstart片段）。
2. 打开 PowerShell 或命令提示符，运行：
   ```powershell
   scoop install neofetch
   ```
3. 安装完成后，运行 `neofetch`。

##### 使用 Chocolatey：

:::warn 替代软件

在Chocolatey的默认源中，笔者没能找到neofetch，但类似的工具`winfetch`是可用的。

:::

1. 确保已安装 Chocolatey（未安装请参考 [Chocolatey 的安装指引](https://chocolatey.org/install#install-step2) ，运行第二步中可以复制并在Powershell中执行的命令）。
2. 打开 PowerShell 或命令提示符（以管理员身份运行），执行：
   ```powershell
   choco install winfetch
   ```
3. 安装完成后，运行 `winfetch`。

***

#### **macOS**

在 macOS 上，可以通过 Homebrew 包管理器安装 `neofetch`。

##### 使用 Homebrew：

1. 确保已安装 Homebrew（未安装请参考 [Homebrew安装指引](https://docs.brew.sh/Installation)）。
2. 打开终端，执行以下命令安装 `neofetch`：
   ```bash
   brew install neofetch
   ```
3. 安装完成后，运行 `neofetch`。

***

#### **Linux**

在 Linux 系统上，`neofetch` 通常可以通过系统的包管理器直接安装。以下是基于不同包管理器的安装步骤：

##### **使用 pacman（Arch Linux 及其衍生发行版，如 Manjaro）：**

1. 打开终端，运行以下命令：
   ```bash
   sudo pacman -S neofetch
   ```
2. 安装完成后，运行 `neofetch`。

##### **使用 apt（Debian、Ubuntu 及其衍生发行版，如 Linux Mint）：**

1. 打开终端，运行以下命令：
   ```bash
   sudo apt update
   sudo apt install neofetch
   ```
2. 安装完成后，运行 `neofetch`。

##### **使用 dnf（Fedora 及其衍生发行版，如 RHEL 和 CentOS Stream）：**

1. 打开终端，运行以下命令：
   ```bash
   sudo dnf install neofetch
   ```
2. 安装完成后，运行 `neofetch`。

### 使用Neofetch

运行`neofetch`命令后，应该会在终端里打印出这样的内容：

![effect-zhcn](/img/general/misc/fetch-os.png)

要确认系统版本和CPU架构，只需要看OS那一行即可。一般而言，那里会有两个部分表示本文中涉及的关键信息。请根据文末的一般词对照表来分析。

## 一般词对照表

| 类型                       | 可能出现的词                                                 | 解释                                                         |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 系统类型/系统名称/系统版本 | Windows，Windows NT，NT (Windows);macOS，OS X，Mac OS X (macOS);Fedora，Ubuntu，Linux，Manjaro，Arch (Linux); | 目前主流操作系统基本就是这三类。Linux用户一般不会不知道自己的系统信息（除非使用的是单位发的国产电脑——目前我们的产品基本未验证其兼容性。以及其他的边缘情况。）系统版本往往作为数字出现在系统名称后面。 |
| 系统架构/CPU架构/指令集    | x86\_64，x86，64-bit，amd64，arm64，ARM，armv8，aarch (或类似形式的词) | 如果你在设备上看到 `x86_64`、`64-bit` 或 `amd64`，这些通常表示你的操作系统是 64 位的，或者你的 CPU 使用 64 位架构。我们通常将这一架构简称为 **`x64`**。 相对地，如果你看到的是 `x32` 或 `x86`，则表示设备使用的是 32 位架构。需要注意的是，我们的软件通常 **不再支持任何32位架构**。除此之外的情况除非有特殊说明否则均不保证兼容。 |
| CPU类型或CPU型号           | Apple Silicon，M1，M1 Ultra，Snapdragon (ARM处理器);Ryzen，CORE，..。(现代常见x64处理器系列);  | 如果你看到的是 **`arm64`**（请注意，这与 `amd64` 完全不同，千万不要混淆！），或者单独出现了 **`ARM`**、**`aarch`**，亦或包含了这些词汇，则通常表示你的 CPU 是基于 **ARM 架构** 的。近年来，许多使用 ARM 处理器的设备（例如部分笔记本电脑或移动设备）都采用了 **`arm64`** 架构。 |

---

---
url: /zhCN/geula.md
---
`@useFixer`

# 通用隐私政策和最终用户许可协议

:::warning

由于目前提供的服务有限，这里会频繁地更新。当内容出现重大更新 (包括服务内容变更: 添加/删除/修改，向使用我们服务和产品的【用户】但是不包括优化遣词造句) 时候，我们才会通知您。

*我们是用爱发电的团队，我们也懒得侵犯您的数据隐私。*

本页面更新于 2025年5月3日，没有更新通知。试行。

:::

\[\[toc]]

## 1) 简而述之…

我们是一个用爱发电的团队，目前没有与任何一个第三方实体有任何利益往来。我们不记录也不追踪您的广告ID，我们也不在服务中植入动态广告。`i`

我们在为您提供在线服务的过程中，使用主流的加密方案传输和存储最基本的、能让我们在茫茫信息流之中认出您的信息: 包括且不限于您的IP地址，LauncherX收集清单中的信息 (若拒绝遥测则不会获取遥测部分的信息)，您主动提供的邮箱地址、您在使用LauncherX保存微软账户时提供的由微软验证并保护的密钥 (用于验证您微软账户的可用性，这关系到您能否使用微软账户来游玩Minecraft)、缓存的玩家皮肤(用于皮肤预览，这属于您与Mojang AB缔结的用户协议的一部分.); 以及在您登陆我们的在线服务时，产生的用户密钥和必要信息 (包括邮箱、登陆设备IP、在P2P服务器注册的房间记录等)。`i`

此外，在您使用CMFS服务时，正版验证服务器将会缓存您正版游戏账户的UUID、加密皮肤缓存、登陆设备IP以及服务器内聊天记录 (作为服务器运行日志保存)。`i`

**可能我们活得气若游丝，但是我们想要活得清白**。`i`

## 2) 在线存储、传输和用户隐私保障

### 总则

针对不同的在线服务需要，您的必要信息将会由您使用的客户端 (网页浏览器、游戏本体、由我们提供的客户端应用程序) 代为收集，并通过网络加密传输到我们处理信息所使用的服务器。这个服务器可能是由第三方提供服务 (比如，我们处理您的Minecraft在线账户必须通过Microsoft的验证。这部分服务协议在您注册微软账户时候应当已经同意.) 我们仅能保证和尽力维护您从运营商区域网络到达我们相关服务器的传输安全，在此之前在您必要经过的网络上出现的意外 (网络被劫持、被侵入、网络不可用等) 恕我们不能为此负责。`i`

您为了使用服务所必须提供的信息，除非另行说明或者明显是委托第三方的服务，否则均会由我们妥善加密保存，并仅供与此相关的由我们提供的在线服务所使用。`i`

:::danger

请注意! 使用代理上网相当于把您的信息传输委托到了第三方。请确保此第三方可信任，出现的任何意外将不由我们承担责任。此外，部分我们的客户端 (比如LauncherX) 在不正确的代理设置下可能导致部分在线功能不可用。`i`

:::

### 同意协议和撤回同意

请注意，为了证明您同意或不同意，我们可能会需要通过各种合法方法来取得您作为用户（或曾为用户）的身份确认。`i`

#### a) 同意

一般来说，使用我们提供的服务和/或产品本身没有繁杂的协议和弯弯绕。我们从用户的角度出发，收集我们维持程序运转的必要信息和非敏感的环境信息等。与此同时，若您**访问和提交内容到CSKB / 仅浏览我们的网站内容**，则不需要完全同意本协议。但是浏览期间，您的互联网协议地址（IP）无论是否通过代理都必然会被网络运营的各个部分获取，因为这是通过互联网传输信息的必要前提。`i`

对于我们分发的软件产品，您有权利在正式开始使用之前阅读有关条文协议，点击【同意】或等效按钮继续使用将被视为您同意了此协议及相关的其他协议（如果有），若您不同意则请立即停止使用。`i`

对于我们通过互联网提供的网站和服务，在合适的地方我们会提示您，您需要阅读有关条文协议，而继续访问服务的操作（比如，注册账户和登录操作）和/或其他明确表示同意的行为（比如，勾选 “我已同意…” ）将被视为同意协议。与此同时，网站可能会单独请求同意使用信息或通知您网站使用了特定技术。`i`

对于我们提供的公益性质游戏服务器，请参阅本站的**CMFS**部分（参见：[欢迎来到 CMFS 指南 | 日冕知识库](https://kb.corona.studio/zhCN/CMFS/)），以确认其附属的用户协议等内容。我们要求附属服务器的各个分管团队在您首次登入服务器的时候在游戏中推送给您，并且将在玩家群聊中以群公告的形式引导您阅读（如果有）。首次加入服务器游玩、注册玩家信息等产生玩家信息将被视为同意本协议**有关CMFS的部分及附属的用户协议等内容**。`i`

总而言之，表示【同意】的行为视提供和/或呈现此协议时附带的文字说明而定。它可以是“继续使用即为同意”，也可以是“勾选以同意”，也可以是“点击同意”。`i`

#### b) 撤回

出于人与人之间最基本的信任，我们相信您在撤回同意生效期间不会直接或间接地再使用我们的任何产品和服务。在您停止**使用或间接使用**我们的产品和服务满30天后，或提供有效的撤回声明，即可视为撤回同意。但是，在撤回同意后的任意时段使用我们的产品和服务（除了CSKB）参照同意协议的行为，会被视为再次同意本协议。仅浏览我们提供的网站不被视作再次同意。`i`

与此同时，针对日冕账户（CSA），您若需要停止使用我们的服务并删除账户，视为撤回对我们储存和使用您提供的个人信息的同意；要删除账户，您可以登录到[corona.studio](https://corona.studio/user)后，在[个人中心](https://corona.studio/user)找到【注销并删除】账户的按钮。此操作不可逆，将会删除包括我们保存的必要用户数据、赞助记录、皮肤站信息（如有）之内的一切数据。`i`

### 资产

我们持有的资产包括声明的知识产权、持有的软件/内容仓库和数据库数据。您主动提供的数据被视为资产的一部分，将被我们存储至数据库，以用于向您提供服务。对于涉及您敏感信息的内容，我们将按需进行脱敏、加密保存。具体参见下文关于隐私收集和处理的部分。`i`

### 收集清单

> 以下是不同包含在线服务的产品的收集清单。

#### 1. 日冕账户

这是访问我们绝大多数在线服务的前提。在需要使用其登陆时，我们会提示您。

| 收集项目                   | 介绍                                  |
| -------------------------- | ------------------------------------- |
| 邮箱地址                   | 用于标识您的账户并在后续向您发出通知。|
| 加密后的密码               | 用于确认登陆账户的客体是不是您本人。  |
| 用户名                     | 这是友好展示您个人资料的文字内容。    |
| 头像(若不上传则为随机图片) | 这是友好展示您个人资料的图像内容。    |

#### 2. LauncherX

详情: [官网](https://corona.studio/launcherx) | [官网.min](https://min.corona.studio/lx)

标注\[\*]的项目为可选项目。您可以在初次启动配置时或随时在 \[设置->[高级](/zhCN/lxguide/settings/item/advanced.html): 数据采集和隐私政策] 中调整收集与否。

标注\[+]的项目为匿名上传的，完全不与您的个人信息绑定。

| 收集项目                   | 介绍                                                         |
| -------------------------- | ------------------------------------------------------------ |
| 互联网协议地址(IP)         | 通过互联网传输信息的必要前提。                               |
| 用户计算机硬件配置         | 这是识别这台计算机并形成唯一识别证据的必要信息。仅在您使用预览版或绑定设备时上传并保存 |
| 计算机名称                 | 用于友好地在设备列表中展示您的设备。仅在您使用预览版或绑定设备时上传并保存 |
| 由LauncherX发起的网络活动+ | 这将会帮助我们分析和优化。                                   |
| 启动器任务调度详情+        | 这将用于分析启动器任务处理性能，并将帮助我们来优化相关功能。 |
| 启动器产生的日志+          | 无论是否登陆了启动器账户，都会脱敏后加密上传日志和错误报告。 |
| 部分启动器操作事件         | 与我们在线服务器直接交互的操作。比如“绑定设备”、“解绑设备”   |
| 崩溃信息+                  | 更严重的错误信息会相比于日志而言收集更详细的环境信息，并将在崩溃时立刻发出。|
| 系统语言和地区\*+           | 用于收集和分析不同国家区域、使用不同语言的用户的使用习惯。需要反馈本地化问题? 请[按照反馈格式](/zhCN/lxguide/report-issue)向我们反馈。|
| 操作系统版本\*+             | 用于辅助分析软件环境情况                                     |
| 游戏启动事件\*+             | 用于跟踪启动错误和分析错误、优化产品。                       |
| 游戏时长\*+                 | 用于辅助分析游戏崩溃原因。如果是玩太久导致的溢出等错误那就不是我们的问题。请适当娱乐。|
| 使用时长\*+                 | 用于辅助分析本体崩溃原因。                                   |
| 游戏启动参数\*+             | 用于辅助分析启动错误 有关游戏启动参数配置，您可以参阅: [启动参数配置指引](/zhCN/lxguide/others/args) |

#### 3. CS Official Site

详情: [官网](https://corona.studio)

这项服务通过Cloudflare加速。少量信息(包括IP)可能会经由这些服务提供方。

| 收集项目                              | 介绍                                               |
| ------------------------------------- | -------------------------------------------------- |
| 互联网协议地址(IP)                    | 通过互联网传输信息的必要前提。                     |
| 日冕账户(可选)                        | 在您登陆后可用于管理账户和LauncherX绑定设备管理等。|
| 由我们创建的SessionStorage            | 临时存储的登陆凭证。                               |
| 隐私通知已阅与否 (存储在LocalStorage) | 记录您是否已经“了解并关闭”了页面的隐私声明。       |

#### 4. CS Official Site MIN

详情: [官网.MIN](https://min.corona.studio) | [官网.MIN.another](https://csmin.kami.su)

这项服务通过Cloudflare加速，部署在vercel平台。少量信息(包括IP)可能会经由这些服务提供方。

MIN.another 部署在热铁盒网页托管。

| 收集项目                              | 介绍                                        |
| ------------------------------------- | ------------------------------------------- |
| 互联网协议地址(IP)                    | 通过互联网传输信息的必要前提。              |
| 外观偏好(存储在LocalStorage)          | 暂存您选择的深色/浅色模式设定。             |
| 隐私通知已阅与否 (存储在LocalStorage) | 记录您是否已经“了解并关闭”了页面的隐私声明。|

#### 5. CMFS

详情: [官网](https://corona.studio/cmf) | [官网.min](https://min.corona.studio/cmf)

CMFS附属的**所有游戏服务器**均可能会将您的游戏行为脱敏后通过遥测加密传输到服务端可能内置的bStats。我们在有需要的情况下会借助Spark进行在线性能分析。与此同时，您在游玩时必须遵守Mojang的[Minecraft Eula](https://www.minecraft.net/en-us/eula).`i`

请参阅本站的**CMFS**部分（参见：[欢迎来到 CMFS 指南 | 日冕知识库](https://kb.corona.studio/zhCN/CMFS/)），以确认其附属的用户协议等内容。我们要求附属服务器的各个分管团队在您首次登入服务器的时候在游戏中推送给您，并且将在玩家群聊中以群公告的形式引导您阅读（如果有）。`i`

| 收集项目                                      | 介绍                                |
| --------------------------------------------- | ----------------------------------- |
| 互联网协议地址(IP)                            | 通过互联网传输信息的必要前提。      |
| 游戏客户端信息                                | 用于反作弊和对接游戏行为。          |
| 玩家信息 (正版玩家和外置登陆玩家的UUID、皮肤) | 用于识别玩家和展示游戏内名称和皮肤。|

#### 6. CSKB

详情: [日冕知识库](https://kb.corona.studio)

| 收集项目           | 介绍                            |
| ------------------ | ------------------------------- |
| 互联网协议地址(IP) | 通过互联网传输信息的必要前提。\* |

::: info 例外

日冕知识库是完全公益性质的。其内容使用`MIT`协议提供和分享、共建（除非引用文章有特别说明 —— 在直接引用CSKB文章时，不得引用包含特别许可证的文章，除非遵从其许可证或得到原作者许可）。日冕知识库的访问流量指向其托管平台和中间的网络服务提供商，我们仅管理和展示、提供内容。因此，CSKB在您访问时不会征求您同意本协议，与此同时，在撤回同意期间和之后使用CSKB的内容本身（阅览、提交贡献、引用）**不被视为中止撤回同意或同意本协议**。`i`

当前日冕知识库部署在 `Github`，即，`Github` 是CSKB 的托管平台，在访问时和访问期间，您的数据经由 `Github`、`Github` 选择的网络服务商、您的ISP、`Cloudflare` 加密传输。日冕工作室无法获取到您的信息，除非您通过托管平台提交内容。**请自行保护自己的信息安全**，并且您在提交内容时**被视为已经同意了托管平台的有关政策**。`i`

*Github 是 Github Inc. 的商标；Cloudflare 是 Cloudflare Inc. 的商标。*

:::

## 3) 免责声明

对于特定的情况和一切非因来自我们的错误导致的问题所造成的一切后果，我们概不负责。`i`

### 用户行为免责

* 由于您未按照提示操作导致的错误和损失，我们不负责。
* 由于您使用服务时使用的终端的环境问题导致的不可用，或是由于您个人主观意愿对服务在您终端本地运作环境制造的障碍导致的原因致使我们的服务出现错误，我们不负责。

### 其他环节原因免责

* 极个别地区出现的服务访问困难问题是我们难以解决的。我们会尝试解决，但是不保证可以解决。
* 因网络攻击、自然灾害等不可抗力、难以预料和防御的突发情况导致的问题，我们不负责任。但是我们会尽可能恢复我们预期的服务状态。

### 边缘情况免责

边缘情况是由我们提供的服务在极不常见的使用情况下出现错误导致的异常。 我们对一切符合边缘情况条件并且没有造成严重后果的故障不负责任，但是我们仍然会尝试修复这些错误。`i`

* 由于各种原因 (包括但不限于软件框架限制) 导致的边缘使用情况引起的非预期错误 (比如，LauncherX可能在极度快速切换界面时可能出现显示错误。)
* 由于硬件和/或软件环境差异导致的性能异常 (比如，在个别设备上LauncherX可能需要耗费十几秒时间启动自身，但是在 “与系统熟悉后” 却可以做到仅仅两三秒即可启动自身)

除此之外的问题请务必向我们反馈。`i`

## 4) 用户许可协议

关于您能如何使用我们产品的协议。在使用我们的产品和/或服务时，请严格遵守所在地的法律法规、中华人民共和国的相关法律法规，以及其他诸如开源项目许可证之类的附加项。我们希望您正常地使用一切工具，过好自己的生活。`i`

### 开源项目

请严格遵守项目对应的**开源许可证**.

::: tip 目前我们的开源项目均在Github可见

查看我们的Github主页: https://github.com/corona-studio

此处不再展示完整的开源项目及其许可证列表。

:::

::: details CSKB 例外

CSKB 在原则上要求贡献者基于MIT许可证提交内容贡献。我们建议只提交使用同许可证或更宽松的许可证的内容。但是如果是转载文章且文章原作者并未授权更改许可证的转载，或是作者一定要使用更严格的许可证，则：`i`

* 其他人挪用CSKB内容时，必须将使用不兼容许可证的内容排除；
* 若要再转载使用更严格许可证的内容，必须征得原作者的允许或遵守对应的许可。

如若发现CSKB中有对您的内容的侵权行为，请通过 [CSKB Issues](https://github.com/Corona-Studio/docs/issues) 提交举报并举证，我们会尽快处理。

:::

### 闭源项目

请展开来查看详细信息.

::: details LauncherX

您可以将LauncherX打包进您的懒人包/完整包中(无论是否使用LauncherX的打包功能)，但是您不能:

* 违反游戏版权方的用户协议
* 售卖打包成品
* 售卖LauncherX程序文件
* 将LauncherX署名/宣称为自己的作品
* …其他会对LauncherX之存在造成负面影响的行为，我们将会自行认定和解释负面影响。

2019~当今，我们对LauncherX（由Corona Studio推出的游戏启动器）保留一切权利。

:::

### 其他

::: details 更新记录

* 2025年2月25日：添加了同意与撤回同意相关的描述，并且修正了一些符号错误，为本页引入扩展样式。
* 2025年2月27日：细化规则，细化适用场景，修改部分内容，删除开源项目列表（应该直接去Github查看）

:::

## 文档有效性

2025年2月27日：暂行/无效，因为尚未完成审核。

---

---
url: /ruRU/projbobcat/createNewAzureApp.md
---
# 配置 Azure 应用

\[\[toc]]

## 开始配置

在开始之前, 您首先需要一个微软账号. 注册 Azure Active Directory 应用无需任何费用.

使用您的微软账户登录 [Azure 门户](https://portal.azure.com/#home)
在完成登录后, 您看到的页面应该是这样的：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_1.png)

点击 **Azure 服务** 下的 **Azure Active Directory**

![Azure AD](/img/projbobcat/installationAndConfig/configMSAuth/azure_ad.png)

您将会看到类似于下面的页面

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_2.png)

接着点击左侧功能栏的 **应用注册**：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/reg_app.png)

点击顶部工具栏的 **新注册**, 填写应用的名称. 并且在 **受支持的账户类型** 中选择 **仅 Microsoft 个人账户**.
由于我们不使用基于 URI 回调的认证方式. 因此, 您不需要填写表单下方的 **重定向 URI**.

::: warning
请仔细核对表单中的信息, 否则可能会导致后续的步骤出现意料之外的问题.
:::

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_3.png)

点击创建后, 等待 Azure AD 完成应用的创建. 在创建完成后, 网页会将您重定向至该应用的详细页面：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_4.png)

接着点击左侧栏的 **身份验证**：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/identity_verification.png)

接着在右侧找到 **高级设置** 板块, 确保板块中的 **高级 SDK 支持** 和 **允许公共客户端流** 为开启状态.
如果他们没有开启, 请手动将他们打开.

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/id_advanced_settings.png)

接着点击下方的保存按钮, 等待保存完成.

## 查看 Client ID

恭喜！您已经完成了 Azure 的应用注册, 接下来您只需要前往 **概述** 页面查看应用的 Client ID.
点击左侧栏的 **概述** 按钮, 即可查看应用的基础信息：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/about.png)

在右侧您会看到应用的详细信息, 在 **概要** 中找到 **应用程序(客户端) ID**,
该 ID 将是您需要在 [微软验证器配置](/ruRU/projbobcat/installationAndConfig) 阶段需要使用到的 Client ID.

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/about_block.png)

---

---
url: /zhCN/projbobcat/createNewAzureApp.md
---
# 配置 Azure 应用

\[\[toc]]

## 开始配置

在开始之前，您首先需要一个微软账号。注册 Azure Active Directory 应用无需任何费用。

使用您的微软账户登录 [Azure 门户](https://portal.azure.com/#home)
在完成登录后，您看到的页面应该是这样的：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_1.png)

点击 **Azure 服务** 下的 **Azure Active Directory**

![Azure AD](/img/projbobcat/installationAndConfig/configMSAuth/azure_ad.png)

您将会看到类似于下面的页面

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_2.png)

接着点击左侧功能栏的 **应用注册**：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/reg_app.png)

点击顶部工具栏的 **新注册**，填写应用的名称。并且在 **受支持的账户类型** 中选择 **仅 Microsoft 个人账户**。
由于我们不使用基于 URI 回调的认证方式。因此，您不需要填写表单下方的 **重定向 URI**。

::: warning
请仔细核对表单中的信息，否则可能会导致后续的步骤出现意料之外的问题。
:::

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_3.png)

点击创建后，等待 Azure AD 完成应用的创建。在创建完成后，网页会将您重定向至该应用的详细页面：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_4.png)

接着点击左侧栏的 **身份验证**：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/identity_verification.png)

接着在右侧找到 **高级设置** 板块，确保板块中的 **高级 SDK 支持** 和 **允许公共客户端流** 为开启状态。
如果他们没有开启，请手动将他们打开。

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/id_advanced_settings.png)

接着点击下方的保存按钮，等待保存完成。

## 查看 Client ID

恭喜！您已经完成了 Azure 的应用注册，接下来您只需要前往 **概述** 页面查看应用的 Client ID。
点击左侧栏的 **概述** 按钮，即可查看应用的基础信息：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/about.png)

在右侧您会看到应用的详细信息，在 **概要** 中找到 **应用程序(客户端) ID**，
该 ID 将是您需要在 [微软验证器配置](/zhCN/projbobcat/installationAndConfig) 阶段需要使用到的 Client ID。

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/about_block.png)

---

---
url: /zhTW/projbobcat/createNewAzureApp.md
---
# 配置 Azure 應用

\[\[toc]]

## 開始配置

在開始之前, 您首先需要一個微軟賬號. 註冊 Azure Active Directory 應用無需任何費用.

使用您的微軟賬戶登入 [Azure 門戶](https://portal.azure.com/#home)
在完成登入後, 您看到的頁面應該是這樣的：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_1.png)

點選 **Azure 服務** 下的 **Azure Active Directory**

![Azure AD](/img/projbobcat/installationAndConfig/configMSAuth/azure_ad.png)

您將會看到類似於下面的頁面

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_2.png)

接著點選左側功能欄的 **應用註冊**：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/reg_app.png)

點選頂部工具欄的 **新註冊**, 填寫應用的名稱. 並且在 **受支援的賬戶型別** 中選擇 **僅 Microsoft 個人賬戶**.
由於我們不使用基於 URI 回撥的認證方式. 因此, 您不需要填寫表單下方的 **重定向 URI**.

::: warning
請仔細核對表單中的資訊, 否則可能會導致後續的步驟出現意料之外的問題.
:::

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_3.png)

點選建立後, 等待 Azure AD 完成應用的建立. 在建立完成後, 網頁會將您重定向至該應用的詳細頁面：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/step_4.png)

接著點選左側欄的 **身份驗證**：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/identity_verification.png)

接著在右側找到 **高階設定** 板塊, 確保板塊中的 **高階 SDK 支援** 和 **允許公共客戶端流** 為開啟狀態.
如果他們沒有開啟, 請手動將他們開啟.

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/id_advanced_settings.png)

接著點選下方的儲存按鈕, 等待儲存完成.

## 檢視 Client ID

恭喜！您已經完成了 Azure 的應用註冊, 接下來您只需要前往 **概述** 頁面檢視應用的 Client ID.
點選左側欄的 **概述** 按鈕, 即可檢視應用的基礎資訊：

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/about.png)

在右側您會看到應用的詳細資訊, 在 **概要** 中找到 **應用程式(客戶端) ID**,
該 ID 將是您需要在 [微軟驗證器配置](/zhTW/projbobcat/installationAndConfig) 階段需要使用到的 Client ID.

![Azure Portal](/img/projbobcat/installationAndConfig/configMSAuth/about_block.png)

---

---
url: /zhCN/lxguide/startup/perOsSetup/linux.md
---
# 针对 Linux 系统的特殊设置

\[\[toc]]

## 对于基于 ARM64 架构的 Linux 发行版

::: warning

由于 Mojang 官方还并未正式支持 ARM64 版本的 Linux 游戏。
因此，在使用 LauncherX 之前，您需要手动下载并安装 JRE 运行时。

:::

### 下载并安装 JRE 运行时

在这里我们将使用 [Azul JDK](https://www.azul.com/downloads/#zulu) 来演示 JRE 的安装。

在 [Azul JDK 官方网站](https://www.azul.com/downloads/#zulu) 中，稍微下拉一点即可看到 JDK 版本筛选框：

![azul-website](/assets/azul-website.Bz9-pqV-.png)

在 **Operating System** 处选择 **Linux**，在 **Architecture** 处选择 **ARM 64-bit**
即可获取到所有可用的 JDK 版本。

在右侧的 **Download** 按钮中选择 `.tar.gz` 格式的 JDK 运行时，下载后将其解压到任意一处本地文件夹。
随后在 LauncherX 中选择 **手动添加**，并选择 JDK 文件夹 **bin/** 目录下的 **java** 可执行文件即可。

有关于JRE的选择，参见:   [配置内存和GC、JavaAgent](/zhCN/lxguide/others/adjust-ram-gc-ja)

## 如果您无法启动

您需要尝试做出以下操作：

* 打开新的终端，或者使用刚才出现的终端
* 在其中键入 `export LC_CTYPE=en_US.UTF-8`，执行
* （如果有必要的话，上述步骤可以使用管理员权限\[sudo]）
* 再次尝试运行。如果失败，尝试重新登录。
* 如果再次失败，请务必依照 [这里的方法](/zhCN/lxguide/report-issue) 向我们反馈。

:::tip 这个问题可能已经在正式发布的稳定版中解决了.

:::

## 其他建议

若您需要其他更加详细的配置，或者纯小白用户，建议阅读：[Linux配置指南](/zhCN/lxguide/startup/others/Linux-Guide)

* 专项：Linux需要其他平台一样的UI外观！如何移除掉丑陋的标题栏并保持窗口按钮：[Linux：干掉标题栏，还我一致感 | 日冕知识库](/zhCN/lxguide/settings/special/linux-as-others)

---

---
url: /zhCN/lxguide/startup/perOsSetup/macOS.md
---
# 针对 macOS 系统的特殊设置

## 一般问题

对于 macOS 用户，若您在打开 LauncherX 时候出现“已损坏”相关的错误弹窗，请执行以下操作：

* 打开 “终端.app”
* 打开您的访达窗口，并找您的LauncherX执行文件 (LauncherX.app 或 LauncherX.Avalonia.app)
* 在终端输入 `sudo xattr -d com.apple.quarantine` 或者 `sudo xattr -cr` (任选其一即可)
* 在上述指令末尾有一个空格的前提下，将您的 **LauncherX APP** 拖入到终端窗口
* 运行。终端将会要求您输入管理员账户的密码。请凭感觉如实输入，终端不会在显示区域呈现您任何的输入记录
* 在键入密码之后按下键盘上的 `Enter` 确认，执行成功不会有任何提示。
* 然后再次尝试启动 LauncherX，如果再次失败，请务必[向我们反馈](/zhCN/lxguide/report-issue)。

## 对于基于 ARM64 架构的macOS

::: warning

由于 Mojang 官方还并未正式支持 ARM64 版本的 macOS 游戏与对应的JRE下载，
因此，在使用 LauncherX 之前，您需要手动下载并安装 JRE 运行时。

:::

### 下载并安装 JRE 运行时

在这里我们将使用 [Azul JDK](https://www.azul.com/downloads/#zulu) 来演示 JRE 的安装。

在 [Azul JDK 官方网站](https://www.azul.com/downloads/#zulu) 中，稍微下拉一点即可看到 JDK 版本筛选框：

![azul-website](/assets/azul-website.Bz9-pqV-.png)

在 **Operating System** 处选择 macOS，在 **Architecture** 处选择 **ARM 64-bit**
即可获取到所有可用的 JDK 版本。

在右侧的 **Download** 按钮中选择 `.zip` 格式的 JDK 运行时，下载后将其解压到任意一处本地文件夹。
随后在 LauncherX 中选择 **手动添加**，并选择 JDK 文件夹 **bin/** 目录下的 **java** 可执行文件即可。

有关于JRE的选择，参见:   [配置内存和GC、JavaAgent](/zhCN/lxguide/others/adjust-ram-gc-ja)

---

---
url: /zhCN/lxguide/startup/perOsSetup/windows.md
---
# 针对 Windows 系统的特殊设置

::: warning

请注意， LauncherX  **不支持** Windows7以下版本的操作系统，以及任意一个版本的Windows S。

对Windows7的支持可能**随时终止**. 如果您使用Windows7, 请尽早升级, 或阅读[Windows7 安装指南](/zhCN/lxguide/startup/others/win7)...

:::

目前，您不需要进行任何额外配置即可使用 LauncherX 启动器的全部功能。

…但是您可能会遇到一些意外，如图所示：

![exception](/img/lxguide/perOsSetup/windows-exception.png)

类似于这样的弹窗——会要求您先在Microsoft Store下载安装“供任务执行的程序”，或者由 SmartScreen 弹出的“警示安全风险”的提示弹窗：

请将其关闭，并且执行以下步骤（或者, 对于SmartScreen的弹窗提示, 点击“更多选项”, 然后点击“继续运行”，跳过后续步骤并再次尝试启动 LauncherX）：

1. 右键单击您的 LauncherX 可执行文件
2. 点击`“属性”`
3. 找到如图中标记出的勾选框并将其勾选: （图片中借用`Everything`刚从网上下载时的“属性”窗口为示范。）![checkbox.png](/assets/checkbox.1J9L04XC.png)
4. 点击`“应用”`，然后关闭`“属性”`窗口。
5. 尝试启动 LauncherX 。如果仍然无法工作，请[与我们取得联系](/zhCN/guide/contact)

::: warning

如果在尝试启动 LauncherX 时候出现了来自其他安全类软件的警告，那么您需要允许 LauncherX 运行以使用 LauncherX 。若您对 LauncherX 持有怀疑，可以前往[VirusTotal](https://www.virustotal.com)这种权威的线上沙盒并将您下载的 LauncherX 副本上传检测。

:::

### 对于Windows7

我们预计将在Windows10被微软结束支持后，原则上不再为新功能在Windows7的可用性作担保；同样的，在此发生的一年后，原则上不再为新功能在Windows8/8.1上的可用性作担保。但是理论上，只要系统框架允许，LauncherX将一直能在Windows7及更高版本的Windows中可用，只是可能不能完全按照预期工作，以及可能需要安装额外的支持性软件和运行时。

比如我们在测试过程中发现，LauncherX若需要在Windows10以前的系统上运行，可能需要自行安装一些支持库, 以及某个或某些**特定的Windows更新包** (KB3118401)。

* Windows7：[查看环境安装引导](/zhCN/lxguide/startup/others/win7)
* Windows8/8.1：[Download Update for Windows 8.1 for x64-based Systems (KB3118401) from Official Microsoft Download Center](https://www.microsoft.com/en-us/download/details.aspx?id=51109)

再次声明：LauncherX仅支持64位操作系统，因而在上方的链接里，所指向的均为适用于64位操作系统的更新安装包。

安装后，如果有必要的话，请尝试重启电脑以让更新内容完全生效。

---

---
url: /zhCN/projbobcat/additionalParsers.md
---
# 附加解析器

ProjBobcat 为了和 Mojang 官方的启动器保持同样的行为，
我们为其实现了一些额外的解析器来帮助我们和官方启动器保持数据和档案的同步。

下表是目前已经实现的解析器：

|              名称              |          说明           |
|:----------------------------:|:---------------------:|
| DefaultLauncherAccountParser | 用于将验证信息写入到官方启动器的配置文件  |
| DefaultLauncherProfileParser | 用于将搜索到的本地游戏写入启动器的配置文件 |

---

---
url: /zhCN/lxguide/features/tricks/restricted-client.md
---
# 限制客户端

::: info 服主功能

此功能适合想要限制玩家登录方式的服主使用。这些设置可以在导出完整包时轻松地通过导出前配置完成，而无需直接影响当前正在使用的启动器。相关阅读：[LauncherX的整合包支持 | 日冕知识库](/zhCN/lxguide/features/modpack-support.html#·-额外选项)

:::

\[\[toc]]

## 限制账户登录

### 限制账户类型

LauncherX允许限制用户只能使用指定的游戏账户登录方式。此功能需要在LauncherX工作目录下的`LauncherX`文件夹内创建名为`DISABLE_CREATE_ACCOUNT_TYPE`的文件完成。

这个文件的内容逐行接受这些预期的文字：`Offline` /`Microsoft` /`ThirdParty`。LauncherX读取这个文件时是**大小写敏感**的。

举例，以下的写法将只允许玩家添加\[微软登录、第三方验证]：

```
Offline
```

也就是说，写在此flag文件的登录方式将被**禁用**。

::: danger

不可以同时选择三个禁用。三个都禁用将被视为无效的flag文件。

:::

### 限制特定的第三方登录

LauncherX允许限制特定的第三方认证的外置登录服务器。此功能需要在LauncherX工作目录下的`LauncherX`文件夹内创建名为`LIMIT_THIRD_PARTY_LOGIN_API`的文件完成。

这个功能可以和**限制账户类型**搭配使用。

文件的内容必须是**一行URL**，指向外置登录时的验证服务。比如：

```text
https://api.skin.org/yggdrasil
```

暂不支持限制“仅允许列表内的外置登录”，因此仅可以设置一个外置登录验证服务器。即便如下写了多行URL：

```
https://api.skin.org/yggdrasil
https://giganticskin.org/yggdrasil
```

也是无效的，只会使用第一个URL。

---

---
url: /zhCN/projbobcat/authenticators.md
---
# 验证模型

在 ProjBobcat 中，我们已经为开发者实现了您在 MineCraft 开发过程中可能遇到的所有的验证情形。

## 支持列表

|          模型名称           |    适用情形     |
|:-----------------------:|:-----------:|
|  OfflineAuthenticator   |   离线验证模型    |
| YggdrasilAuthenticator  | 适用于旧版本的登录模型 |
| MicrosoftAuthenticator  |  新版的微软验证模型  |
